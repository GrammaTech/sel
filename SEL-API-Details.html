<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This file documents the Software Evolution library

Copyright (C) 2014-2018 Eric Schulte and GrammaTech

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with the Invariant Section being "GNU GENERAL PUBLIC LICENSE,"
A copy of the license is included in the section entitled
"GNU Free Documentation License." -->
<!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>SEL API Details (Software Evolution Library)</title>

<meta name="description" content="SEL API Details (Software Evolution Library)">
<meta name="keywords" content="SEL API Details (Software Evolution Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="SEL-API.html#SEL-API" rel="up" title="SEL API">
<link href="SEL-Utility-API.html#SEL-Utility-API" rel="next" title="SEL Utility API">
<link href="SEL-API-Concept-Index.html#SEL-API-Concept-Index" rel="prev" title="SEL API Concept Index">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<a name="SEL-API-Details"></a>
<div class="header">
<p>
Next: <a href="SEL-Utility-API.html#SEL-Utility-API" accesskey="n" rel="next">SEL Utility API</a>, Previous: <a href="SEL-API-Concept-Index.html#SEL-API-Concept-Index" accesskey="p" rel="prev">SEL API Concept Index</a>, Up: <a href="SEL-API.html#SEL-API" accesskey="u" rel="up">SEL API</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html#Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="SEL-API-Details-1"></a>
<h3 class="unnumberedsec">SEL API Details</h3>
<a name="Constant-_002bc_002darithmetic_002dassignment_002doperators_002b"></a><dl>
<dt><a name="index-_002bc_002darithmetic_002dassignment_002doperators_002b"></a>Constant: <strong>+c-arithmetic-assignment-operators+</strong></dt>
<dd><p>C arithmetic assignment operators.
</p></dd></dl>
<a name="Constant-_002bc_002dbitwise_002dbinary_002doperators_002b"></a><dl>
<dt><a name="index-_002bc_002dbitwise_002dbinary_002doperators_002b"></a>Constant: <strong>+c-bitwise-binary-operators+</strong></dt>
<dd><p>C bitwise operators on two arguments.
</p></dd></dl>
<a name="Constant-_002bc_002dpointer_002dunary_002doperators_002b"></a><dl>
<dt><a name="index-_002bc_002dpointer_002dunary_002doperators_002b"></a>Constant: <strong>+c-pointer-unary-operators+</strong></dt>
<dd><p>C pointer operators on one arguments.
</p></dd></dl>
<a name="Generic_002dFunction-add_002dinclude"></a><dl>
<dt><a name="index-add_002dinclude"></a>Generic Function: <strong>add-include</strong> <em>software include</em></dt>
<dd><p>Add an #include directive for an <code>include</code> to <code>software</code>.
</p></dd></dl>
<a name="Method-add_002dinclude-_0028_0028obj-clang_0029-_0028include-string_0029_0029"></a><dl>
<dt><a name="index-add_002dinclude-1"></a>Method: <strong>add-include</strong> <em>(obj clang) (include string)</em></dt>
<dd><p>Add an #include directive for an <code>include</code> to <code>obj</code>.
</p><ul>
<li> <code>obj</code> object to modify
</li><li> <code>include</code> header to include in <code>obj</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-apply_002dmutations"></a><dl>
<dt><a name="index-apply_002dmutations"></a>Generic Function: <strong>apply-mutations</strong> <em>software mutation n</em></dt>
<dd><p>Apply <code>mutation</code> to the first <code>n</code> targets in <code>software</code>.
Returns the resulting software objects.  Returns a list of the applied
mutations as an optional second value.
</p></dd></dl>
<a name="Method-apply_002dmutations-_0028_0028project-project_0029-_0028mut-mutation_0029-n_0029"></a><dl>
<dt><a name="index-apply_002dmutations-1"></a>Method: <strong>apply-mutations</strong> <em>(project project) (mut mutation) n</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-apply_002dmutations-_0028_0028obj-software_0029-_0028mut-mutation_0029-n_0029"></a><dl>
<dt><a name="index-apply_002dmutations-2"></a>Method: <strong>apply-mutations</strong> <em>(obj software) (mut mutation) n</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mut</code> <code>docfixme</code>
</li><li> <code>n</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Structure-ast"></a><dl>
<dt><a name="index-ast"></a>Structure: <strong>ast</strong></dt>
<dd><p>Class precedence list: <code>ast, structure-object, t</code>
</p>
<p>Base type of sub-tree of an applicative AST tree.
</p></dd></dl>
<a name="Structure-ast_002dnode"></a><dl>
<dt><a name="index-ast_002dnode"></a>Structure: <strong>ast-node</strong></dt>
<dd><p>Class precedence list: <code>ast-node, structure-object, t</code>
</p>
<p>Base type of immutable portion of ast nodes.
</p></dd></dl>
<a name="Structure-clang_002dast"></a><dl>
<dt><a name="index-clang_002dast"></a>Structure: <strong>clang-ast</strong></dt>
<dd><p>Class precedence list: <code>clang-ast, ast, structure-object, t</code>
</p>
<p>AST generated by clang-mutate.
</p></dd></dl>
<a name="Structure-clang_002dast_002dnode"></a><dl>
<dt><a name="index-clang_002dast_002dnode"></a>Structure: <strong>clang-ast-node</strong></dt>
<dd><p>Class precedence list: <code>clang-ast-node, ast-node, structure-object, t</code>
</p>
<p>Immutable structure holding <code>clang-ast-node</code> slots.
</p></dd></dl>
<a name="Structure-clang_002dtype"></a><dl>
<dt><a name="index-clang_002dtype"></a>Structure: <strong>clang-type</strong></dt>
<dd><p>Class precedence list: <code>clang-type, structure-object, t</code>
</p>
<p>Immutable structure holding <code>clang-type</code> slots.
</p></dd></dl>
<a name="Class-adaptive_002dmutation"></a><dl>
<dt><a name="index-adaptive_002dmutation"></a>Class: <strong>adaptive-mutation</strong></dt>
<dd><p>Class precedence list: <code>adaptive-mutation, software, standard-object, t</code>
</p>
<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-add_002dsubtract_002dtree"></a><dl>
<dt><a name="index-add_002dsubtract_002dtree"></a>Class: <strong>add-subtract-tree</strong></dt>
<dd><p>Class precedence list: <code>add-subtract-tree, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-ancestral"></a><dl>
<dt><a name="index-ancestral"></a>Class: <strong>ancestral</strong></dt>
<dd><p>Class precedence list: <code>ancestral, software, standard-object, t</code>
</p>
<p>Class adding ancestry tracking to software.
</p></dd></dl>
<a name="Generic_002dFunction-apply_002dall_002dmutations"></a><dl>
<dt><a name="index-apply_002dall_002dmutations"></a>Generic Function: <strong>apply-all-mutations</strong> <em>software mutation</em></dt>
<dd><p>Apply <code>mutation</code> to every target in <code>software</code>.
Returns the resulting software objects.  Returns a list of the applied
mutations as an optional second value.
</p></dd></dl>
<a name="Method-apply_002dall_002dmutations-_0028_0028obj-software_0029-_0028mut-mutation_0029_0029"></a><dl>
<dt><a name="index-apply_002dall_002dmutations-1"></a>Method: <strong>apply-all-mutations</strong> <em>(obj software) (mut mutation)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mut</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-apply_002dmutation"></a><dl>
<dt><a name="index-apply_002dmutation"></a>Generic Function: <strong>apply-mutation</strong> <em>software mutation</em></dt>
<dd><p>Apply <code>mutation</code> to <code>software</code>, return the resulting software object.
Mutation application may destructively modify the software object, or it may return a
new instance with the mutation applied, and leave the original untouched. Any client
which calls apply-mutation should ensure that the result returned by apply-mutation is 
captured, and should not make assumptions about the state of the original.
</p>
<p>Example:  (let ((mutated-software (apply-mutation (copy software) mutation)))
              ...
</p>
<p>Define an :around method on this function to record mutations.
</p></dd></dl>
<a name="Method-apply_002dmutation-_0028_0028obj-coq_0029-_0028mutation-type_002dsafe_002dswap_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-1"></a>Method: <strong>apply-mutation</strong> <em>(obj coq) (mutation type-safe-swap)</em></dt>
<dd><p>Apply a &lsquo;type-safe-swap&rsquo; <code>mutation</code> to Coq object <code>obj</code>.
</p></dd></dl>
<a name="Method-apply_002dmutation-before-_0028_0028obj-ancestral_0029-op_0029"></a><dl>
<dt><a name="index-before-apply_002dmutation"></a>Method: <strong>before apply-mutation</strong> <em>(obj ancestral) op</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>op</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028llvm-llvm_0029-op_0029"></a><dl>
<dt><a name="index-apply_002dmutation-2"></a>Method: <strong>apply-mutation</strong> <em>(llvm llvm) op</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>llvm</code> <code>docfixme</code>
</li><li> <code>op</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-after-_0028_0028obj-clang_002dw_002dfodder_0029-mutation_0029"></a><dl>
<dt><a name="index-after-apply_002dmutation"></a>Method: <strong>after apply-mutation</strong> <em>(obj clang-w-fodder) mutation</em></dt>
<dd><p>Inject fodder dependencies such as types, macros, and headers after a fodder
<code>mutation</code> has been applied to <code>obj</code>.
</p><ul>
<li> <code>obj</code> software object modified by <code>mutation</code>
</li><li> <code>mutation</code> operations applied to <code>obj</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028software-clang_0029-_0028mutation-clang_002dmutation_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-3"></a>Method: <strong>apply-mutation</strong> <em>(software clang) (mutation clang-mutation)</em></dt>
<dd><p>Apply <code>mutation</code> to <code>software</code>, returning the resulting <code>software</code>.
</p><ul>
<li> <code>software</code> object to be mutated
</li><li> <code>mutation</code> mutation to be performed
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028software-java_0029-_0028mutation-java_002dmutation_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-4"></a>Method: <strong>apply-mutation</strong> <em>(software java) (mutation java-mutation)</em></dt>
<dd><p>Driver function to mutate java source.
Build-op function prepends the mutation function (cut, replace, swap,
insert).
</p></dd></dl>
<a name="Method-apply_002dmutation-_0028_0028java-java_0029-_0028op-list_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-5"></a>Method: <strong>apply-mutation</strong> <em>(java java) (op list)</em></dt>
<dd><p>Helper method for initializing mutation objects when a list is provided.
</p></dd></dl>
<a name="Method-apply_002dmutation-_0028_0028cil-cil_0029-op_0029"></a><dl>
<dt><a name="index-apply_002dmutation-6"></a>Method: <strong>apply-mutation</strong> <em>(cil cil) op</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-apply_002dmutation-_0028_0028obj-parseable_0029-_0028op-list_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-7"></a>Method: <strong>apply-mutation</strong> <em>(obj parseable) (op list)</em></dt>
<dd><p>Apply <code>ops</code> to <code>software</code>, returning the resulting <code>software</code>.
</p><ul>
<li> <code>obj</code> object to be mutated
</li><li> <code>op</code> mutation to be performed
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028software-parseable_0029-_0028mutation-parseable_002dmutation_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-8"></a>Method: <strong>apply-mutation</strong> <em>(software parseable) (mutation parseable-mutation)</em></dt>
<dd><p>Apply <code>mutation</code> to <code>software</code>, returning the resulting <code>software</code>.
</p><ul>
<li> <code>software</code> object to be mutated
</li><li> <code>mutation</code> mutation to be performed
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028elf-elf_002drisc_0029-mut_0029"></a><dl>
<dt><a name="index-apply_002dmutation-9"></a>Method: <strong>apply-mutation</strong> <em>(elf elf-risc) mut</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-apply_002dmutation-_0028_0028elf-elf_002dcisc_0029-mut_0029"></a><dl>
<dt><a name="index-apply_002dmutation-10"></a>Method: <strong>apply-mutation</strong> <em>(elf elf-cisc) mut</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-apply_002dmutation-_0028_0028asm-asm_002dheap_0029-_0028mutation-asm_002dreplace_002doperand_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-11"></a>Method: <strong>apply-mutation</strong> <em>(asm asm-heap) (mutation asm-replace-operand)</em></dt>
<dd><p>Apply an asm-replace-operand <code>mutation</code> to <code>asm-heap</code>, return the resulting
software. The <code>mutation</code> targets are a pair of instruction indices pointing
to a &quot;bad&quot; instruction (whose operand will be replaced) and
a &quot;good&quot; instruction (whose operand will be used as the replacement).
If either instruction lacks an operand, a &lsquo;no-mutation-targets&rsquo; condition
is raised.
</p></dd></dl>
<a name="Method-apply_002dmutation-_0028_0028asm-asm_002dheap_0029-_0028mutation-simple_002dswap_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-12"></a>Method: <strong>apply-mutation</strong> <em>(asm asm-heap) (mutation simple-swap)</em></dt>
<dd><p>Swap the values at two locations in ASM as specified by <code>mutation</code>.
</p></dd></dl>
<a name="Method-apply_002dmutation-_0028_0028asm-asm_002dheap_0029-_0028mutation-simple_002dinsert_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-13"></a>Method: <strong>apply-mutation</strong> <em>(asm asm-heap) (mutation simple-insert)</em></dt>
<dd><p>Insert a value into location of ASM as specified by <code>mutation</code>.
</p></dd></dl>
<a name="Method-apply_002dmutation-_0028_0028asm-asm_002dheap_0029-_0028mutation-simple_002dcut_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-14"></a>Method: <strong>apply-mutation</strong> <em>(asm asm-heap) (mutation simple-cut)</em></dt>
<dd><p>Implement simple-cut mutation on <code>asm-heap</code>.
</p></dd></dl>
<a name="Method-apply_002dmutation-_0028_0028asm-asm_0029-_0028mutation-asm_002dreplace_002doperand_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-15"></a>Method: <strong>apply-mutation</strong> <em>(asm asm) (mutation asm-replace-operand)</em></dt>
<dd><p>Apply an asm-replace-operand <code>mutation</code> to ASM, return the resulting software.
The <code>mutation</code> targets are a pair of instruction indices pointing to a &quot;bad&quot;
instruction (whose operand will be replaced) and a &quot;good&quot; instruction
(whose operand will be used as the replacement). If either instruction lacks an
operand, a &lsquo;no-mutation-targets&rsquo; condition is raised.
</p></dd></dl>
<a name="Method-apply_002dmutation-_0028_0028obj-expression_0029-_0028mutation-random_002dsubtree_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-16"></a>Method: <strong>apply-mutation</strong> <em>(obj expression) (mutation random-subtree)</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mutation</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028obj-expression_0029-_0028mutation-double_002dhalf_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-17"></a>Method: <strong>apply-mutation</strong> <em>(obj expression) (mutation double-half)</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mutation</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028obj-expression_0029-_0028mutation-subtract_002dadd_002dtree_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-18"></a>Method: <strong>apply-mutation</strong> <em>(obj expression) (mutation subtract-add-tree)</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mutation</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028obj-expression_0029-_0028mut-add_002dsubtract_002dscope_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-19"></a>Method: <strong>apply-mutation</strong> <em>(obj expression) (mut add-subtract-scope)</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mut</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028obj-expression_0029-_0028mutation-add_002dsubtract_002dtree_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-20"></a>Method: <strong>apply-mutation</strong> <em>(obj expression) (mutation add-subtract-tree)</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mutation</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028obj-expression_0029-_0028mutation-subtract_002dadd_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-21"></a>Method: <strong>apply-mutation</strong> <em>(obj expression) (mutation subtract-add)</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mutation</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028obj-expression_0029-_0028mutation-add_002dsubtract_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-22"></a>Method: <strong>apply-mutation</strong> <em>(obj expression) (mutation add-subtract)</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mutation</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028obj-expression_0029-_0028mutation-mult_002ddivide_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-23"></a>Method: <strong>apply-mutation</strong> <em>(obj expression) (mutation mult-divide)</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mutation</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028obj-expression_0029-_0028mutation-demote_002dbinop_002dright_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-24"></a>Method: <strong>apply-mutation</strong> <em>(obj expression) (mutation demote-binop-right)</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mutation</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028obj-expression_0029-_0028mutation-demote_002dbinop_002dleft_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-25"></a>Method: <strong>apply-mutation</strong> <em>(obj expression) (mutation demote-binop-left)</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mutation</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028obj-expression_0029-_0028mutation-change_002dconstant_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-26"></a>Method: <strong>apply-mutation</strong> <em>(obj expression) (mutation change-constant)</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mutation</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028obj-expression_0029-_0028mutation-change_002doperator_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-27"></a>Method: <strong>apply-mutation</strong> <em>(obj expression) (mutation change-operator)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mutation</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028lisp-lisp_0029-_0028mutation-lisp_002dswap_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-28"></a>Method: <strong>apply-mutation</strong> <em>(lisp lisp) (mutation lisp-swap)</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>lisp</code> <code>docfixme</code>
</li><li> <code>mutation</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028lisp-lisp_0029-_0028mutation-lisp_002dreplace_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-29"></a>Method: <strong>apply-mutation</strong> <em>(lisp lisp) (mutation lisp-replace)</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>lisp</code> <code>docfixme</code>
</li><li> <code>mutation</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028lisp-lisp_0029-_0028mutation-lisp_002dcut_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-30"></a>Method: <strong>apply-mutation</strong> <em>(lisp lisp) (mutation lisp-cut)</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>lisp</code> <code>docfixme</code>
</li><li> <code>mutation</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-apply_002dmutation-_0028_0028range-sw_002drange_0029-_0028mutation-simple_002dswap_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-31"></a>Method: <strong>apply-mutation</strong> <em>(range sw-range) (mutation simple-swap)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-apply_002dmutation-_0028_0028range-sw_002drange_0029-_0028mutation-simple_002dinsert_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-32"></a>Method: <strong>apply-mutation</strong> <em>(range sw-range) (mutation simple-insert)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-apply_002dmutation-_0028_0028range-sw_002drange_0029-_0028mutation-simple_002dcut_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-33"></a>Method: <strong>apply-mutation</strong> <em>(range sw-range) (mutation simple-cut)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-apply_002dmutation-_0028_0028simple-simple_0029-_0028mutation-simple_002dswap_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-34"></a>Method: <strong>apply-mutation</strong> <em>(simple simple) (mutation simple-swap)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-apply_002dmutation-_0028_0028simple-simple_0029-_0028mutation-simple_002dinsert_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-35"></a>Method: <strong>apply-mutation</strong> <em>(simple simple) (mutation simple-insert)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-apply_002dmutation-_0028_0028simple-simple_0029-_0028mutation-simple_002dcut_0029_0029"></a><dl>
<dt><a name="index-apply_002dmutation-36"></a>Method: <strong>apply-mutation</strong> <em>(simple simple) (mutation simple-cut)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-apply_002dmutation-before-_0028_0028obj-software_0029-_0028mut-mutation_0029_0029"></a><dl>
<dt><a name="index-before-apply_002dmutation-1"></a>Method: <strong>before apply-mutation</strong> <em>(obj software) (mut mutation)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mut</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-apply_002dpicked_002dmutations"></a><dl>
<dt><a name="index-apply_002dpicked_002dmutations"></a>Generic Function: <strong>apply-picked-mutations</strong> <em>software mutation n</em></dt>
<dd><p>Apply <code>mutation</code> to <code>n</code> randomly selected targets in <code>software</code>.
Returns the resulting software objects.  Returns a list of the applied
mutations as an optional second value.
</p></dd></dl>
<a name="Method-apply_002dpicked_002dmutations-_0028_0028project-project_0029-_0028mut-mutation_0029-n_0029"></a><dl>
<dt><a name="index-apply_002dpicked_002dmutations-1"></a>Method: <strong>apply-picked-mutations</strong> <em>(project project) (mut mutation) n</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-apply_002dpicked_002dmutations-_0028_0028obj-software_0029-_0028mut-mutation_0029-n_0029"></a><dl>
<dt><a name="index-apply_002dpicked_002dmutations-2"></a>Method: <strong>apply-picked-mutations</strong> <em>(obj software) (mut mutation) n</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mut</code> <code>docfixme</code>
</li><li> <code>n</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Class-asm"></a><dl>
<dt><a name="index-asm"></a>Class: <strong>asm</strong></dt>
<dd><p>Class precedence list: <code>asm, simple, software, standard-object, t</code>
</p>
<p>General assembler backend used to manipulate &quot;.s&quot; text assembler.
</p></dd></dl>
<a name="Class-asm_002dheap"></a><dl>
<dt><a name="index-asm_002dheap"></a>Class: <strong>asm-heap</strong></dt>
<dd><p>Class precedence list: <code>asm-heap, asm, simple, software, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>function-index</code> &mdash; initarg: <code><span class="nolinebreak">:function-index</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:function-index</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:function-index)</span><!-- /@w --></code>

<p>Create this on demand.
</p></li></ul>

<p>Alternative to <code>simple</code> software objects which should use less memory.
Similar to <code>range</code>, but allows for adding and mutating lines, and should
be able to handle type of mutation we need. The <code>genome</code> is a vector of
references into the asm-heap (asm-line-info) describes the code.
</p></dd></dl>
<a name="Class-asm_002dreplace_002doperand"></a><dl>
<dt><a name="index-asm_002dreplace_002doperand"></a>Class: <strong>asm-replace-operand</strong></dt>
<dd><p>Class precedence list: <code>asm-replace-operand, simple-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Select two instructions, and replace an operand in the first
with an operand in the second.
</p></dd></dl>
<a name="Class-asm_002dsuper_002dmutant"></a><dl>
<dt><a name="index-asm_002dsuper_002dmutant"></a>Class: <strong>asm-super-mutant</strong></dt>
<dd><p>Class precedence list: <code>asm-super-mutant, asm-heap, asm, simple, super-mutant, software, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>input-spec</code> &mdash; initarg: <code><span class="nolinebreak">:input-spec</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library::input-spec</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::input-spec)</span><!-- /@w --></code>

<p>Vector of <code>input-specification</code> structs, one for each test case.
</p></li><li> <code>output-spec</code> &mdash; initarg: <code><span class="nolinebreak">:output-spec</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library::output-spec</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::output-spec)</span><!-- /@w --></code>

<p>Vector of <code>input-specification</code> structs, one for each test case.
</p></li><li> <code>var-table</code> &mdash; initarg: <code><span class="nolinebreak">:var-table</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library::var-table</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::var-table)</span><!-- /@w --></code>

<p>Vector of var-rec (data/address records)
</p></li><li> <code>target-start-index</code> &mdash; initarg: <code><span class="nolinebreak">:target-start-index</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library::target-start-index</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::target-start-index)</span><!-- /@w --></code>

<p>Integer index represents the first line of target code.
</p></li><li> <code>target-end-index</code> &mdash; initarg: <code><span class="nolinebreak">:target-end-index</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library::target-end-index</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::target-end-index)</span><!-- /@w --></code>

<p>Integer index represents the last line of target code.
</p></li><li> <code>target-info</code> &mdash; initarg: <code><span class="nolinebreak">:target-info</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library::target-info</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::target-info)</span><!-- /@w --></code>

<p>Function index entry of the target function
</p></li><li> <code>target-lines</code> &mdash; initarg: <code><span class="nolinebreak">:target-lines</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library::target-lines</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::target-lines)</span><!-- /@w --></code>

<p>Cache the lines of the target code, as they are used often.
</p></li><li> <code>assembler</code> &mdash; initarg: <code>:assembler<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:assembler</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:assembler)</span><!-- /@w --></code>

<p>Assembler to use for assembling.
</p></li><li> <code>fitness-harness</code> &mdash; initarg: <code><span class="nolinebreak">:fitness-harness</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:fitness-harness</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:fitness-harness)</span><!-- /@w --></code>

<p>Pathname to the fitness harness file <code>(c program source)</code>
</p></li></ul>

<p>Combine <code>super-mutant</code> capabilities with <code>asm-heap</code> framework.
</p></dd></dl>
<a name="Generic_002dFunction-ast_002dfull_002dstmt_002dbi_002dgrams_002dextractor"></a><dl>
<dt><a name="index-ast_002dfull_002dstmt_002dbi_002dgrams_002dextractor"></a>Generic Function: <strong>ast-full-stmt-bi-grams-extractor</strong> <em>software</em></dt>
<dd><p>Return a feature vector counting AST node type bi-grams for full statements.
</p></dd></dl>
<a name="Generic_002dFunction-ast_002dnode_002dtypes"></a><dl>
<dt><a name="index-ast_002dnode_002dtypes"></a>Generic Function: <strong>ast-node-types</strong> <em>software</em></dt>
<dd><p>Return a list of the node types present in the ASTs in <code>software</code>.
</p></dd></dl>
<a name="Method-ast_002dnode_002dtypes-_0028_0028clang-clang_0029_0029"></a><dl>
<dt><a name="index-ast_002dnode_002dtypes-1"></a>Method: <strong>ast-node-types</strong> <em>(clang clang)</em></dt>
<dd><p>Return a list of the ast classes that occur in <code>clang</code>
</p></dd></dl>
<a name="Generic_002dFunction-ast_002dpatch"></a><dl>
<dt><a name="index-ast_002dpatch"></a>Generic Function: <strong>ast-patch</strong> <em>original diff</em></dt>
<dd><p>Create an edited AST by applying <code>diff</code> to <code>original</code>.
</p>
<p>A diff is a sequence of actions as returned by &lsquo;ast-diff&rsquo; including:
:same A <code>b</code>  <code>:</code> keep the current AST
:insert <code>b</code>  <code>:</code> insert <code>b</code> at the current position
:remove A  <code>:</code> remove the current AST
:recurse <code>s</code> <code>:</code> recursively apply script <code>s</code> to the current AST
</p></dd></dl>
<a name="Generic_002dFunction-bad_002dstmts"></a><dl>
<dt><a name="index-bad_002dstmts"></a>Generic Function: <strong>bad-stmts</strong> <em>software</em></dt>
<dd><p>Return a list of all bad statement asts in <code>software</code>.
</p></dd></dl>
<a name="Method-bad_002dstmts-_0028_0028obj-coq_0029_0029"></a><dl>
<dt><a name="index-bad_002dstmts-1"></a>Method: <strong>bad-stmts</strong> <em>(obj coq)</em></dt>
<dd><p>Return a list of the indices of bad statements in <code>obj</code>.
</p></dd></dl>
<a name="Method-bad_002dstmts-_0028_0028clang-clang_0029_0029"></a><dl>
<dt><a name="index-bad_002dstmts-2"></a>Method: <strong>bad-stmts</strong> <em>(clang clang)</em></dt>
<dd><p>Return a list of all bad statement ASTs in <code>clang</code>.
</p></dd></dl>
<a name="Generic_002dFunction-bi_002dgrams_002dhashtable_002dto_002dfeature"></a><dl>
<dt><a name="index-bi_002dgrams_002dhashtable_002dto_002dfeature"></a>Generic Function: <strong>bi-grams-hashtable-to-feature</strong> <em>software bi-grams</em></dt>
<dd><p>Return a feature-vector containing counts of bi-grams in
<code>software</code> stored in <code>bi-grams</code>.
</p></dd></dl>
<a name="Method-bi_002dgrams_002dhashtable_002dto_002dfeature-_0028_0028clang-clang_0029-_0028bi_002dgrams-hash_002dtable_0029_0029"></a><dl>
<dt><a name="index-bi_002dgrams_002dhashtable_002dto_002dfeature-1"></a>Method: <strong>bi-grams-hashtable-to-feature</strong> <em>(clang clang) (bi-grams hash-table)</em></dt>
<dd><p>Return a feature-vector containing counts of bi-grams in <code>clang</code> stored in
hash-table <code>bi-grams</code>.
</p><ul>
<li> <code>clang</code> a clang software object
</li><li> <code>bi-grams</code> a hash-table containing bi-grams counts
</li></ul>
</dd></dl>
<a name="Condition-eval_002derror"></a><dl>
<dt><a name="index-eval_002derror"></a>Condition: <strong>eval-error</strong></dt>
<dd><p>Class precedence list: <code>eval-error, error, serious-condition, condition, t</code>
</p>
<p><code>docfixme</code>
</p></dd></dl>
<a name="Condition-no_002dmutation_002dtargets"></a><dl>
<dt><a name="index-no_002dmutation_002dtargets"></a>Condition: <strong>no-mutation-targets</strong></dt>
<dd><p>Class precedence list: <code>no-mutation-targets, mutate, error, serious-condition, condition, t</code>
</p>
<p>This is a particularly benign form of mutation error.
A common restart is &lsquo;ignore-failed-mutation&rsquo;.
</p></dd></dl>
<a name="Class-change_002dconstant"></a><dl>
<dt><a name="index-change_002dconstant"></a>Class: <strong>change-constant</strong></dt>
<dd><p>Class precedence list: <code>change-constant, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-change_002doperator"></a><dl>
<dt><a name="index-change_002doperator"></a>Class: <strong>change-operator</strong></dt>
<dd><p>Class precedence list: <code>change-operator, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-clang_002dcut"></a><dl>
<dt><a name="index-clang_002dcut"></a>Class: <strong>clang-cut</strong></dt>
<dd><p>Class precedence list: <code>clang-cut, clang-mutation, parseable-cut, parseable-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform a cut operation on a clang software object.
</p></dd></dl>
<a name="Class-clang_002dcut_002dfull"></a><dl>
<dt><a name="index-clang_002dcut_002dfull"></a>Class: <strong>clang-cut-full</strong></dt>
<dd><p>Class precedence list: <code>clang-cut-full, clang-cut, clang-mutation, parseable-cut, parseable-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform a cut operation on a clang software object,
only cutting full statements.
</p></dd></dl>
<a name="Class-clang_002dexpression"></a><dl>
<dt><a name="index-clang_002dexpression"></a>Class: <strong>clang-expression</strong></dt>
<dd><p>Class precedence list: <code>clang-expression, expression, lisp, simple, software, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>scope</code> &mdash; initarg: <code>:scope<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:scope</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:scope)</span><!-- /@w --></code>

<p>List of in-scope variable names.
</p></li></ul>

<p>C arithmetic expressions represented as trees to allow direct evaluation.
</p></dd></dl>
<a name="Class-clang_002dinsert"></a><dl>
<dt><a name="index-clang_002dinsert"></a>Class: <strong>clang-insert</strong></dt>
<dd><p>Class precedence list: <code>clang-insert, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform an insertion operation on a clang software object.
</p></dd></dl>
<a name="Class-clang_002dinsert_002dfull"></a><dl>
<dt><a name="index-clang_002dinsert_002dfull"></a>Class: <strong>clang-insert-full</strong></dt>
<dd><p>Class precedence list: <code>clang-insert-full, clang-insert, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform an insertion operation on a clang software object,
only inserting full statements.
</p></dd></dl>
<a name="Class-clang_002dinsert_002dsame"></a><dl>
<dt><a name="index-clang_002dinsert_002dsame"></a>Class: <strong>clang-insert-same</strong></dt>
<dd><p>Class precedence list: <code>clang-insert-same, clang-insert, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform an insertion operation on a clang software object,
only inserting statements of the same AST class as the preceding statement.
</p></dd></dl>
<a name="Class-clang_002dinstrumenter"></a><dl>
<dt><a name="index-clang_002dinstrumenter"></a>Class: <strong>clang-instrumenter</strong></dt>
<dd><p>Class precedence list: <code>clang-instrumenter, instrumenter, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>names</code> &mdash; initarg: <code>:names<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library::names</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::names)</span><!-- /@w --></code>

<p>Mapping of names to indices.
</p></li><li> <code>types</code> &mdash; initarg: <code>:types<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:types</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:types)</span><!-- /@w --></code>

<p>Mapping of trace type strings to indices.
</p></li><li> <code>type-descriptions</code> &mdash; initarg: <code><span class="nolinebreak">:type-descriptions</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library::type-descriptions</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::type-descriptions)</span><!-- /@w --></code>

<p>Mapping of type descriptions to indices.
</p></li><li> <code>ast-ids</code> &mdash; initarg: <code><span class="nolinebreak">:ast-ids</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:ast-ids</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:ast-ids)</span><!-- /@w --></code>

<p>Mapping of ASTs to trace ids.
</p></li></ul>

<p>Handles instrumentation for clang software objects.
</p></dd></dl>
<a name="Class-clang_002dmove"></a><dl>
<dt><a name="index-clang_002dmove"></a>Class: <strong>clang-move</strong></dt>
<dd><p>Class precedence list: <code>clang-move, clang-mutation, parseable-move, parseable-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform a move operation on a clang software object.
</p></dd></dl>
<a name="Class-clang_002dnop"></a><dl>
<dt><a name="index-clang_002dnop"></a>Class: <strong>clang-nop</strong></dt>
<dd><p>Class precedence list: <code>clang-nop, clang-mutation, parseable-nop, parseable-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform a nop on a clang software object.
</p></dd></dl>
<a name="Class-clang_002dproject"></a><dl>
<dt><a name="index-clang_002dproject"></a>Class: <strong>clang-project</strong></dt>
<dd><p>Class precedence list: <code>clang-project, project, software, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>project-dir</code> &mdash; initarg: <code><span class="nolinebreak">:project-dir</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:project-dir</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:project-dir)</span><!-- /@w --></code>

<p>Source directory containing the project.
</p></li><li> <code>compilation-database</code> &mdash; initarg: <code><span class="nolinebreak">:compilation-database</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:compilation-database</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:compilation-database)</span><!-- /@w --></code>

<p>Compilation database for the project.
See https://clang.llvm.org/docs/JSONCompilationDatabase.html for
information on the format of compilation databases.
</p></li><li> <code>clang-class</code> &mdash; initarg: <code><span class="nolinebreak">:clang-class</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library::clang-class</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::clang-class)</span><!-- /@w --></code>

<p>Clang subclass to utilize in the project.
</p></li></ul>

<p>Project specialization for clang software objects.
</p></dd></dl>
<a name="Class-clang_002dpromote_002dguarded"></a><dl>
<dt><a name="index-clang_002dpromote_002dguarded"></a>Class: <strong>clang-promote-guarded</strong></dt>
<dd><p>Class precedence list: <code>clang-promote-guarded, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Promote a guarded compound statement in a clang
software object.
</p></dd></dl>
<a name="Class-clang_002dreplace"></a><dl>
<dt><a name="index-clang_002dreplace"></a>Class: <strong>clang-replace</strong></dt>
<dd><p>Class precedence list: <code>clang-replace, clang-mutation, parseable-replace, parseable-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform a replace operation on a clang software object.
</p></dd></dl>
<a name="Class-clang_002dreplace_002dfull"></a><dl>
<dt><a name="index-clang_002dreplace_002dfull"></a>Class: <strong>clang-replace-full</strong></dt>
<dd><p>Class precedence list: <code>clang-replace-full, clang-replace, clang-mutation, parseable-replace, parseable-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform a replace operation on a clang software object,
only replacing full statements.
</p></dd></dl>
<a name="Class-clang_002dreplace_002dfull_002dsame"></a><dl>
<dt><a name="index-clang_002dreplace_002dfull_002dsame"></a>Class: <strong>clang-replace-full-same</strong></dt>
<dd><p>Class precedence list: <code>clang-replace-full-same, clang-replace, clang-mutation, parseable-replace, parseable-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform a replace operation on a clang software object,
only replacing full statements of the same AST class.
</p></dd></dl>
<a name="Class-clang_002dswap"></a><dl>
<dt><a name="index-clang_002dswap"></a>Class: <strong>clang-swap</strong></dt>
<dd><p>Class precedence list: <code>clang-swap, clang-mutation, parseable-swap, parseable-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform a swap operation on a clang software object.
</p></dd></dl>
<a name="Class-clang_002dswap_002dfull_002dsame"></a><dl>
<dt><a name="index-clang_002dswap_002dfull_002dsame"></a>Class: <strong>clang-swap-full-same</strong></dt>
<dd><p>Class precedence list: <code>clang-swap-full-same, clang-swap, clang-mutation, parseable-swap, parseable-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform a swap operation on a clang software object,
only full statements of the same AST class.
</p></dd></dl>
<a name="Class-clang_002dswap_002dsame"></a><dl>
<dt><a name="index-clang_002dswap_002dsame"></a>Class: <strong>clang-swap-same</strong></dt>
<dd><p>Class precedence list: <code>clang-swap-same, clang-swap, clang-mutation, parseable-swap, parseable-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform a swap operation on a clang software object,
only swapping statements of the same AST class.
</p></dd></dl>
<a name="Class-coq"></a><dl>
<dt><a name="index-coq"></a>Class: <strong>coq</strong></dt>
<dd><p>Class precedence list: <code>coq, lisp, simple, software, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>ast-ids</code> &mdash; initarg: <code><span class="nolinebreak">:ast-ids</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:ast-ids</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:ast-ids)</span><!-- /@w --></code>

<p>List of IDs for the ASTs when they were loaded.
</p></li><li> <code>project-file</code> &mdash; initarg: <code><span class="nolinebreak">:project-file</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:project-file</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:project-file)</span><!-- /@w --></code>

<p>Path to _CoqProject file, if it exists.
</p></li><li> <code>file-source</code> &mdash; initarg: <code><span class="nolinebreak">:file-source</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:file-source</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:file-source)</span><!-- /@w --></code>

<p>Name of source file.
</p></li><li> <code>imports</code> &mdash; initarg: <code>:imports<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:imports</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:imports)</span><!-- /@w --></code>

<p>ASTs for imports, not part of genome.
</p></li></ul>

<p>Coq software object.
</p></dd></dl>
<a name="Class-coq_002dproject"></a><dl>
<dt><a name="index-coq_002dproject"></a>Class: <strong>coq-project</strong></dt>
<dd><p>Class precedence list: <code>coq-project, project, software, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>project-file</code> &mdash; initarg: <code><span class="nolinebreak">:project-file</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:project-file</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:project-file)</span><!-- /@w --></code>

<p>Path to _CoqProject file, if it exists.
</p></li></ul>

<p>Coq project software object.
</p></dd></dl>
<a name="Class-csurf_002dasm"></a><dl>
<dt><a name="index-csurf_002dasm"></a>Class: <strong>csurf-asm</strong></dt>
<dd><p>Class precedence list: <code>csurf-asm, asm-heap, asm, simple, software, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>assembler</code> &mdash; initarg: <code>:assembler<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:assembler</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:assembler)</span><!-- /@w --></code>

<p>Assembler to use for assembling.
</p></li><li> <code>linker</code> &mdash; initarg: <code>:linker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:linker</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:linker)</span><!-- /@w --></code>

<p>Linker to use for linking.
</p></li><li> <code>flags</code> &mdash; initarg: <code>:flags<!-- /@w --></code>; reader: <code>elf:flags<!-- /@w --></code>; writer: <code>(setf&nbsp;elf:flags)<!-- /@w --></code>

<p>Flags to use for linking
</p></li><li> <code>asm-flags</code> &mdash; initarg: <code><span class="nolinebreak">:asm-flags</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:asm-flags</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:asm-flags)</span><!-- /@w --></code>

<p>Flags to pass to assembler.
</p></li><li> <code>redirect-file</code> &mdash; initarg: <code><span class="nolinebreak">:redirect-file</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:redirect-file</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:redirect-file)</span><!-- /@w --></code>

<p>CodeSurfer redirect file to redirect elf copy relocations.
</p></li><li> <code>linker-script</code> &mdash; initarg: <code><span class="nolinebreak">:linker-script</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:linker-script</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:linker-script)</span><!-- /@w --></code>

<p>CodeSurfer linker script to pin section locations.
</p></li><li> <code>weak-symbols</code> &mdash; initarg: <code><span class="nolinebreak">:weak-symbols</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:weak-symbols</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:weak-symbols)</span><!-- /@w --></code>

<p>Symbols to weaken with &lsquo;elf-weaken-gmon-start&rsquo;.
</p></li><li> <code>linked-files</code> &mdash; initarg: <code><span class="nolinebreak">:linked-files</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:linked-files</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:linked-files)</span><!-- /@w --></code>

<p>List of additional libraries to link.
</p></li></ul>

<p>Software object for ASM generated by CodeSurfer.
</p></dd></dl>
<a name="Class-cut_002ddecl"></a><dl>
<dt><a name="index-cut_002ddecl"></a>Class: <strong>cut-decl</strong></dt>
<dd><p>Class precedence list: <code>cut-decl, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform a cut operation on a DeclStmt AST in a clang software object.
</p></dd></dl>
<a name="Class-elf_002darm"></a><dl>
<dt><a name="index-elf_002darm"></a>Class: <strong>elf-arm</strong></dt>
<dd><p>Class precedence list: <code>elf-arm, elf-cisc, elf, simple, software, standard-object, t</code>
</p>
<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-elf_002dx86"></a><dl>
<dt><a name="index-elf_002dx86"></a>Class: <strong>elf-x86</strong></dt>
<dd><p>Class precedence list: <code>elf-x86, elf-cisc, elf, simple, software, standard-object, t</code>
</p>
<p><code>docfixme</code>
</p></dd></dl>
<a name="Variable-_002aasm_002dmutation_002dtypes_002a"></a><dl>
<dt><a name="index-_002aasm_002dmutation_002dtypes_002a"></a>Variable: <strong>*asm-mutation-types*</strong></dt>
<dd><p>Add asm mutations with probability 1/N, where <code>n</code> is the number of possible
mutations (simple plus asm mutations).
</p></dd></dl>
<a name="Variable-_002afree_002dvar_002ddecay_002drate_002a"></a><dl>
<dt><a name="index-_002afree_002dvar_002ddecay_002drate_002a"></a>Variable: <strong>*free-var-decay-rate*</strong></dt>
<dd><p>The decay rate for choosing variable bindings.
</p></dd></dl>
<a name="Variable-_002aprocess_002dkill_002dtimeout_002a"></a><dl>
<dt><a name="index-_002aprocess_002dkill_002dtimeout_002a"></a>Variable: <strong>*process-kill-timeout*</strong></dt>
<dd><p>Timeout (in seconds) before killing a process with <code>sigkill</code>
</p></dd></dl>
<a name="Constant-_002bc_002darithmetic_002dunary_002doperators_002b"></a><dl>
<dt><a name="index-_002bc_002darithmetic_002dunary_002doperators_002b"></a>Constant: <strong>+c-arithmetic-unary-operators+</strong></dt>
<dd><p>C arithmetic operators on one arguments.
</p></dd></dl>
<a name="Constant-_002bc_002dbitwise_002dunary_002doperators_002b"></a><dl>
<dt><a name="index-_002bc_002dbitwise_002dunary_002doperators_002b"></a>Constant: <strong>+c-bitwise-unary-operators+</strong></dt>
<dd><p>C bitwise operators on one arguments.
</p></dd></dl>
<a name="Constant-_002bc_002dsign_002dunary_002doperators_002b"></a><dl>
<dt><a name="index-_002bc_002dsign_002dunary_002doperators_002b"></a>Constant: <strong>+c-sign-unary-operators+</strong></dt>
<dd><p>C sign operators on one arguments.
</p></dd></dl>
<a name="Constant-_002binstrument_002dlog_002dvariable_002dname_002b"></a><dl>
<dt><a name="index-_002binstrument_002dlog_002dvariable_002dname_002b"></a>Constant: <strong>+instrument-log-variable-name+</strong></dt>
<dd><p>Variable used for instrumentation.
</p></dd></dl>
<a name="Class-add_002dsubtract"></a><dl>
<dt><a name="index-add_002dsubtract"></a>Class: <strong>add-subtract</strong></dt>
<dd><p>Class precedence list: <code>add-subtract, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-add_002dsubtract_002dscope"></a><dl>
<dt><a name="index-add_002dsubtract_002dscope"></a>Class: <strong>add-subtract-scope</strong></dt>
<dd><p>Class precedence list: <code>add-subtract-scope, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Variable-_002bsoftware_002devolution_002dlibrary_002dversion_002b"></a><dl>
<dt><a name="index-_002bsoftware_002devolution_002dlibrary_002dversion_002b"></a>Variable: <strong>+software-evolution-library-version+</strong></dt>
<dd><p>Current version of the <code>software-evolution-library</code>.
</p></dd></dl>
<a name="Generic_002dFunction-adjust_002dstmt_002drange"></a><dl>
<dt><a name="index-adjust_002dstmt_002drange"></a>Generic Function: <strong>adjust-stmt-range</strong> <em>software start end</em></dt>
<dd><p>Adjust <code>start</code> and <code>end</code> so that they represent a valid range for set-range.
The values returned will be STMT1 and STMT2, where STMT1 and STMT2 are both
full statements
</p></dd></dl>
<a name="Method-adjust_002dstmt_002drange-_0028_0028clang-clang_0029-start-end_0029"></a><dl>
<dt><a name="index-adjust_002dstmt_002drange-1"></a>Method: <strong>adjust-stmt-range</strong> <em>(clang clang) start end</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>clang</code> <code>docfixme</code>
</li><li> <code>start</code> <code>docfixme</code>
</li><li> <code>end</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-all_002dkeywords"></a><dl>
<dt><a name="index-all_002dkeywords"></a>Generic Function: <strong>all-keywords</strong> <em>software</em></dt>
<dd><p>Return the list of possible keywords that may appear in <code>software</code>.
</p></dd></dl>
<a name="Method-all_002dkeywords-_0028_0028clang-clang_0029_0029"></a><dl>
<dt><a name="index-all_002dkeywords-1"></a>Method: <strong>all-keywords</strong> <em>(clang clang)</em></dt>
<dd><p>Return the list of possible keywords that may appear in <code>clang</code>.
Uses &lsquo;*clang-c-keywords*&rsquo;.
</p></dd></dl>
<a name="Function-asm_002dsplit_002dinstruction"></a><dl>
<dt><a name="index-asm_002dsplit_002dinstruction"></a>Function: <strong>asm-split-instruction</strong> <em>instruction</em></dt>
<dd><p>Split <code>instruction</code> string on white space or commas. Return a list of strings.
</p></dd></dl>
<a name="Generic_002dFunction-ast_002ddepth"></a><dl>
<dt><a name="index-ast_002ddepth"></a>Generic Function: <strong>ast-depth</strong> <em>software ast</em></dt>
<dd><p>Depth of AST in <code>software</code>. The root node has a depth of 0.
</p></dd></dl>
<a name="Method-ast_002ddepth-around-_0028_0028clang-clang_0029-_0028ast-clang_002dast_0029_0029"></a><dl>
<dt><a name="index-around-ast_002ddepth"></a>Method: <strong>around ast-depth</strong> <em>(clang clang) (ast clang-ast)</em></dt>
<dd><p>Depth of AST in <code>clang</code>. The root node has a depth of 0
</p><ul>
<li> <code>clang</code> software object
</li><li> AST ast pointing to the root of the AST tree in <code>clang</code>
</li></ul>
</dd></dl>
<a name="Method-ast_002ddepth-_0028_0028clang-clang_0029-_0028ast-clang_002dast_0029_0029"></a><dl>
<dt><a name="index-ast_002ddepth-1"></a>Method: <strong>ast-depth</strong> <em>(clang clang) (ast clang-ast)</em></dt>
<dd><p>Depth of AST in <code>clang</code>. The root node has a depth of 0
</p><ul>
<li> <code>clang</code> software object
</li><li> AST ast pointing to the root of the AST tree in <code>clang</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-ast_002ddiff"></a><dl>
<dt><a name="index-ast_002ddiff"></a>Generic Function: <strong>ast-diff</strong> <em>ast-a ast-b</em></dt>
<dd><p>Return a least-cost edit script which transforms <code>ast-a</code> into <code>ast-b</code>.
Also return a second value indicating the cost of the edit.
</p>
<p>See &lsquo;ast-patch&rsquo; for more details on edit scripts.
</p>
<p>The following generic functions may be specialized to configure
differencing of specialized AST structures.; &lsquo;ast-equal-p&rsquo;,
&lsquo;ast-cost&rsquo;, &lsquo;ast-can-recurse&rsquo;, and &lsquo;ast-on-recurse&rsquo;.
</p></dd></dl>
<a name="Generic_002dFunction-ast_002dkeyword_002dtf_002dextractor"></a><dl>
<dt><a name="index-ast_002dkeyword_002dtf_002dextractor"></a>Generic Function: <strong>ast-keyword-tf-extractor</strong> <em>software</em></dt>
<dd><p>Return a vector containing term frequencies for all possible keywords in
<code>software</code> (see also &lsquo;all-keywords&rsquo;).
</p>
<p>The returned feature vector will have one entry for each keyword
listed in &lsquo;*clang-c-keywords*&rsquo;.
</p></dd></dl>
<a name="Generic_002dFunction-ast_002dtext"></a><dl>
<dt><a name="index-ast_002dtext"></a>Generic Function: <strong>ast-text</strong> <em>ast</em></dt>
<dd><p>Return textual representation of AST.
</p></dd></dl>
<a name="Generic_002dFunction-bad_002dmutation_002dtargets"></a><dl>
<dt><a name="index-bad_002dmutation_002dtargets"></a>Generic Function: <strong>bad-mutation-targets</strong> <em>software &amp;key filter</em></dt>
<dd><p>Return a list of all bad mutation targets in
<code>software</code> matching <code>filter</code>.
</p></dd></dl>
<a name="Method-bad_002dmutation_002dtargets-_0028_0028clang-clang_0029-_0026key-filter_0029"></a><dl>
<dt><a name="index-bad_002dmutation_002dtargets-1"></a>Method: <strong>bad-mutation-targets</strong> <em>(clang clang) &amp;key filter</em></dt>
<dd><p>Return a list of all bad statement ASTs in <code>clang</code> matching <code>filter</code>.
</p><ul>
<li> <code>clang</code> software object to query for bad statements
</li><li> <code>filter</code> predicate taking an AST parameter to allow for filtering
</li></ul>
</dd></dl>
<a name="Method-bad_002dmutation_002dtargets-_0028_0028obj-parseable_0029-_0026key-filter_0029"></a><dl>
<dt><a name="index-bad_002dmutation_002dtargets-2"></a>Method: <strong>bad-mutation-targets</strong> <em>(obj parseable) &amp;key filter</em></dt>
<dd><p>Return a list of all bad mutation targets in <code>obj</code> matching <code>filter</code>.
</p><ul>
<li> <code>obj</code> software object to query for bad mutation targets
</li><li> <code>filter</code> predicate taking an AST parameter to allow for filtering
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-bi_002dgrams"></a><dl>
<dt><a name="index-bi_002dgrams"></a>Generic Function: <strong>bi-grams</strong> <em>items &amp;key key bi-grams-ht</em></dt>
<dd><p>Update and return <code>bi-grams-ht</code> of counts of bi-gram occurrences in <code>items</code>.
Use <code>key</code> to specify a function applied to each item to get a value which will be
paired with another such value to create a key.
</p></dd></dl>
<a name="Method-bi_002dgrams-_0028_0028items-list_0029-_0026key-_0028key-_0023_0027identity_0029-_0028bi_002dgrams_002dht-_0028make_002dhash_002dtable-test-_0023_0027equal_0029_0029_0029"></a><dl>
<dt><a name="index-bi_002dgrams-1"></a>Method: <strong>bi-grams</strong> <em>(items list) &amp;key (key (function identity)) (bi-grams-ht (make-hash-table test (function equal)))</em></dt>
<dd><p>Update and return hash table <code>bi-grams-ht</code> with counts of bi-gram occurrences
in <code>items</code>. Use <code>key</code> to specify a function applied to each item to get a value
which will be paired with another such value to create a key.
</p><ul>
<li> <code>items</code> a list of elements
</li><li> <code>key</code> a function applied to items in <code>items</code> to generate values paired up and
</li></ul>
<p>used as keys in the hash-table
* <code>bi-grams-ht</code> a hash table mapping pairs of keys to numbers of occurrences
</p></dd></dl>
<a name="Generic_002dFunction-can_002dbe_002dmade_002dtraceable_002dp"></a><dl>
<dt><a name="index-can_002dbe_002dmade_002dtraceable_002dp"></a>Generic Function: <strong>can-be-made-traceable-p</strong> <em>software ast</em></dt>
<dd><p>Check if AST can be made a traceable statement in <code>software</code>.
</p></dd></dl>
<a name="Method-can_002dbe_002dmade_002dtraceable_002dp-_0028_0028obj-clang_0029-_0028ast-clang_002dast_0029_0029"></a><dl>
<dt><a name="index-can_002dbe_002dmade_002dtraceable_002dp-1"></a>Method: <strong>can-be-made-traceable-p</strong> <em>(obj clang) (ast clang-ast)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> AST <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Structure-clang_002dmacro"></a><dl>
<dt><a name="index-clang_002dmacro"></a>Structure: <strong>clang-macro</strong></dt>
<dd><p>Class precedence list: <code>clang-macro, structure-object, t</code>
</p>
<p>Immutable structure holding <code>clang-macro</code> slots.
</p></dd></dl>
<a name="Class-clang_002dinsert_002dfull_002dsame"></a><dl>
<dt><a name="index-clang_002dinsert_002dfull_002dsame"></a>Class: <strong>clang-insert-full-same</strong></dt>
<dd><p>Class precedence list: <code>clang-insert-full-same, clang-insert, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform an insertion operation on a clang software object,
only inserting full statements of the same AST class as the preceding
statement.
</p></dd></dl>
<a name="Class-clang_002dreplace_002dsame"></a><dl>
<dt><a name="index-clang_002dreplace_002dsame"></a>Class: <strong>clang-replace-same</strong></dt>
<dd><p>Class precedence list: <code>clang-replace-same, clang-replace, clang-mutation, parseable-replace, parseable-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform a replace operation on a clang software object,
only replacing statements of the same AST class.
</p></dd></dl>
<a name="Class-coalesce_002dwhile_002dloop"></a><dl>
<dt><a name="index-coalesce_002dwhile_002dloop"></a>Class: <strong>coalesce-while-loop</strong></dt>
<dd><p>Class precedence list: <code>coalesce-while-loop, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Select a &rsquo;while&rsquo; loop and coalesce it into a &rsquo;for&rsquo; loop.
This mutation will transform <code>'a</code>;while<code>(b)</code>;C&rsquo; into &rsquo;for(A;<code>b</code>;C)&rsquo;.
</p></dd></dl>
<a name="Generic_002dFunction-collect_002dtrace"></a><dl>
<dt><a name="index-collect_002dtrace"></a>Generic Function: <strong>collect-trace</strong> <em>software input &amp;key max bin</em></dt>
<dd><p>Execute instrumented <code>software</code> on <code>test-case</code> collecting a dynamic trace.
<code>max</code> specifies the maximum number of trace points to record.  <code>bin</code> specifies
the name of an already-compiled binary to use.
</p>
<p>Returns a list of traces, which may contains multiple elements if
executing a test script which runs the traceable program multiple
times.
</p></dd></dl>
<a name="Method-collect_002dtrace-_0028_0028obj-java_002dtraceable_002dproject_0029-_0028test_002dcase-test_002dcase_0029-_0026key-_0028max-infinity_0029-_0028bin-_0028temp_002dfile_002dname_0029_0029_0029"></a><dl>
<dt><a name="index-collect_002dtrace-1"></a>Method: <strong>collect-trace</strong> <em>(obj java-traceable-project) (test-case test-case) &amp;key (max infinity) (bin (temp-file-name))</em></dt>
<dd><p>Execute instrumented <code>obj</code> on <code>test-case</code> collecting dynamic traces.
</p><ul>
<li> <code>obj</code> Instrumented java project software object suitable for trace collection
</li><li> <code>test-case</code> test case to execute for trace collection
</li><li> <code>max</code> maximum number of trace points to record
</li><li> <code>bin</code> compiled binary with instrumentation to use for trace collection
</li></ul>
</dd></dl>
<a name="Method-collect_002dtrace-_0028_0028obj-java_002dtraceable_0029-_0028test_002dcase-test_002dcase_0029-_0026key-_0028max-infinity_0029-_0028bin-_0028temp_002dfile_002dname_0029_0029_0029"></a><dl>
<dt><a name="index-collect_002dtrace-2"></a>Method: <strong>collect-trace</strong> <em>(obj java-traceable) (test-case test-case) &amp;key (max infinity) (bin (temp-file-name))</em></dt>
<dd><p>Execute instrumented <code>obj</code> on <code>test-case</code> collecting dynamic traces.
</p><ul>
<li> <code>obj</code> Instrumented java software object suitable for trace collection
</li><li> <code>test-case</code> test case to execute for trace collection
</li><li> <code>max</code> maximum number of trace points to record
</li><li> <code>bin</code> compiled binary with instrumentation to use for trace collection
</li></ul>
</dd></dl>
<a name="Method-collect_002dtrace-_0028_0028obj-software_0029-_0028test_002dcase-test_002dcase_0029-_0026key-max-_0028bin-_0028temp_002dfile_002dname_0029_0029-_0026aux-_0028delete_002dbin_002dp-t_0029_0029"></a><dl>
<dt><a name="index-collect_002dtrace-3"></a>Method: <strong>collect-trace</strong> <em>(obj software) (test-case test-case) &amp;key max (bin (temp-file-name)) &amp;aux (delete-bin-p t)</em></dt>
<dd><p>Execute instrumented <code>obj</code> on <code>test-case</code> collecting dynamic traces.
</p><ul>
<li> <code>obj</code> Instrumented software object suitable for trace collection
</li><li> <code>test-case</code> test case to execute for trace collection
</li><li> <code>max</code> maximum number of trace points to record
</li><li> <code>bin</code> compiled binary with instrumentation to use for trace collection
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-collect_002dtraces"></a><dl>
<dt><a name="index-collect_002dtraces"></a>Generic Function: <strong>collect-traces</strong> <em>software test-suite &amp;key max bin</em></dt>
<dd><p>Execute instrumented <code>software</code> on <code>test-suite</code> collecting dynamic traces.
See the documentation of &lsquo;collect-trace&rsquo; for information on the
<code>max</code> and <code>bin</code> keyword arguments.
</p></dd></dl>
<a name="Method-collect_002dtraces-_0028_0028obj-java_002dtraceable_002dproject_0029-_0028test_002dsuite-test_002dsuite_0029-_0026key-max-_0028bin-_0028temp_002dfile_002dname_0029_0029_0029"></a><dl>
<dt><a name="index-collect_002dtraces-1"></a>Method: <strong>collect-traces</strong> <em>(obj java-traceable-project) (test-suite test-suite) &amp;key max (bin (temp-file-name))</em></dt>
<dd><p>Executed instrumented <code>obj</code> on <code>test-suite</code> collecting dynamic traces.
</p><ul>
<li> <code>obj</code> Instrumented software object suitable for trace collection
</li><li> <code>test-suite</code> suite of test case to execute for trace collection
</li><li> <code>max</code> maximum number of trace points to record
</li><li> <code>bin</code> compiled binary with instrumentation to use for trace collection
</li></ul>
</dd></dl>
<a name="Method-collect_002dtraces-_0028_0028obj-java_002dtraceable_0029-_0028test_002dsuite-test_002dsuite_0029-_0026key-max-_0028bin-_0028temp_002dfile_002dname_0029_0029_0029"></a><dl>
<dt><a name="index-collect_002dtraces-2"></a>Method: <strong>collect-traces</strong> <em>(obj java-traceable) (test-suite test-suite) &amp;key max (bin (temp-file-name))</em></dt>
<dd><p>Executed instrumented <code>obj</code> on <code>test-suite</code> collecting dynamic traces.
</p><ul>
<li> <code>obj</code> Instrumented software object suitable for trace collection
</li><li> <code>test-suite</code> suite of test case to execute for trace collection
</li><li> <code>max</code> maximum number of trace points to record
</li><li> <code>bin</code> compiled binary with instrumentation to use for trace collection
</li></ul>
</dd></dl>
<a name="Method-collect_002dtraces-_0028_0028obj-software_0029-_0028test_002dsuite-test_002dsuite_0029-_0026key-max-_0028bin-_0028temp_002dfile_002dname_0029_0029-_0026aux-_0028args-_0028list-bin-bin_0029_0029-_0028delete_002dbin_002dp-t_0029_0029"></a><dl>
<dt><a name="index-collect_002dtraces-3"></a>Method: <strong>collect-traces</strong> <em>(obj software) (test-suite test-suite) &amp;key max (bin (temp-file-name)) &amp;aux (args (list bin bin)) (delete-bin-p t)</em></dt>
<dd><p>Executed instrumented <code>obj</code> on <code>test-suite</code> collecting dynamic traces.
</p><ul>
<li> <code>obj</code> Instrumented software object suitable for trace collection
</li><li> <code>test-suite</code> suite of test case to execute for trace collection
</li><li> <code>max</code> maximum number of trace points to record
</li><li> <code>bin</code> compiled binary with instrumentation to use for trace collection
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-crossover"></a><dl>
<dt><a name="index-crossover"></a>Generic Function: <strong>crossover</strong> <em>software-a software-b</em></dt>
<dd><p>Crossover two software objects.
Define an :around method on this function to record crossovers.
</p></dd></dl>
<a name="Method-crossover-around-_0028_0028a-ancestral_0029-_0028b-ancestral_0029_0029"></a><dl>
<dt><a name="index-around-crossover"></a>Method: <strong>around crossover</strong> <em>(a ancestral) (b ancestral)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> A <code>docfixme</code>
</li><li> <code>b</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-crossover-_0028_0028a-project_0029-_0028b-project_0029_0029"></a><dl>
<dt><a name="index-crossover-1"></a>Method: <strong>crossover</strong> <em>(a project) (b project)</em></dt>
<dd><p>Randomly pick one file in a and perform crossover with the corresponding file in b.
</p></dd></dl>
<a name="Method-crossover-_0028_0028a-clang_0029-_0028b-clang_0029_0029"></a><dl>
<dt><a name="index-crossover-2"></a>Method: <strong>crossover</strong> <em>(a clang) (b clang)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> A <code>docfixme</code>
</li><li> <code>b</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-crossover-_0028_0028a-source_0029-_0028b-source_0029_0029"></a><dl>
<dt><a name="index-crossover-3"></a>Method: <strong>crossover</strong> <em>(a source) (b source)</em></dt>
<dd><p>Crossover two software objects, A and <code>b</code>.
</p></dd></dl>
<a name="Method-crossover-_0028_0028a-elf_002drisc_0029-_0028b-elf_002drisc_0029_0029"></a><dl>
<dt><a name="index-crossover-4"></a>Method: <strong>crossover</strong> <em>(a elf-risc) (b elf-risc)</em></dt>
<dd><p>One point crossover.
</p></dd></dl>
<a name="Method-crossover-_0028_0028a-elf_002dcisc_0029-_0028b-elf_002dcisc_0029_0029"></a><dl>
<dt><a name="index-crossover-5"></a>Method: <strong>crossover</strong> <em>(a elf-cisc) (b elf-cisc)</em></dt>
<dd><p>One point crossover.
</p></dd></dl>
<a name="Method-crossover-_0028_0028a-asm_0029-_0028b-asm_0029_0029"></a><dl>
<dt><a name="index-crossover-6"></a>Method: <strong>crossover</strong> <em>(a asm) (b asm)</em></dt>
<dd><p>By default, crossover for ASM objects uses &lsquo;homologous-crossover&rsquo;.
</p></dd></dl>
<a name="Method-crossover-_0028_0028a-lisp_0029-_0028b-lisp_0029_0029"></a><dl>
<dt><a name="index-crossover-7"></a>Method: <strong>crossover</strong> <em>(a lisp) (b lisp)</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> A <code>docfixme</code>
</li><li> <code>b</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-crossover-_0028_0028a-simple_0029-_0028b-simple_0029_0029"></a><dl>
<dt><a name="index-crossover-8"></a>Method: <strong>crossover</strong> <em>(a simple) (b simple)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Generic_002dFunction-database_002demptyp"></a><dl>
<dt><a name="index-database_002demptyp"></a>Generic Function: <strong>database-emptyp</strong> <em>database</em></dt>
<dd><p>Return t if the database is empty, nil otherwise
</p></dd></dl>
<a name="Method-database_002demptyp-_0028_0028obj-pliny_002ddatabase_0029_0029"></a><dl>
<dt><a name="index-database_002demptyp-1"></a>Method: <strong>database-emptyp</strong> <em>(obj pliny-database)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-database_002demptyp-_0028_0028db-in_002dmemory_002ddatabase_0029_0029"></a><dl>
<dt><a name="index-database_002demptyp-2"></a>Method: <strong>database-emptyp</strong> <em>(db in-memory-database)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Class-demote_002dbinop_002dleft"></a><dl>
<dt><a name="index-demote_002dbinop_002dleft"></a>Class: <strong>demote-binop-left</strong></dt>
<dd><p>Class precedence list: <code>demote-binop-left, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-elf_002dcisc"></a><dl>
<dt><a name="index-elf_002dcisc"></a>Class: <strong>elf-cisc</strong></dt>
<dd><p>Class precedence list: <code>elf-cisc, elf, simple, software, standard-object, t</code>
</p>
<p>Executable Linkable Format <code>(elf) </code>binaries in complex instruction set architectures.
</p></dd></dl>
<a name="Class-elf_002dcsurf"></a><dl>
<dt><a name="index-elf_002dcsurf"></a>Class: <strong>elf-csurf</strong></dt>
<dd><p>Class precedence list: <code>elf-csurf, elf-cisc, elf, simple, software, standard-object, t</code>
</p>
<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-elf_002dmips"></a><dl>
<dt><a name="index-elf_002dmips"></a>Class: <strong>elf-mips</strong></dt>
<dd><p>Class precedence list: <code>elf-mips, elf-risc, elf, simple, software, standard-object, t</code>
</p>
<p>Executable Linkable Format <code>(elf) </code>binaries in <code>mips</code> architectures.
</p></dd></dl>
<a name="Class-expand_002darithmatic_002dop"></a><dl>
<dt><a name="index-expand_002darithmatic_002dop"></a>Class: <strong>expand-arithmatic-op</strong></dt>
<dd><p>Class precedence list: <code>expand-arithmatic-op, clang-replace, clang-mutation, parseable-replace, parseable-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Expand a compound assignment or increment/decrement operation
in a clang software object.
</p></dd></dl>
<a name="Class-explode_002dfor_002dloop"></a><dl>
<dt><a name="index-explode_002dfor_002dloop"></a>Class: <strong>explode-for-loop</strong></dt>
<dd><p>Class precedence list: <code>explode-for-loop, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Select a &rsquo;for&rsquo; loop and explode it into it&rsquo;s component parts.
This mutation will transform &rsquo;for(A;<code>b</code>;C)&rsquo; into <code>'a</code>;while<code>(b)</code>;C&rsquo;.
</p></dd></dl>
<a name="Variable-_002asame_002dbias_002a"></a><dl>
<dt><a name="index-_002asame_002dbias_002a"></a>Variable: <strong>*same-bias*</strong></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Function-analyze_002dmutation"></a><dl>
<dt><a name="index-analyze_002dmutation"></a>Function: <strong>analyze-mutation</strong> <em>obj mutation-info test</em></dt>
<dd><p>Default function to collect statistics from an applied mutation.
</p>
<p>This function will calculate the improvements to the fitness of <code>software</code>
as the result of crossover and mutation using &lsquo;evaluate&rsquo; and <code>test</code>.
Each crossover and mutation will be paired with one of the following tags;
:dead, :same, :worse, or :better.  Calculated stats will be added to the
*crossover-stats* and *mutation-stats* variables for analysis.
</p></dd></dl>
<a name="Generic_002dFunction-expression"></a><dl>
<dt><a name="index-expression"></a>Generic Function: <strong>expression</strong> <em>software what</em></dt>
<dd><p>Return <code>what</code> in <code>software</code> as a lisp expression.
</p></dd></dl>
<a name="Method-expression-_0028_0028obj-clang_0029-_0028ast-clang_002dast_0029_0029"></a><dl>
<dt><a name="index-expression-1"></a>Method: <strong>expression</strong> <em>(obj clang) (ast clang-ast)</em></dt>
<dd><p>Convert AST to an expression tree.
</p><ul>
<li> <code>obj</code> clang software object containing AST
</li><li> AST the AST to convert
</li></ul>
</dd></dl>
<a name="Class-expression"></a><dl>
<dt><a name="index-expression-2"></a>Class: <strong>expression</strong></dt>
<dd><p>Class precedence list: <code>expression, lisp, simple, software, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>scope</code> &mdash; initarg: <code>:scope<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:scope</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:scope)</span><!-- /@w --></code>

<p>List of in-scope variable names.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Generic_002dFunction-extract_002dfeatures"></a><dl>
<dt><a name="index-extract_002dfeatures"></a>Generic Function: <strong>extract-features</strong> <em>software &amp;key features files &amp;allow-other-keys</em></dt>
<dd><p>For a <code>software</code> object, extract a set of <code>features</code>.
Returns two values: a vector of feature vectors and a vector of metadata (used
by feature merge functions).
</p></dd></dl>
<a name="Method-extract_002dfeatures-_0028_0028project-style_002dproject_0029-_0026key-_0028features-_002afeature_002dextractors_002a_0029-_0028files-nil_0029_0029"></a><dl>
<dt><a name="index-extract_002dfeatures-1"></a>Method: <strong>extract-features</strong> <em>(project style-project) &amp;key (features *feature-extractors*) (files nil)</em></dt>
<dd><p>For a <code>project</code> object, extract a set of <code>features</code> for each software object in
the project and merge the results. Return two values: a vector of feature vectors
and a vector of metadata (used by feature merge functions).
</p><ul>
<li> <code>project</code> a project software object
</li><li> <code>features</code> a list of features to be extracted (default: &lsquo;*feature-extractors*&rsquo;)
</li><li> <code>files</code> a list of files on which to extract features (default: &lsquo;all-files&rsquo;)
</li></ul>
</dd></dl>
<a name="Method-extract_002dfeatures-_0028_0028style-styleable_0029-_0026key-_0028features-nil_0029_0029"></a><dl>
<dt><a name="index-extract_002dfeatures-2"></a>Method: <strong>extract-features</strong> <em>(style styleable) &amp;key (features nil)</em></dt>
<dd><p>For a styleable <code>style</code>, extract a list of style-features <code>features</code>.
Returns two values: a vector of feature vectors and a vector of metadata (used
by feature merge functions).
</p><ul>
<li> <code>style</code> a styleable software object
</li><li> <code>features</code> a list of style-features
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-find_002dmacro"></a><dl>
<dt><a name="index-find_002dmacro"></a>Generic Function: <strong>find-macro</strong> <em>database hash</em></dt>
<dd><p>Find the macro in the database
matching the parameter <code>hash</code>
</p></dd></dl>
<a name="Method-find_002dmacro-_0028_0028obj-pliny_002ddatabase_0029-hash_0029"></a><dl>
<dt><a name="index-find_002dmacro-1"></a>Method: <strong>find-macro</strong> <em>(obj pliny-database) hash</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>hash</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-find_002dmacro-_0028_0028db-in_002dmemory_002ddatabase_0029-hash_0029"></a><dl>
<dt><a name="index-find_002dmacro-2"></a>Method: <strong>find-macro</strong> <em>(db in-memory-database) hash</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>db</code> <code>docfixme</code>
</li><li> <code>hash</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-find_002dmacro-_0028_0028obj-clang_0029-hash_0029"></a><dl>
<dt><a name="index-find_002dmacro-3"></a>Method: <strong>find-macro</strong> <em>(obj clang) hash</em></dt>
<dd><p>Return the macro in <code>obj</code> with the given <code>hash</code>.
</p><ul>
<li> <code>obj</code> object to search for <code>hash</code>
</li><li> <code>hash</code> macro hash to find
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-find_002dvar_002dtype"></a><dl>
<dt><a name="index-find_002dvar_002dtype"></a>Generic Function: <strong>find-var-type</strong> <em>software variable</em></dt>
<dd><p>Return the type of <code>variable</code> in <code>software</code>.
</p></dd></dl>
<a name="Method-find_002dvar_002dtype-_0028_0028obj-clang_0029-_0028variable-list_0029_0029"></a><dl>
<dt><a name="index-find_002dvar_002dtype-1"></a>Method: <strong>find-var-type</strong> <em>(obj clang) (variable list)</em></dt>
<dd><p>Return the type of <code>variable</code> in <code>software</code>
</p></dd></dl>
<a name="Generic_002dFunction-fitness_002dextra_002ddata"></a><dl>
<dt><a name="index-fitness_002dextra_002ddata"></a>Generic Function: <strong>fitness-extra-data</strong> <em>software</em></dt>
<dd><p>Hold extra data returned by the fitness function.
</p></dd></dl>
<a name="Generic_002dFunction-_0028setf-fitness_002dextra_002ddata_0029"></a><dl>
<dt><a name="index-_0028setf-fitness_002dextra_002ddata_0029"></a>Generic Function: <strong>(setf fitness-extra-data)</strong> <em>extra-data software</em></dt>
<dd><p>Pass extra data (optionally) returned by the fitness function
                   to the software object.
</p></dd></dl>
<a name="Method-_0028setf-fitness_002dextra_002ddata_0029-around-_0028extra_002ddata-_0028obj-ancestral_0029_0029"></a><dl>
<dt><a name="index-around-_0028setf-fitness_002dextra_002ddata_0029"></a>Method: <strong>around (setf fitness-extra-data)</strong> <em>extra-data (obj ancestral)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>extra-data</code> <code>docfixme</code>
</li><li> <code>obj</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Class-fodder_002ddatabase"></a><dl>
<dt><a name="index-fodder_002ddatabase"></a>Class: <strong>fodder-database</strong></dt>
<dd><p>Class precedence list: <code>fodder-database, searchable, standard-object, t</code>
</p>
<p><code>fixme</code>
</p></dd></dl>
<a name="Class-forth"></a><dl>
<dt><a name="index-forth"></a>Class: <strong>forth</strong></dt>
<dd><p>Class precedence list: <code>forth, simple, software, standard-object, t</code>
</p>
<p>Forth program represented as a list of commands.
</p></dd></dl>
<a name="Variable-_002across_002dchance_002a"></a><dl>
<dt><a name="index-_002across_002dchance_002a"></a>Variable: <strong>*cross-chance*</strong></dt>
<dd><p>Fraction of new individuals generated using crossover rather than mutation.
</p></dd></dl>
<a name="Variable-_002acrossover_002dstats_002a"></a><dl>
<dt><a name="index-_002acrossover_002dstats_002a"></a>Variable: <strong>*crossover-stats*</strong></dt>
<dd><p>Variable to hold crossover statistics.
</p></dd></dl>
<a name="Variable-_002afeature_002dextractors_002a"></a><dl>
<dt><a name="index-_002afeature_002dextractors_002a"></a>Variable: <strong>*feature-extractors*</strong></dt>
<dd><p>List of feature-extractors to use as the default set during feature
extraction.
</p></dd></dl>
<a name="Variable-_002aprocess_002dsleep_002dinterval_002a"></a><dl>
<dt><a name="index-_002aprocess_002dsleep_002dinterval_002a"></a>Variable: <strong>*process-sleep-interval*</strong></dt>
<dd><p>Frequency (in seconds) at which to check if a process has completed.
</p></dd></dl>
<a name="Variable-_002aworst_002dfitness_002dp_002a"></a><dl>
<dt><a name="index-_002aworst_002dfitness_002dp_002a"></a>Variable: <strong>*worst-fitness-p*</strong></dt>
<dd><p>Predicate indicating whether an individual has the worst possible fitness.
</p></dd></dl>
<a name="Function-adaptive_002danalyze_002dmutation"></a><dl>
<dt><a name="index-adaptive_002danalyze_002dmutation"></a>Function: <strong>adaptive-analyze-mutation</strong> <em>obj mutation-info test</em></dt>
<dd><p>Adaptively update mutation probabilities based on the result of the mutation
</p></dd></dl>
<a name="Function-ast_002dlater_002dp"></a><dl>
<dt><a name="index-ast_002dlater_002dp"></a>Function: <strong>ast-later-p</strong> <em>ast-a ast-b</em></dt>
<dd><p>Is <code>ast-a</code> later in the genome than <code>ast-b</code>?
</p>
<p>Use this to sort AST asts for mutations that perform multiple
operations.
</p></dd></dl>
<a name="Generic_002dFunction-from_002dalist"></a><dl>
<dt><a name="index-from_002dalist"></a>Generic Function: <strong>from-alist</strong> <em>symbol alist</em></dt>
<dd><p>Convert alist to struct representation.
</p></dd></dl>
<a name="Generic_002dFunction-function_002dbody"></a><dl>
<dt><a name="index-function_002dbody"></a>Generic Function: <strong>function-body</strong> <em>software ast</em></dt>
<dd><p>If AST is a function, return the AST representing its body.
</p></dd></dl>
<a name="Method-function_002dbody-_0028_0028software-clang_0029-_0028ast-clang_002dast_0029_0029"></a><dl>
<dt><a name="index-function_002dbody-1"></a>Method: <strong>function-body</strong> <em>(software clang) (ast clang-ast)</em></dt>
<dd><p>If AST is a function, return the AST representing its body.
</p><ul>
<li> <code>software</code> software object containing AST and its children
</li><li> AST potential function AST to query for its body
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-genome_002dstring"></a><dl>
<dt><a name="index-genome_002dstring"></a>Generic Function: <strong>genome-string</strong> <em>software &amp;optional stream</em></dt>
<dd><p>Return a string of the &lsquo;genome&rsquo; of <code>software</code>.
</p></dd></dl>
<a name="Method-genome_002dstring-_0028_0028forth-forth_0029-_0026optional-stream_0029"></a><dl>
<dt><a name="index-genome_002dstring-1"></a>Method: <strong>genome-string</strong> <em>(forth forth) &amp;optional stream</em></dt>
<dd><p>Return genome of <code>forth</code> as a string.
Like &lsquo;(genome-string simple)&rsquo; but lines are delimited by spaces
instead of Newlines.
</p></dd></dl>
<a name="Method-genome_002dstring-_0028_0028obj-source_0029-_0026optional-stream_0029"></a><dl>
<dt><a name="index-genome_002dstring-2"></a>Method: <strong>genome-string</strong> <em>(obj source) &amp;optional stream</em></dt>
<dd><p>Return the source code of <code>obj</code>, optionally writing to <code>stream</code>
</p></dd></dl>
<a name="Method-genome_002dstring-_0028_0028elf-elf_0029-_0026optional-stream_0029"></a><dl>
<dt><a name="index-genome_002dstring-3"></a>Method: <strong>genome-string</strong> <em>(elf elf) &amp;optional stream</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-genome_002dstring-_0028_0028lisp-lisp_0029-_0026optional-stream_0029"></a><dl>
<dt><a name="index-genome_002dstring-4"></a>Method: <strong>genome-string</strong> <em>(lisp lisp) &amp;optional stream</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>lisp</code> <code>docfixme</code>
</li><li> <code>stream</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-genome_002dstring-_0028_0028simple-simple_0029-_0026optional-stream_0029"></a><dl>
<dt><a name="index-genome_002dstring-5"></a>Method: <strong>genome-string</strong> <em>(simple simple) &amp;optional stream</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Generic_002dFunction-_0028setf-genome_002dstring_0029"></a><dl>
<dt><a name="index-_0028setf-genome_002dstring_0029"></a>Generic Function: <strong>(setf genome-string)</strong> <em>text software</em></dt>
<dd><p>Set the &lsquo;genome&rsquo; of <code>software</code> to the string representation
</p></dd></dl>
<a name="Method-_0028setf-genome_002dstring_0029-_0028text-_0028obj-source_0029_0029"></a><dl>
<dt><a name="index-_0028setf-genome_002dstring_0029-1"></a>Method: <strong>(setf genome-string)</strong> <em>text (obj source)</em></dt>
<dd><p>Update the source code of <code>obj</code> to <code>text</code>.
</p></dd></dl>
<a name="Generic_002dFunction-get_002dast"></a><dl>
<dt><a name="index-get_002dast"></a>Generic Function: <strong>get-ast</strong> <em>obj path</em></dt>
<dd><p>Return the AST in <code>obj</code> at <code>path</code>.
</p></dd></dl>
<a name="Method-get_002dast-_0028_0028obj-parseable_0029-_0028path-list_0029_0029"></a><dl>
<dt><a name="index-get_002dast-1"></a>Method: <strong>get-ast</strong> <em>(obj parseable) (path list)</em></dt>
<dd><p>Return the AST in <code>obj</code> at the given <code>path</code>.
</p><ul>
<li> <code>obj</code> software object with ASTs
</li><li> <code>path</code> path to the AST to return
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-get_002dast_002dtypes"></a><dl>
<dt><a name="index-get_002dast_002dtypes"></a>Generic Function: <strong>get-ast-types</strong> <em>software ast</em></dt>
<dd><p>Types directly referenced within AST.
</p></dd></dl>
<a name="Method-get_002dast_002dtypes-_0028_0028software-clang_0029-_0028ast-clang_002dast_0029_0029"></a><dl>
<dt><a name="index-get_002dast_002dtypes-1"></a>Method: <strong>get-ast-types</strong> <em>(software clang) (ast clang-ast)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>software</code> <code>docfixme</code>
</li><li> AST <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-get_002dentry"></a><dl>
<dt><a name="index-get_002dentry"></a>Generic Function: <strong>get-entry</strong> <em>software</em></dt>
<dd><p>Return the AST of the entry point (main function) in <code>software</code>.
</p></dd></dl>
<a name="Method-get_002dentry-_0028_0028obj-clang_0029_0029"></a><dl>
<dt><a name="index-get_002dentry-1"></a>Method: <strong>get-entry</strong> <em>(obj clang)</em></dt>
<dd><p>Return the AST of the entry point (main function) in <code>software</code>.
</p>
<p><code>obj</code> a clang software object
</p></dd></dl>
<a name="Generic_002dFunction-get_002dparent_002dfull_002dstmt"></a><dl>
<dt><a name="index-get_002dparent_002dfull_002dstmt"></a>Generic Function: <strong>get-parent-full-stmt</strong> <em>software ast</em></dt>
<dd><p>Return the first ancestor of AST in <code>software</code> which is a full stmt.
Returns nil if no full-stmt parent is found.
</p></dd></dl>
<a name="Method-get_002dparent_002dfull_002dstmt-_0028_0028clang-clang_0029-_0028ast-clang_002dast_0029_0029"></a><dl>
<dt><a name="index-get_002dparent_002dfull_002dstmt-1"></a>Method: <strong>get-parent-full-stmt</strong> <em>(clang clang) (ast clang-ast)</em></dt>
<dd><p>Return the first ancestor of AST in <code>software</code> which is a full stmt.
Returns nil if no full-stmt is found.
</p><ul>
<li> <code>clang</code> software object containing AST and its parents
</li><li> AST to find the parent full statement of if not already a full statement
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-get_002dunbound_002dvals"></a><dl>
<dt><a name="index-get_002dunbound_002dvals"></a>Generic Function: <strong>get-unbound-vals</strong> <em>software ast</em></dt>
<dd><p>Variables used (but not defined) within the AST.
</p></dd></dl>
<a name="Method-get_002dunbound_002dvals-_0028_0028software-clang_0029-_0028ast-clang_002dast_002dnode_0029_0029"></a><dl>
<dt><a name="index-get_002dunbound_002dvals-1"></a>Method: <strong>get-unbound-vals</strong> <em>(software clang) (ast clang-ast-node)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>software</code> <code>docfixme</code>
</li><li> AST <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-get_002dunbound_002dvals-_0028_0028software-clang_0029-_0028ast-clang_002dast_0029_0029"></a><dl>
<dt><a name="index-get_002dunbound_002dvals-2"></a>Method: <strong>get-unbound-vals</strong> <em>(software clang) (ast clang-ast)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>software</code> <code>docfixme</code>
</li><li> AST <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-homologous_002dcrossover"></a><dl>
<dt><a name="index-homologous_002dcrossover"></a>Generic Function: <strong>homologous-crossover</strong> <em>software-a software-b</em></dt>
<dd><p>Crossover at a similar point in both software objects.
After picking a crossover point in <code>software-a</code>, try to find the same point in
<code>software-b</code>. Ideally, if A and <code>b</code> are identical, &lsquo;homologous-crossover&rsquo; always
results in a genome that matches those of A and <code>b</code>.
</p></dd></dl>
<a name="Method-homologous_002dcrossover-_0028_0028a-asm_0029-_0028b-asm_0029_0029"></a><dl>
<dt><a name="index-homologous_002dcrossover-1"></a>Method: <strong>homologous-crossover</strong> <em>(a asm) (b asm)</em></dt>
<dd><p>Crossover at a similar point in asm objects, A and <code>b</code>.
After picking a crossover point in A, try to find the same point in <code>b</code>. If A and
<code>b</code> are identical, this implementation always results in a genome that matches
those of A and <code>b</code>.
</p></dd></dl>
<a name="Class-if_002dto_002dwhile"></a><dl>
<dt><a name="index-if_002dto_002dwhile"></a>Class: <strong>if-to-while</strong></dt>
<dd><p>Class precedence list: <code>if-to-while, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Replace an if statement with a while on the same condition.
<code>e</code>.g., if(foo) becomes while(foo).
</p></dd></dl>
<a name="Class-if_002dto_002dwhile_002dtighten_002dcondition"></a><dl>
<dt><a name="index-if_002dto_002dwhile_002dtighten_002dcondition"></a>Class: <strong>if-to-while-tighten-condition</strong></dt>
<dd><p>Class precedence list: <code>if-to-while-tighten-condition, if-to-while, tighten-condition, refine-condition, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Combine if-to-while replacement with a tighter condition.
<code>e</code>.g., if(foo) becomes while(foo <code>&amp;&amp;</code> !abst_cond()).
</p></dd></dl>
<a name="Class-in_002dmemory_002ddatabase"></a><dl>
<dt><a name="index-in_002dmemory_002ddatabase"></a>Class: <strong>in-memory-database</strong></dt>
<dd><p>Class precedence list: <code>in-memory-database, fodder-database, searchable, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>ast-database-ht</code> &mdash; initarg: <code><span class="nolinebreak">:ast-database-ht</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library::ast-database-ht</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::ast-database-ht)</span><!-- /@w --></code>

<p>The database of source code snippets, grouped by AST class name.
</p></li><li> <code>ast-database-list</code> &mdash; initarg: <code><span class="nolinebreak">:ast-database-list</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library::ast-database-list</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::ast-database-list)</span><!-- /@w --></code>

<p>The database of source code snippets as a raw list.
</p></li><li> <code>ast-database-full-stmt-list</code> &mdash; initarg: <code><span class="nolinebreak">:ast-database-full-stmt-list</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library::ast-database-full-stmt-list</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::ast-database-full-stmt-list)</span><!-- /@w --></code>

<p>The database of source code snippets which are full statements.
</p></li><li> <code>type-database-ht</code> &mdash; initarg: <code><span class="nolinebreak">:type-database-ht</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library::type-database-ht</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::type-database-ht)</span><!-- /@w --></code>

<p>An auxillary database of type snippets, grouped by hash-code
</p></li><li> <code>macro-database-ht</code> &mdash; initarg: <code><span class="nolinebreak">:macro-database-ht</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library::macro-database-ht</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::macro-database-ht)</span><!-- /@w --></code>

<p>An auxillary database of macro snippets, grouped by hash-code
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-insert_002dfodder"></a><dl>
<dt><a name="index-insert_002dfodder"></a>Class: <strong>insert-fodder</strong></dt>
<dd><p>Class precedence list: <code>insert-fodder, clang-insert, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Insert a fodder AST into a clang software object.
</p></dd></dl>
<a name="Class-insert_002dfodder_002ddecl"></a><dl>
<dt><a name="index-insert_002dfodder_002ddecl"></a>Class: <strong>insert-fodder-decl</strong></dt>
<dd><p>Class precedence list: <code>insert-fodder-decl, clang-insert, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Insert a Decl fodder AST into a clang software object.
</p></dd></dl>
<a name="Class-insert_002dfodder_002ddecl_002drep"></a><dl>
<dt><a name="index-insert_002dfodder_002ddecl_002drep"></a>Class: <strong>insert-fodder-decl-rep</strong></dt>
<dd><p>Class precedence list: <code>insert-fodder-decl-rep, clang-insert, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>First apply &lsquo;insert-fodder-decl&rsquo; then &lsquo;rename-variable&rsquo; mutations.
Ensure that the name of the inserted decl is used by
&lsquo;rename-variable&rsquo;.
</p></dd></dl>
<a name="Class-insert_002dfodder_002dfull"></a><dl>
<dt><a name="index-insert_002dfodder_002dfull"></a>Class: <strong>insert-fodder-full</strong></dt>
<dd><p>Class precedence list: <code>insert-fodder-full, clang-insert, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Insert a full statement fodder AST into a clang software
object
</p></dd></dl>
<a name="Class-instrumenter"></a><dl>
<dt><a name="index-instrumenter"></a>Class: <strong>instrumenter</strong></dt>
<dd><p>Class precedence list: <code>instrumenter, standard-object, t</code>
</p>
<p>Base class for objects which handle instrumentation.
Stores instrumentation state and provides methods for instrumentation
operations.
</p></dd></dl>
<a name="Class-java_002dmutation"></a><dl>
<dt><a name="index-java_002dmutation"></a>Class: <strong>java-mutation</strong></dt>
<dd><p>Class precedence list: <code>java-mutation, mutation, standard-object, t</code>
</p>
<p>Base class for all Java mutations.
</p></dd></dl>
<a name="Class-java_002dtraceable"></a><dl>
<dt><a name="index-java_002dtraceable"></a>Class: <strong>java-traceable</strong></dt>
<dd><p>Class precedence list: <code>java-traceable, java, source, traceable, software, standard-object, t</code>
</p>
<p>Specialization of the traceable interface for java software objects.
</p></dd></dl>
<a name="Class-lisp"></a><dl>
<dt><a name="index-lisp"></a>Class: <strong>lisp</strong></dt>
<dd><p>Class precedence list: <code>lisp, simple, software, standard-object, t</code>
</p>
<p>Common Lisp source represented naturally as lists of code.
</p></dd></dl>
<a name="Class-lisp_002dcut"></a><dl>
<dt><a name="index-lisp_002dcut"></a>Class: <strong>lisp-cut</strong></dt>
<dd><p>Class precedence list: <code>lisp-cut, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-lisp_002dswap"></a><dl>
<dt><a name="index-lisp_002dswap"></a>Class: <strong>lisp-swap</strong></dt>
<dd><p>Class precedence list: <code>lisp-swap, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-mult_002ddivide"></a><dl>
<dt><a name="index-mult_002ddivide"></a>Class: <strong>mult-divide</strong></dt>
<dd><p>Class precedence list: <code>mult-divide, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-mutation"></a><dl>
<dt><a name="index-mutation"></a>Class: <strong>mutation</strong></dt>
<dd><p>Class precedence list: <code>mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>object</code> &mdash; initarg: <code>:object<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:object</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:object)</span><!-- /@w --></code>

<p>The software object to be mutated.
</p></li><li> <code>targets</code> &mdash; initarg: <code>:targets<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:get-targets</span><!-- /@w --></code>

<p>A calculated target set.
</p></li></ul>

<p>The base class of all software mutations.
</p></dd></dl>
<a name="Generic_002dFunction-one_002dpoint_002dcrossover"></a><dl>
<dt><a name="index-one_002dpoint_002dcrossover"></a>Generic Function: <strong>one-point-crossover</strong> <em>software-a software-b</em></dt>
<dd><p>Crossover at a single point.
</p></dd></dl>
<a name="Method-one_002dpoint_002dcrossover-_0028_0028a-sw_002drange_0029-_0028b-sw_002drange_0029_0029"></a><dl>
<dt><a name="index-one_002dpoint_002dcrossover-1"></a>Method: <strong>one-point-crossover</strong> <em>(a sw-range) (b sw-range)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-one_002dpoint_002dcrossover-_0028_0028a-simple_0029-_0028b-simple_0029_0029"></a><dl>
<dt><a name="index-one_002dpoint_002dcrossover-2"></a>Method: <strong>one-point-crossover</strong> <em>(a simple) (b simple)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Generic_002dFunction-pick_002dgood"></a><dl>
<dt><a name="index-pick_002dgood"></a>Generic Function: <strong>pick-good</strong> <em>software</em></dt>
<dd><p>Pick a &rsquo;good&rsquo; index into a software object.
Used to target mutation.
</p></dd></dl>
<a name="Method-pick_002dgood-_0028_0028obj-coq_0029_0029"></a><dl>
<dt><a name="index-pick_002dgood-1"></a>Method: <strong>pick-good</strong> <em>(obj coq)</em></dt>
<dd><p>Return a randomly selected index of a good statement in <code>obj</code>.
Remove statements containing Coq location info from consideration.
If none exist, raise a &lsquo;no-mutation-targets&rsquo; error.
</p></dd></dl>
<a name="Method-pick_002dgood-_0028_0028clang-clang_0029_0029"></a><dl>
<dt><a name="index-pick_002dgood-2"></a>Method: <strong>pick-good</strong> <em>(clang clang)</em></dt>
<dd><p>Pick a random AST in <code>clang</code> from the &lsquo;good-stmt&rsquo; pool.
</p></dd></dl>
<a name="Method-pick_002dgood-_0028_0028obj-parseable_0029_0029"></a><dl>
<dt><a name="index-pick_002dgood-3"></a>Method: <strong>pick-good</strong> <em>(obj parseable)</em></dt>
<dd><p>Pick a &rsquo;good&rsquo; index into a software object.
Used to target mutation.
</p></dd></dl>
<a name="Method-pick_002dgood-_0028_0028elf-elf_0029_0029"></a><dl>
<dt><a name="index-pick_002dgood-4"></a>Method: <strong>pick-good</strong> <em>(elf elf)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Class-pliny_002ddatabase"></a><dl>
<dt><a name="index-pliny_002ddatabase"></a>Class: <strong>pliny-database</strong></dt>
<dd><p>Class precedence list: <code>pliny-database, fodder-database, searchable, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>host</code> &mdash; initarg: <code>:host<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:host</span><!-- /@w --></code>

<p>Pliny database host
</p></li><li> <code>port</code> &mdash; initarg: <code>:port<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:port</span><!-- /@w --></code>

<p>Pliny database port
</p></li><li> <code>storage</code> &mdash; reader: <code><span class="nolinebreak">software-evolution-library::storage</span><!-- /@w --></code>

<p>Database storage file
</p></li><li> <code>catalog</code> &mdash; reader: <code><span class="nolinebreak">software-evolution-library::catalog</span><!-- /@w --></code>

<p>File with database storage locations
</p></li><li> <code>num-threads</code> &mdash; reader: <code><span class="nolinebreak">software-evolution-library::num-threads</span><!-- /@w --></code>

<p>Number of database front-end threads
</p></li><li> <code>memory-per-thread</code> &mdash; reader: <code><span class="nolinebreak">software-evolution-library::memory-per-thread</span><!-- /@w --></code>

<p>Memory per database thread
</p></li><li> <code>server-log</code> &mdash; reader: <code><span class="nolinebreak">software-evolution-library::server-log</span><!-- /@w --></code>

<p>Database server log
</p></li><li> <code>server-bin</code> &mdash; reader: <code><span class="nolinebreak">software-evolution-library::server-bin</span><!-- /@w --></code>

<p>Database server creation binary
</p></li><li> <code>shutdown-bin</code> &mdash; reader: <code><span class="nolinebreak">software-evolution-library::shutdown-bin</span><!-- /@w --></code>

<p>Database server shutdown binary
</p></li><li> <code>loader-bin</code> &mdash; reader: <code><span class="nolinebreak">software-evolution-library::loader-bin</span><!-- /@w --></code>

<p>Database loader binary
</p></li><li> <code>query-bin</code> &mdash; reader: <code><span class="nolinebreak">software-evolution-library::query-bin</span><!-- /@w --></code>

<p>Database query binary
</p></li><li> <code>server-thread</code> &mdash; reader: <code><span class="nolinebreak">software-evolution-library::server-thread</span><!-- /@w --></code>

<p>Thread running the GTServer
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-random_002dsubtree"></a><dl>
<dt><a name="index-random_002dsubtree"></a>Class: <strong>random-subtree</strong></dt>
<dd><p>Class precedence list: <code>random-subtree, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-replace_002dfodder_002dfull"></a><dl>
<dt><a name="index-replace_002dfodder_002dfull"></a>Class: <strong>replace-fodder-full</strong></dt>
<dd><p>Class precedence list: <code>replace-fodder-full, clang-replace, clang-mutation, parseable-replace, parseable-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Replace an AST in a clang software object with a full
statement fodder AST.
</p></dd></dl>
<a name="Class-simple"></a><dl>
<dt><a name="index-simple"></a>Class: <strong>simple</strong></dt>
<dd><p>Class precedence list: <code>simple, software, standard-object, t</code>
</p>
<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-simple_002dcut"></a><dl>
<dt><a name="index-simple_002dcut"></a>Class: <strong>simple-cut</strong></dt>
<dd><p>Class precedence list: <code>simple-cut, simple-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-simple_002dinsert"></a><dl>
<dt><a name="index-simple_002dinsert"></a>Class: <strong>simple-insert</strong></dt>
<dd><p>Class precedence list: <code>simple-insert, simple-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-simple_002dswap"></a><dl>
<dt><a name="index-simple_002dswap"></a>Class: <strong>simple-swap</strong></dt>
<dd><p>Class precedence list: <code>simple-swap, simple-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-source"></a><dl>
<dt><a name="index-source"></a>Class: <strong>source</strong></dt>
<dd><p>Class precedence list: <code>source, software, standard-object, t</code>
</p>
<p>Raw source code software representation.
</p></dd></dl>
<a name="Class-styleable"></a><dl>
<dt><a name="index-styleable"></a>Class: <strong>styleable</strong></dt>
<dd><p>Class precedence list: <code>styleable, software, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>features</code> &mdash; initarg: <code>:features<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:features</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:features)</span><!-- /@w --></code>

<p>Ordered list of style features.
</p></li><li> <code>feature-vecs</code> &mdash; initarg: <code><span class="nolinebreak">:feature-vecs</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:feature-vecs</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:feature-vecs)</span><!-- /@w --></code>

<p>Vector of feature vectors, same length as features list.
</p></li><li> <code>feature-vec-meta</code> &mdash; initarg: <code><span class="nolinebreak">:feature-vec-meta</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:feature-vec-meta</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:feature-vec-meta)</span><!-- /@w --></code>

<p>Vector of feature vector metadata.
</p></li></ul>

<p>Type of software objects that can have style features extracted.
</p></dd></dl>
<a name="Class-subtract_002dadd"></a><dl>
<dt><a name="index-subtract_002dadd"></a>Class: <strong>subtract-add</strong></dt>
<dd><p>Class precedence list: <code>subtract-add, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-subtract_002dadd_002dtree"></a><dl>
<dt><a name="index-subtract_002dadd_002dtree"></a>Class: <strong>subtract-add-tree</strong></dt>
<dd><p>Class precedence list: <code>subtract-add-tree, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-swap_002ddecls"></a><dl>
<dt><a name="index-swap_002ddecls"></a>Class: <strong>swap-decls</strong></dt>
<dd><p>Class precedence list: <code>swap-decls, clang-swap, clang-mutation, parseable-swap, parseable-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Swap two DeclStmt ASTs in a clang software object.
</p></dd></dl>
<a name="Class-test_002dcase"></a><dl>
<dt><a name="index-test_002dcase"></a>Class: <strong>test-case</strong></dt>
<dd><p>Class precedence list: <code>test-case, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>program-name</code> &mdash; initarg: <code><span class="nolinebreak">:program-name</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:program-name</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:program-name)</span><!-- /@w --></code>

<p>The executable that runs the test case.  
Contains either a string containing the name of an executable file or
special symbol :bin, which will be dynamically replaced by the name of
the compiled phenome for the software object under test.
</p></li><li> <code>program-args</code> &mdash; initarg: <code><span class="nolinebreak">:program-args</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:program-args</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:program-args)</span><!-- /@w --></code>

<p>A list of arguments which will be passed to the executable
<code>program-name</code>. 
Each argument must be either a string or symbol :bin, which will be
replaced by the name of the compiled phenome.
</p></li><li> <code>fitness</code> &mdash; initarg: <code>:fitness<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:fitness</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:fitness)</span><!-- /@w --></code>

<p>May be used to store the fitness result from a prior run of the test case. 
This field is not updated automatically since some components may need
to perform comparisons between new and old values (e.g., condition
synthesis).
</p></li></ul>

<p>Test case object.
</p></dd></dl>
<a name="Class-tighten_002dcondition"></a><dl>
<dt><a name="index-tighten_002dcondition"></a>Class: <strong>tighten-condition</strong></dt>
<dd><p>Class precedence list: <code>tighten-condition, refine-condition, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Add an abstract condition to make a guard less permissive.
<code>e</code>.g., if(foo) becomes if(foo <code>&amp;&amp;</code> !abst_cond()).
</p></dd></dl>
<a name="Class-traceable"></a><dl>
<dt><a name="index-traceable"></a>Class: <strong>traceable</strong></dt>
<dd><p>Class precedence list: <code>traceable, software, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>traces</code> &mdash; initarg: <code>:traces<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:traces</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:traces)</span><!-- /@w --></code>

<p>Execution traces from execution of the software.
</p></li></ul>

<p>Instrumentable software with support for collecting dynamic traces.
</p></dd></dl>
<a name="Class-type_002dsafe_002dswap"></a><dl>
<dt><a name="index-type_002dsafe_002dswap"></a>Class: <strong>type-safe-swap</strong></dt>
<dd><p>Class precedence list: <code>type-safe-swap, lisp-swap, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Swap two Coq ASTs tagged with the same type.
</p></dd></dl>
<a name="Variable-_002aabst_002dcond_002dattempts_002a"></a><dl>
<dt><a name="index-_002aabst_002dcond_002dattempts_002a"></a>Variable: <strong>*abst-cond-attempts*</strong></dt>
<dd><p>Maximum number of combinations for abst_cond() values to attempt before
discarding a repair.
</p></dd></dl>
<a name="Variable-_002abias_002dtoward_002ddynamic_002dmutation_002a"></a><dl>
<dt><a name="index-_002abias_002dtoward_002ddynamic_002dmutation_002a"></a>Variable: <strong>*bias-toward-dynamic-mutation*</strong></dt>
<dd><p>Degree to which dynamic weights are emphasized over default weights.
</p></dd></dl>
<a name="Variable-_002abuild_002ddir_002a"></a><dl>
<dt><a name="index-_002abuild_002ddir_002a"></a>Variable: <strong>*build-dir*</strong></dt>
<dd><p>Directory in which to build projects.
Each project needs a build directory which contains copies of the
build scripts and other dependencies. Paths within a project are
relative to *build-dir*, which allows us to do evolution in multiple
threads by creating separate build directory per thread.
</p></dd></dl>
<a name="Variable-_002aclang_002dast_002daux_002dfields_002a"></a><dl>
<dt><a name="index-_002aclang_002dast_002daux_002dfields_002a"></a>Variable: <strong>*clang-ast-aux-fields*</strong></dt>
<dd><p>Extra fields to read from clang-mutate into ast-aux-data.
</p></dd></dl>
<a name="Variable-_002aclang_002djson_002drequired_002daux_002a"></a><dl>
<dt><a name="index-_002aclang_002djson_002drequired_002daux_002a"></a>Variable: <strong>*clang-json-required-aux*</strong></dt>
<dd><p><code>json</code> database AuxDB entries required for clang software objects.
</p></dd></dl>
<a name="Variable-_002aclang_002djson_002drequired_002dfields_002a"></a><dl>
<dt><a name="index-_002aclang_002djson_002drequired_002dfields_002a"></a>Variable: <strong>*clang-json-required-fields*</strong></dt>
<dd><p><code>json</code> database entry fields required for clang software objects.
</p></dd></dl>
<a name="Variable-_002aclang_002dmax_002djson_002dsize_002a"></a><dl>
<dt><a name="index-_002aclang_002dmax_002djson_002dsize_002a"></a>Variable: <strong>*clang-max-json-size*</strong></dt>
<dd><p>Maximum size of output accepted from &lsquo;clang-mutate&rsquo;.
</p></dd></dl>
<a name="Variable-_002aclang_002dmutation_002dtypes_002a"></a><dl>
<dt><a name="index-_002aclang_002dmutation_002dtypes_002a"></a>Variable: <strong>*clang-mutation-types*</strong></dt>
<dd><p>Cumulative distribution of normalized probabilities of weighted mutations.
</p></dd></dl>
<a name="Variable-_002aclang_002dw_002dfodder_002dnew_002dmutation_002dtypes_002a"></a><dl>
<dt><a name="index-_002aclang_002dw_002dfodder_002dnew_002dmutation_002dtypes_002a"></a>Variable: <strong>*clang-w-fodder-new-mutation-types*</strong></dt>
<dd><p>Fodder mutation types.
</p></dd></dl>
<a name="Variable-_002adead_002dbias_002a"></a><dl>
<dt><a name="index-_002adead_002dbias_002a"></a>Variable: <strong>*dead-bias*</strong></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Variable-_002adynamic_002dlinker_002dpath_002a"></a><dl>
<dt><a name="index-_002adynamic_002dlinker_002dpath_002a"></a>Variable: <strong>*dynamic-linker-path*</strong></dt>
<dd><p>Path to the dynamic linker on this system.
</p></dd></dl>
<a name="Variable-_002aelf_002dcopy_002dredirect_002dpath_002a"></a><dl>
<dt><a name="index-_002aelf_002dcopy_002dredirect_002dpath_002a"></a>Variable: <strong>*elf-copy-redirect-path*</strong></dt>
<dd><p>Path to elf_copy_redirect (or just the name if it&rsquo;s on the path).
</p></dd></dl>
<a name="Variable-_002aelf_002dedit_002dsymtab_002dpath_002a"></a><dl>
<dt><a name="index-_002aelf_002dedit_002dsymtab_002dpath_002a"></a>Variable: <strong>*elf-edit-symtab-path*</strong></dt>
<dd><p>Path to elf_edit_symtab64 or 32 (or just the name if it&rsquo;s on the path).
</p></dd></dl>
<a name="Variable-_002afitness_002devals_002a"></a><dl>
<dt><a name="index-_002afitness_002devals_002a"></a>Variable: <strong>*fitness-evals*</strong></dt>
<dd><p>Track the total number of fitness evaluations.
</p></dd></dl>
<a name="Variable-_002afitness_002dpredicate_002a"></a><dl>
<dt><a name="index-_002afitness_002dpredicate_002a"></a>Variable: <strong>*fitness-predicate*</strong></dt>
<dd><p>Function to compare two fitness values to select which is preferred.
</p></dd></dl>
<a name="Variable-_002afitness_002dscalar_002dfn_002a"></a><dl>
<dt><a name="index-_002afitness_002dscalar_002dfn_002a"></a>Variable: <strong>*fitness-scalar-fn*</strong></dt>
<dd><p>Function to convert fitness to a numeric value
</p></dd></dl>
<a name="Variable-_002agenerations_002a"></a><dl>
<dt><a name="index-_002agenerations_002a"></a>Variable: <strong>*generations*</strong></dt>
<dd><p>Holds the running generation count.
</p></dd></dl>
<a name="Variable-_002alexicase_002dkey_002a"></a><dl>
<dt><a name="index-_002alexicase_002dkey_002a"></a>Variable: <strong>*lexicase-key*</strong></dt>
<dd><p>Optional key function for components of test vector.
</p></dd></dl>
<a name="Variable-_002alib_002dpapi_002a"></a><dl>
<dt><a name="index-_002alib_002dpapi_002a"></a>Variable: <strong>*lib-papi*</strong></dt>
<dd><p>Path to papi library.  See http://icl.cs.utk.edu/papi/.
</p></dd></dl>
<a name="Variable-_002alisp_002dmutation_002dtypes_002a"></a><dl>
<dt><a name="index-_002alisp_002dmutation_002dtypes_002a"></a>Variable: <strong>*lisp-mutation-types*</strong></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Variable-_002amatching_002dfree_002dfunction_002dretains_002dname_002dbias_002a"></a><dl>
<dt><a name="index-_002amatching_002dfree_002dfunction_002dretains_002dname_002dbias_002a"></a>Variable: <strong>*matching-free-function-retains-name-bias*</strong></dt>
<dd><p>The probability that if a free functions&rsquo;s original name matches a name
already in scope, it will keep that name.
</p></dd></dl>
<a name="Variable-_002amatching_002dfree_002dvar_002dretains_002dname_002dbias_002a"></a><dl>
<dt><a name="index-_002amatching_002dfree_002dvar_002dretains_002dname_002dbias_002a"></a>Variable: <strong>*matching-free-var-retains-name-bias*</strong></dt>
<dd><p>The probability that if a free variable&rsquo;s original name matches a name
already in scope, it will keep that name.
</p></dd></dl>
<a name="Variable-_002amcmc_002dfodder_002a"></a><dl>
<dt><a name="index-_002amcmc_002dfodder_002a"></a>Variable: <strong>*mcmc-fodder*</strong></dt>
<dd><p>Holds the genome elements which may be used by &lsquo;mcmc-step&rsquo;.
Should be initialized to a list of the unique possible genome
elements.
</p></dd></dl>
<a name="Variable-_002amut_002drate_002a"></a><dl>
<dt><a name="index-_002amut_002drate_002a"></a>Variable: <strong>*mut-rate*</strong></dt>
<dd><p>Chance to mutate a new individual.
</p><ul>
<li> If &lt;1, new individuals will be mutated once with change <code>*mut-rate*</code>.
</li><li> If =1, then every new individual will be mutated exactly once.
</li><li> If &gt;1, then new individuals will be mutated from 1 to <code>*mut-rate*</code> times.
</li></ul>
</dd></dl>
<a name="Variable-_002amutation_002dimprovements_002a"></a><dl>
<dt><a name="index-_002amutation_002dimprovements_002a"></a>Variable: <strong>*mutation-improvements*</strong></dt>
<dd><p>List of recent mutation improvements cons&rsquo;d with *fitness-evals*.
</p></dd></dl>
<a name="Variable-_002apareto_002dcomparison_002dset_002dsize_002a"></a><dl>
<dt><a name="index-_002apareto_002dcomparison_002dset_002dsize_002a"></a>Variable: <strong>*pareto-comparison-set-size*</strong></dt>
<dd><p>Size of comparison set for Pareto tournaments.
</p></dd></dl>
<a name="Variable-_002apopulation_002a"></a><dl>
<dt><a name="index-_002apopulation_002a"></a>Variable: <strong>*population*</strong></dt>
<dd><p>Holds the variant programs to be evolved.
</p>
<p>This variable may be read to inspect a running search process, or
written to as part of a running search process.
</p></dd></dl>
<a name="Variable-_002asimple_002dmutation_002dtypes_002a"></a><dl>
<dt><a name="index-_002asimple_002dmutation_002dtypes_002a"></a>Variable: <strong>*simple-mutation-types*</strong></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Variable-_002astart_002dtime_002a"></a><dl>
<dt><a name="index-_002astart_002dtime_002a"></a>Variable: <strong>*start-time*</strong></dt>
<dd><p>Holds the start time of evolutionary processes.
</p></dd></dl>
<a name="Variable-_002asynth_002dcondition_002dattempts_002a"></a><dl>
<dt><a name="index-_002asynth_002dcondition_002dattempts_002a"></a>Variable: <strong>*synth-condition-attempts*</strong></dt>
<dd><p>Maximum number of synthesized conditions to test before discarding a repair.
</p></dd></dl>
<a name="Variable-_002atie_002dbreaker_002dpredicate_002a"></a><dl>
<dt><a name="index-_002atie_002dbreaker_002dpredicate_002a"></a>Variable: <strong>*tie-breaker-predicate*</strong></dt>
<dd><p>Function to compare two tie breaker values to select which is preferred.
</p></dd></dl>
<a name="Variable-_002atournament_002deviction_002dsize_002a"></a><dl>
<dt><a name="index-_002atournament_002deviction_002dsize_002a"></a>Variable: <strong>*tournament-eviction-size*</strong></dt>
<dd><p>Number of individuals to participate in eviction tournaments.
</p></dd></dl>
<a name="Variable-_002atournament_002dselector_002a"></a><dl>
<dt><a name="index-_002atournament_002dselector_002a"></a>Variable: <strong>*tournament-selector*</strong></dt>
<dd><p>Function used to select winners of a tournament. Returns a list of
  winners.
</p></dd></dl>
<a name="Variable-_002atournament_002dsize_002a"></a><dl>
<dt><a name="index-_002atournament_002dsize_002a"></a>Variable: <strong>*tournament-size*</strong></dt>
<dd><p>Number of individuals to participate in tournament selection.
</p></dd></dl>
<a name="Variable-_002atournament_002dtie_002dbreaker_002a"></a><dl>
<dt><a name="index-_002atournament_002dtie_002dbreaker_002a"></a>Variable: <strong>*tournament-tie-breaker*</strong></dt>
<dd><p>Function used to break ties in a tournament. Returns a single winner.
</p></dd></dl>
<a name="Variable-_002aworse_002dbias_002a"></a><dl>
<dt><a name="index-_002aworse_002dbias_002a"></a>Variable: <strong>*worse-bias*</strong></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Constant-_002bc_002darithmetic_002dbinary_002doperators_002b"></a><dl>
<dt><a name="index-_002bc_002darithmetic_002dbinary_002doperators_002b"></a>Constant: <strong>+c-arithmetic-binary-operators+</strong></dt>
<dd><p>C arithmetic operators on two arguments.
</p></dd></dl>
<a name="Constant-_002bc_002dbitwise_002dassignment_002doperators_002b"></a><dl>
<dt><a name="index-_002bc_002dbitwise_002dassignment_002doperators_002b"></a>Constant: <strong>+c-bitwise-assignment-operators+</strong></dt>
<dd><p>C bitwise assignment operators.
</p></dd></dl>
<a name="Constant-_002bc_002drelational_002doperators_002b"></a><dl>
<dt><a name="index-_002bc_002drelational_002doperators_002b"></a>Constant: <strong>+c-relational-operators+</strong></dt>
<dd><p>C Relational operators.
</p></dd></dl>
<a name="Constant-_002binstrument_002dlog_002dlock_002dvariable_002dname_002b"></a><dl>
<dt><a name="index-_002binstrument_002dlog_002dlock_002dvariable_002dname_002b"></a>Constant: <strong>+instrument-log-lock-variable-name+</strong></dt>
<dd><p>File lock variable used for instrumentation
</p></dd></dl>
<a name="Class-add_002dcondition"></a><dl>
<dt><a name="index-add_002dcondition"></a>Class: <strong>add-condition</strong></dt>
<dd><p>Class precedence list: <code>add-condition, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Guard a statement with an abstract condition.
<code>e</code>.g., foo; becomes if(abst_cond()) foo;.
</p></dd></dl>
<a name="Variable-_002bsoftware_002devolution_002dlibrary_002dbranch_002b"></a><dl>
<dt><a name="index-_002bsoftware_002devolution_002dlibrary_002dbranch_002b"></a>Variable: <strong>+software-evolution-library-branch+</strong></dt>
<dd><p>Current branch of the <code>software-evolution-library</code>.
</p></dd></dl>
<a name="Generic_002dFunction-add_002dmacro"></a><dl>
<dt><a name="index-add_002dmacro"></a>Generic Function: <strong>add-macro</strong> <em>software macro</em></dt>
<dd><p>Add <code>macro</code> to &lsquo;macros&rsquo; of <code>software</code>, unique by hash.
</p></dd></dl>
<a name="Method-add_002dmacro-_0028_0028obj-clang_0029-_0028macro-clang_002dmacro_0029_0029"></a><dl>
<dt><a name="index-add_002dmacro-1"></a>Method: <strong>add-macro</strong> <em>(obj clang) (macro clang-macro)</em></dt>
<dd><p>Add <code>macro</code> to &lsquo;macros&rsquo; of <code>obj</code>, unique by hash.
</p><ul>
<li> <code>obj</code> object to modify with macro
</li><li> <code>macro</code> macro to add
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-add_002dtype"></a><dl>
<dt><a name="index-add_002dtype"></a>Generic Function: <strong>add-type</strong> <em>software type</em></dt>
<dd><p>Add <code>type</code> to &lsquo;types&rsquo; of <code>software</code>, unique by hash.
</p></dd></dl>
<a name="Method-add_002dtype-_0028_0028obj-clang_0029-_0028type-null_0029_0029"></a><dl>
<dt><a name="index-add_002dtype-1"></a>Method: <strong>add-type</strong> <em>(obj clang) (type null)</em></dt>
<dd><p>Add <code>type</code> to &lsquo;types&rsquo; of <code>obj</code>, unique by hash.
</p><ul>
<li> <code>obj</code> software object to modify
</li><li> <code>type</code> null to allow for nop when nil is passed for the type argument
</li></ul>
</dd></dl>
<a name="Method-add_002dtype-_0028_0028obj-clang_0029-_0028type-clang_002dtype_0029_0029"></a><dl>
<dt><a name="index-add_002dtype-2"></a>Method: <strong>add-type</strong> <em>(obj clang) (type clang-type)</em></dt>
<dd><p>Add <code>type</code> to &lsquo;types&rsquo; of <code>obj</code>, unique by hash.
</p><ul>
<li> <code>obj</code> software object to modify
</li><li> <code>type</code> type to be added
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-all_002dast_002dnode_002dtypes"></a><dl>
<dt><a name="index-all_002dast_002dnode_002dtypes"></a>Generic Function: <strong>all-ast-node-types</strong> <em>software</em></dt>
<dd><p>Return a list of all possible types of AST nodes for ASTs in <code>software</code>.
</p></dd></dl>
<a name="Method-all_002dast_002dnode_002dtypes-_0028_0028clang-clang_0029_0029"></a><dl>
<dt><a name="index-all_002dast_002dnode_002dtypes-1"></a>Method: <strong>all-ast-node-types</strong> <em>(clang clang)</em></dt>
<dd><p>Return a list of all possible types of AST nodes for ASTs in <code>clang</code>.
Uses &lsquo;*clang-c-ast-classes*&rsquo;.
</p></dd></dl>
<a name="Generic_002dFunction-apply_002dconfig"></a><dl>
<dt><a name="index-apply_002dconfig"></a>Generic Function: <strong>apply-config</strong> <em>software config-file</em></dt>
<dd><p>Parse <code>config-file</code> and use to configure <code>software</code>.
</p></dd></dl>
<a name="Method-apply_002dconfig-_0028_0028obj-csurf_002dasm_0029-log_002dfile_0029"></a><dl>
<dt><a name="index-apply_002dconfig-1"></a>Method: <strong>apply-config</strong> <em>(obj csurf-asm) log-file</em></dt>
<dd><p>Parse <code>log-file</code> to update fields of <code>csurf-asm</code> software object.
</p></dd></dl>
<a name="Generic_002dFunction-apply_002dpath"></a><dl>
<dt><a name="index-apply_002dpath"></a>Generic Function: <strong>apply-path</strong> <em>software key path</em></dt>
<dd><p>Apply the execution trace <code>path</code> behind <code>key</code> in <code>software</code>.
</p></dd></dl>
<a name="Method-apply_002dpath-_0028_0028elf-elf_002dcisc_0029-key-addresses-_0026aux-applied_0029"></a><dl>
<dt><a name="index-apply_002dpath-1"></a>Method: <strong>apply-path</strong> <em>(elf elf-cisc) key addresses &amp;aux applied</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-apply_002dpath-_0028_0028asm-asm_0029-key-addresses-_0026aux-applied_0029"></a><dl>
<dt><a name="index-apply_002dpath-2"></a>Method: <strong>apply-path</strong> <em>(asm asm) key addresses &amp;aux applied</em></dt>
<dd><p>Apply a list of sampled <code>addresses</code> to the ASM&rsquo;s genome behind <code>key</code>.
If each element of <code>addresses</code> is a cons cell then assume the car is the
address and the cdr is the value.
</p></dd></dl>
<a name="Generic_002dFunction-ast_002dbi_002dgrams_002dextractor"></a><dl>
<dt><a name="index-ast_002dbi_002dgrams_002dextractor"></a>Generic Function: <strong>ast-bi-grams-extractor</strong> <em>software</em></dt>
<dd><p>Return a feature vector counting AST node type bi-grams.
</p></dd></dl>
<a name="Class-cil"></a><dl>
<dt><a name="index-cil"></a>Class: <strong>cil</strong></dt>
<dd><p>Class precedence list: <code>cil, source, software, standard-object, t</code>
</p>
<p>C abstract syntax trees using C Intermediate Language <code>(cil)</code>.
See http://kerneis.github.io/cil/.
</p></dd></dl>
<a name="Class-parseable"></a><dl>
<dt><a name="index-parseable"></a>Class: <strong>parseable</strong></dt>
<dd><p>Class precedence list: <code>parseable, source, software, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>ast-root</code> &mdash; initarg: <code><span class="nolinebreak">:ast-root</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:ast-root</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:ast-root)</span><!-- /@w --></code>

<p>Root node of AST.
</p></li><li> <code>asts</code> &mdash; initarg: <code>:asts<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:asts</span><!-- /@w --></code>

<p>List of all ASTs.
</p></li><li> <code>asts-changed-p</code> &mdash; reader: <code><span class="nolinebreak">software-evolution-library::asts-changed-p</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::asts-changed-p)</span><!-- /@w --></code>

<p>Have ASTs changed since the last parse?
</p></li><li> <code>copy-lock</code> &mdash; 

<p>Lock while copying parseable objects.
</p></li></ul>

<p>Parsed AST tree software representation.
</p></dd></dl>
<a name="Class-style_002dproject"></a><dl>
<dt><a name="index-style_002dproject"></a>Class: <strong>style-project</strong></dt>
<dd><p>Class precedence list: <code>style-project, styleable, project, software, standard-object, t</code>
</p>
<p>A project with style-features.
</p></dd></dl>
<a name="Variable-ast_002dkeyword_002dtf_002dfeature"></a><dl>
<dt><a name="index-ast_002dkeyword_002dtf_002dfeature"></a>Variable: <strong>ast-keyword-tf-feature</strong></dt>
<dd><p>Term frequency of keywords in an AST.
</p></dd></dl>
<a name="Generic_002dFunction-ast_002dnode_002dtype_002davg_002ddepth_002dextractor"></a><dl>
<dt><a name="index-ast_002dnode_002dtype_002davg_002ddepth_002dextractor"></a>Generic Function: <strong>ast-node-type-avg-depth-extractor</strong> <em>software</em></dt>
<dd><p>Returns a feature vector of average depth of AST nodes by type.
The length is the number of possible AST node tyes (as determined by
&lsquo;all-ast-node-types&rsquo;). Each element is the average depth of nodes of the
corresponding type in the AST of <code>software</code>.
</p></dd></dl>
<a name="Generic_002dFunction-asts"></a><dl>
<dt><a name="index-asts"></a>Generic Function: <strong>asts</strong> <em>obj</em></dt>
<dd><p>Return a list of all asts in <code>obj</code>.
</p></dd></dl>
<a name="Method-asts-_0028_0028obj-clang_002dproject_0029_0029"></a><dl>
<dt><a name="index-asts-1"></a>Method: <strong>asts</strong> <em>(obj clang-project)</em></dt>
<dd><p>Return a list of all ASTs in the project <code>obj</code>.
</p></dd></dl>
<a name="Method-asts-before-_0028_0028obj-parseable_0029_0029"></a><dl>
<dt><a name="index-before-asts"></a>Method: <strong>before asts</strong> <em>(obj parseable)</em></dt>
<dd><p>Ensure the &lsquo;asts&rsquo; field is set on <code>obj</code> prior to access.
</p></dd></dl>
<a name="Method-asts-_0028_0028parseable-parseable_0029_0029"></a><dl>
<dt><a name="index-asts-2"></a>Method: <strong>asts</strong> <em>(parseable parseable)</em></dt>
<dd><p>List of all ASTs.
</p></dd></dl>
<a name="Generic_002dFunction-astyle"></a><dl>
<dt><a name="index-astyle"></a>Generic Function: <strong>astyle</strong> <em>software &amp;optional style options</em></dt>
<dd><p>Apply Artistic Style to the software.
Documentation can be found at
http://astyle.sourceforge.net/astyle.html#_Usage
</p></dd></dl>
<a name="Method-astyle-_0028_0028clang_002dproject-clang_002dproject_0029-_0026optional-_0028style-nil-style_002dp_0029-_0028options-nil-options_002dp_0029_0029"></a><dl>
<dt><a name="index-astyle-1"></a>Method: <strong>astyle</strong> <em>(clang-project clang-project) &amp;optional (style nil style-p) (options nil options-p)</em></dt>
<dd><p>Apply Artistic Style to <code>clang-project</code>.
</p><ul>
<li> <code>clang-project</code> project to format and return
</li><li> <code>style</code> style to utilize
</li><li> <code>options</code> list of additional options to astyle
</li></ul>
</dd></dl>
<a name="Method-astyle-_0028_0028obj-clang_0029-_0026optional-_0028style-kr_0029-_0028options-_0027_0028_002d_002dadd_002dbrackets_0029_0029-_0026aux-errno_0029"></a><dl>
<dt><a name="index-astyle-2"></a>Method: <strong>astyle</strong> <em>(obj clang) &amp;optional (style kr) (options (quote (--add-brackets))) &amp;aux errno</em></dt>
<dd><p>Apply Artistic Style to <code>obj</code>.
</p><ul>
<li> <code>obj</code> object to format and return
</li><li> <code>style</code> style to utilize
</li><li> <code>options</code> list of additional options to astyle
</li><li> <code>errno</code> Exit code of astyle binary
</li></ul>
</dd></dl>
<a name="Method-astyle-_0028_0028obj-java_0029-_0026optional-style-options_0029"></a><dl>
<dt><a name="index-astyle-3"></a>Method: <strong>astyle</strong> <em>(obj java) &amp;optional style options</em></dt>
<dd><p>This method currently has not effect on Java objects.
</p></dd></dl>
<a name="Generic_002dFunction-clang_002dtidy"></a><dl>
<dt><a name="index-clang_002dtidy"></a>Generic Function: <strong>clang-tidy</strong> <em>software &amp;optional checks</em></dt>
<dd><p>Apply the software fixing clang tool, optionally using
the given list of <code>checks</code>.
</p></dd></dl>
<a name="Method-clang_002dtidy-_0028_0028clang_002dproject-clang_002dproject_0029-_0026optional-_0028checks-nil-checks_002dp_0029_0029"></a><dl>
<dt><a name="index-clang_002dtidy-1"></a>Method: <strong>clang-tidy</strong> <em>(clang-project clang-project) &amp;optional (checks nil checks-p)</em></dt>
<dd><p>Apply &lsquo;clang-tidy&rsquo; to <code>clang-project</code>.
* <code>clang-project</code> project to tidy and return
</p></dd></dl>
<a name="Method-clang_002dtidy-_0028_0028clang-clang_0029-_0026optional--_0028checks--_0027_0028cppcore_002dguidelines_002a-misc_002a-_002dmisc_002dmacro_002dparentheses-_002dmisc_002dstatic_002dassert-_002dmisc_002dunused_002dparameters-_002dmodernize_002a-performance_002a--_002dperformance_002dunnecessary_002dvalue_002dparam-readability_002a-_002dreadability_002delse_002dafter_002dreturn-_002dreadability_002dfunction_002dsize-_002dreadability_002didentifier_002dnaming--_002dreadability_002dimplicit_002dbool_002dconversion-_002dreadability_002dinconsistent_002ddeclaration_002dparameter_002dname-_002dreadability_002dnon_002dconst_002dparameter--_002dreadability_002dredundant_002dcontrol_002dflow-_002dreadability_002dredundant_002ddeclaration_0029_0029--_0026aux-errno_0029"></a><dl>
<dt><a name="index-clang_002dtidy-2"></a>Method: <strong>clang-tidy</strong> <em>(clang clang) &amp;optional (checks (quote (cppcore-guidelines* misc* -misc-macro-parentheses -misc-static-assert -misc-unused-parameters -modernize* performance* -performance-unnecessary-value-param readability* -readability-else-after-return -readability-function-size -readability-identifier-naming -readability-implicit-bool-conversion -readability-inconsistent-declaration-parameter-name -readability-non-const-parameter -readability-redundant-control-flow -readability-redundant-declaration))) &amp;aux errno</em></dt>
<dd><p>Apply clang-tidy to <code>obj</code>.
</p><ul>
<li> <code>clang</code> object to tidy and return
</li><li> <code>checks</code> list of clang-tidy checks to apply
</li><li> <code>errno</code> Exit code of clang-tidy
</li></ul>
</dd></dl>
<a name="Method-clang_002dtidy-_0028_0028obj-java_0029-_0026optional-checks_0029"></a><dl>
<dt><a name="index-clang_002dtidy-3"></a>Method: <strong>clang-tidy</strong> <em>(obj java) &amp;optional checks</em></dt>
<dd><p>This method has no effect on Java objects.
</p></dd></dl>
<a name="Generic_002dFunction-copy"></a><dl>
<dt><a name="index-copy"></a>Generic Function: <strong>copy</strong> <em>software &amp;key hash name body array col decl file line i-file pointer const volatile restrict storage-class reqs size path children args class counter declares expr-type full-stmt guard-stmt in-macro-expansion includes is-decl macros opcode ret syn-ctx types unbound-funs unbound-vals varargs void-ret array-length base-type bit-field-width aux-data &amp;allow-other-keys</em></dt>
<dd><p>Copy the software.
Return a deep copy of a software object.
</p></dd></dl>
<a name="Method-copy-before-_0028_0028obj-parseable_0029-_0026key_0029"></a><dl>
<dt><a name="index-before-copy"></a>Method: <strong>before copy</strong> <em>(obj parseable) &amp;key</em></dt>
<dd><p>Update ASTs in <code>obj</code> prior to performing a copy.
* <code>obj</code> software object to copy
</p></dd></dl>
<a name="Method-copy-_0028_0028asm-asm_002drange_0029-_0026key_0029"></a><dl>
<dt><a name="index-copy-1"></a>Method: <strong>copy</strong> <em>(asm asm-range) &amp;key</em></dt>
<dd><p>Customized copy for &lsquo;asm-range&rsquo; software objects.
Ensures deep copies are made of the genome (ranges) but shallow copies
are made of the reference base genome.
</p></dd></dl>
<a name="Method-copy-_0028_0028diff-diff_0029-_0026key_0029"></a><dl>
<dt><a name="index-copy-2"></a>Method: <strong>copy</strong> <em>(diff diff) &amp;key</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Condition-phenome"></a><dl>
<dt><a name="index-phenome-11"></a>Condition: <strong>phenome</strong></dt>
<dd><p>Class precedence list: <code>phenome, error, serious-condition, condition, t</code>
</p>
<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-clang_002dswap_002dfull"></a><dl>
<dt><a name="index-clang_002dswap_002dfull"></a>Class: <strong>clang-swap-full</strong></dt>
<dd><p>Class precedence list: <code>clang-swap-full, clang-swap, clang-mutation, parseable-swap, parseable-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Perform a swap operation on a clang software object,
only swapping full statements.
</p></dd></dl>
<a name="Class-clang_002dw_002dfodder"></a><dl>
<dt><a name="index-clang_002dw_002dfodder"></a>Class: <strong>clang-w-fodder</strong></dt>
<dd><p>Class precedence list: <code>clang-w-fodder, clang, parseable, source, software, standard-object, t</code>
</p>
<p>clang software resentation with a database
containing AST entries as fodder for the evolution process.
</p></dd></dl>
<a name="Class-demote_002dbinop_002dright"></a><dl>
<dt><a name="index-demote_002dbinop_002dright"></a>Class: <strong>demote-binop-right</strong></dt>
<dd><p>Class precedence list: <code>demote-binop-right, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-diff"></a><dl>
<dt><a name="index-diff"></a>Class: <strong>diff</strong></dt>
<dd><p>Class precedence list: <code>diff, simple, software, standard-object, t</code>
</p>
<p>Alternative to <code>simple</code> software objects which should use less memory.
Instead of directly holding code in the <code>genome</code>, each <code>genome</code> is a list
of range references to an external <code>reference</code> code array.
</p>
<p>Similar to the range approach, but striving for a simpler interface.
</p></dd></dl>
<a name="Class-elf_002drisc"></a><dl>
<dt><a name="index-elf_002drisc"></a>Class: <strong>elf-risc</strong></dt>
<dd><p>Class precedence list: <code>elf-risc, elf, simple, software, standard-object, t</code>
</p>
<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-style_002dfeature"></a><dl>
<dt><a name="index-style_002dfeature"></a>Class: <strong>style-feature</strong></dt>
<dd><p>Class precedence list: <code>style-feature, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>feature-name</code> &mdash; initarg: <code><span class="nolinebreak">:feature-name</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:feature-name</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:feature-name)</span><!-- /@w --></code>

<p>Name of style feature.
</p></li><li> <code>extractor-fn</code> &mdash; initarg: <code><span class="nolinebreak">:extractor-fn</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:extractor-fn</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:extractor-fn)</span><!-- /@w --></code>

<p>Feature extractor function, takes a software object
and returns a feature vector and metadata necessary to merge feature vectors.
</p></li><li> <code>merge-fn</code> &mdash; initarg: <code><span class="nolinebreak">:merge-fn</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:merge-fn</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:merge-fn)</span><!-- /@w --></code>

<p>Function to merge two feature vectors. Takes as input a
two feature vectors and their metadata (as returned by the extractor) and
returns a new feature vector and updated metadata.
</p></li></ul>

<p>Type of style feature, including a feature extractor and an
accompanying merge function for combining feature vectors.
</p></dd></dl>
<a name="Variable-_002aclang_002dmutate_002dadditional_002dargs_002a"></a><dl>
<dt><a name="index-_002aclang_002dmutate_002dadditional_002dargs_002a"></a>Variable: <strong>*clang-mutate-additional-args*</strong></dt>
<dd><p>Extra arguments to pass to clang-mutate when parsing
</p></dd></dl>
<a name="Variable-_002arunning_002a"></a><dl>
<dt><a name="index-_002arunning_002a"></a>Variable: <strong>*running*</strong></dt>
<dd><p>True when a search process is running, set to nil to stop evolution.
</p></dd></dl>
<a name="Variable-_002bsoftware_002devolution_002dlibrary_002ddir_002b"></a><dl>
<dt><a name="index-_002bsoftware_002devolution_002dlibrary_002ddir_002b"></a>Variable: <strong>+software-evolution-library-dir+</strong></dt>
<dd><p>Path to directory holding <code>software-evolution-library</code>.
</p></dd></dl>
<a name="Variable-ast_002dbi_002dgrams_002dfeature"></a><dl>
<dt><a name="index-ast_002dbi_002dgrams_002dfeature"></a>Variable: <strong>ast-bi-grams-feature</strong></dt>
<dd><p>Number of occurrences of AST node type bi-grams in an AST.
</p></dd></dl>
<a name="Variable-ast_002dnode_002dtype_002davg_002ddepth_002dfeature"></a><dl>
<dt><a name="index-ast_002dnode_002dtype_002davg_002ddepth_002dfeature"></a>Variable: <strong>ast-node-type-avg-depth-feature</strong></dt>
<dd><p>Average depth of each possible node type in the AST.
</p></dd></dl>
<a name="Generic_002dFunction-ast_002dnode_002dtype_002dtf_002dextractor"></a><dl>
<dt><a name="index-ast_002dnode_002dtype_002dtf_002dextractor"></a>Generic Function: <strong>ast-node-type-tf-extractor</strong> <em>software</em></dt>
<dd><p>Return a vector with counts of occurrences of each possible AST node type.
</p>
<p>The returned vector will have one entry for each ast class listed in &lsquo;clang-c-ast-classes&rsquo;.
</p></dd></dl>
<a name="Variable-avg_002ddepth_002dast_002dfeature"></a><dl>
<dt><a name="index-avg_002ddepth_002dast_002dfeature"></a>Variable: <strong>avg-depth-ast-feature</strong></dt>
<dd><p>Average depth of nodes in the AST.
</p></dd></dl>
<a name="Generic_002dFunction-block_002dp"></a><dl>
<dt><a name="index-block_002dp"></a>Generic Function: <strong>block-p</strong> <em>software statement</em></dt>
<dd><p>Check if <code>statement</code> is a block in <code>software</code>.
</p></dd></dl>
<a name="Method-block_002dp-_0028_0028obj-clang_0029-_0028stmt-clang_002dast_0029_0029"></a><dl>
<dt><a name="index-block_002dp-1"></a>Method: <strong>block-p</strong> <em>(obj clang) (stmt clang-ast)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>stmt</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Class-clang"></a><dl>
<dt><a name="index-clang"></a>Class: <strong>clang</strong></dt>
<dd><p>Class precedence list: <code>clang, parseable, source, software, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>stmt-asts</code> &mdash; initarg: <code><span class="nolinebreak">:stmt-asts</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:stmt-asts</span><!-- /@w --></code>

<p>List of statement ASTs which exist within a function body.
</p></li><li> <code>non-stmt-asts</code> &mdash; initarg: <code><span class="nolinebreak">:non-stmt-asts</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:non-stmt-asts</span><!-- /@w --></code>

<p>List of global AST which live outside of any function.
</p></li><li> <code>functions</code> &mdash; initarg: <code>:functions<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:functions</span><!-- /@w --></code>

<p>Complete functions with bodies.
</p></li><li> <code>prototypes</code> &mdash; initarg: <code>:prototypes<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:prototypes</span><!-- /@w --></code>

<p>Function prototypes.
</p></li><li> <code>includes</code> &mdash; initarg: <code>:includes<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:includes</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:includes)</span><!-- /@w --></code>

<p>Names of included includes.
</p></li><li> <code>types</code> &mdash; initarg: <code>:types<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:types</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:types)</span><!-- /@w --></code>

<p>Association list of types keyed by <code>hash</code> id.
</p></li><li> <code>macros</code> &mdash; initarg: <code>:macros<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:macros</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:macros)</span><!-- /@w --></code>

<p>Association list of Names and values of macros.
</p></li></ul>

<p>C language (C, C++, <code>c#</code>, etc...) ASTs using Clang, C language frontend for <code>llvm</code>.
See http://clang.llvm.org/.
</p></dd></dl>
<a name="Class-clang_002dmutation"></a><dl>
<dt><a name="index-clang_002dmutation"></a>Class: <strong>clang-mutation</strong></dt>
<dd><p>Class precedence list: <code>clang-mutation, mutation, standard-object, t</code>
</p>
<p>Specialization of the mutation interface for clang software
objects.
</p></dd></dl>
<a name="Generic_002dFunction-collect_002dfault_002dloc_002dtraces"></a><dl>
<dt><a name="index-collect_002dfault_002dloc_002dtraces"></a>Generic Function: <strong>collect-fault-loc-traces</strong> <em>bin test-suite read-trace-fn &amp;optional fl-neg-test</em></dt>
<dd><p>Run test cases and collect execution traces.
</p>
<p>Returns a list of traces where the notion of &quot;good&quot; traces (from
passing tests) &quot;bad&quot; traces (from failing tests) are recorded in a
manner that the client can later digest.
</p>
<p><code>bin</code> is the path to software object which has already been instrumented
and built.  <code>read-trace-fn</code> is a function for reading the traces
generated by that instrumentation. fl-neg-test specifies a list of
tests to be considered the &rsquo;failing&rsquo; tests (indicating a bug,
usually).
</p>
<p>No assumptions are made about the format or contents of the traces.
</p></dd></dl>
<a name="Method-collect_002dfault_002dloc_002dtraces-_0028bin-test_002dsuite-read_002dtrace_002dfn-_0026optional-fl_002dneg_002dtest_0029"></a><dl>
<dt><a name="index-collect_002dfault_002dloc_002dtraces-1"></a>Method: <strong>collect-fault-loc-traces</strong> <em>bin test-suite read-trace-fn &amp;optional fl-neg-test</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>bin</code> <code>docfixme</code>
</li><li> <code>test-suite</code> <code>docfixme</code>
</li><li> <code>read-trace-fn</code> <code>docfixme</code>
</li><li> <code>fl-neg-test</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-declared_002dtype"></a><dl>
<dt><a name="index-declared_002dtype"></a>Generic Function: <strong>declared-type</strong> <em>ast variable-name</em></dt>
<dd><p>Guess the type of the <code>variable-name</code> in AST.
<code>variable-name</code> should be declared in AST.
</p></dd></dl>
<a name="Method-declared_002dtype-_0028_0028ast-clang_002dast_0029-variable_002dname_0029"></a><dl>
<dt><a name="index-declared_002dtype-1"></a>Method: <strong>declared-type</strong> <em>(ast clang-ast) variable-name</em></dt>
<dd><p>Guess the type of the <code>variable-name</code> in AST.
<code>variable-name</code> should be declared in AST.
</p></dd></dl>
<a name="Variable-elf_002drisc_002dmax_002ddisplacement"></a><dl>
<dt><a name="index-elf_002drisc_002dmax_002ddisplacement"></a>Variable: <strong>elf-risc-max-displacement</strong></dt>
<dd><p>Maximum range that &lsquo;elf-insert&rsquo; will displace instructions.
This is the range within which insertion will search for a nop to
delete, if none is found in this range insertion becomes replacement.
A value of nil means never replace.
</p></dd></dl>
<a name="Macro-compose_002dmutations"></a><dl>
<dt><a name="index-compose_002dmutations"></a>Macro: <strong>compose-mutations</strong> <em>class-name mutations &amp;rest options</em></dt>
<dd><p>Define a new mutation named <code>class-name</code> composing <code>mutations</code>.
<code>mutations</code> is a list of the names of mutation classes.
</p></dd></dl>
<a name="Macro-define_002dfeature"></a><dl>
<dt><a name="index-define_002dfeature"></a>Macro: <strong>define-feature</strong> <em>feature-name feature-desc (extractor-fn eargs extractor-desc &amp;rest ebody) (merge-fn &amp;optional margs &amp;rest mbody)</em></dt>
<dd><p>A macro for defining feature extractors.
</p><ul>
<li> <code>feature-name</code> a new variable of this name will hold the style-feature object
</li><li> <code>feature-desc</code> a docstring for the variable <code>feature-name</code>
</li><li> <code>extractor-fn</code> the name for the function to perform feature extraction
</li><li> <code>eargs</code> argument to <code>extractor-fn</code> (should just be one, a software object)
</li><li> <code>extractor-desc</code> a docstring for <code>extractor-fn</code>
</li><li> <code>ebody</code> function body of <code>extractor-fn</code>
</li><li> <code>merge-fn</code> the merge function to merge two feature vectors for this feature.
</li></ul>
<p>If the function doesn&rsquo;t exist, <code>margs</code> and <code>mbody</code> should be provided. Otherwise,
they should not be provided.
* <code>margs</code> arguments to the merge function (should be 4: vector1, metadata1,
vector2, metadata2). Not required if <code>merge-fn</code> is already a defined function.
* <code>mbody</code> body of the merge function. Not required if <code>merge-fn</code> is already a
defined function.
</p></dd></dl>
<a name="Macro-define_002dsoftware"></a><dl>
<dt><a name="index-define_002dsoftware"></a>Macro: <strong>define-software</strong> <em>name direct-superclasses direct-slots &amp;rest options</em></dt>
<dd><p>Define a new &lsquo;software&rsquo; class <code>name</code> including a deep &lsquo;copy&rsquo; method.
Arguments <code>name</code> <code>direct-superclasses</code> and <code>options</code> are passed through to
&lsquo;defclass&rsquo; unmodified.  Additional optional <code>:copier</code> property on each
slot in <code>direct-slots</code> may be one of the following:
</p>
<ul>
<li> <code>:none</code> this slot is not copied and will be nil in the new object
</li><li> <code>:direct</code> this slot is copied by direct reference to the slot value
          skipping the accessor
</li><li> otherwise if the value of <code>:copier</code> is nil (default) then the slot is
            copied through its accessor, otherwise the value is
            assumed to be a function (e.g., &lsquo;copy-tree&rsquo;) which is used
            to copy the slot.
</li></ul>
</dd></dl>
<a name="Function-clang_002dinstrument"></a><dl>
<dt><a name="index-clang_002dinstrument"></a>Function: <strong>clang-instrument</strong> <em>args</em></dt>
<dd><p>Interface to the command line instrumentation tool.
* <code>args</code> command-line arguments
</p></dd></dl>
<a name="Function-crossed"></a><dl>
<dt><a name="index-crossed"></a>Function: <strong>crossed</strong> <em>&amp;optional a b</em></dt>
<dd><p>Generate a new individual from <code>*population*</code> using crossover.
</p></dd></dl>
<a name="Function-default_002drandom_002dwinner"></a><dl>
<dt><a name="index-default_002drandom_002dwinner"></a>Function: <strong>default-random-winner</strong> <em>group &amp;key predicate</em></dt>
<dd><p>Choose a random winner from <code>group</code>.
</p></dd></dl>
<a name="Function-default_002dselect_002dbest"></a><dl>
<dt><a name="index-default_002dselect_002dbest"></a>Function: <strong>default-select-best</strong> <em>group &amp;key predicate</em></dt>
<dd><p>Return the members of <code>group</code> with most <code>predicate</code> fitness.
Default selection function for &lsquo;tournament&rsquo;.
</p></dd></dl>
<a name="Generic_002dFunction-delete_002ddecl_002dstmts"></a><dl>
<dt><a name="index-delete_002ddecl_002dstmts"></a>Generic Function: <strong>delete-decl-stmts</strong> <em>software block replacements</em></dt>
<dd><p>Return mutation ops applying <code>replacements</code> to <code>block</code> in <code>software</code>.
<code>replacements</code> is a list holding lists of an <code>id</code> to replace, and the new
variables to replace use of the variables declared in stmt <code>id</code>.
</p></dd></dl>
<a name="Method-delete_002ddecl_002dstmts-_0028_0028obj-clang_0029-_0028block-clang_002dast_0029-_0028replacements-list_0029_0029"></a><dl>
<dt><a name="index-delete_002ddecl_002dstmts-1"></a>Method: <strong>delete-decl-stmts</strong> <em>(obj clang) (block clang-ast) (replacements list)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>block</code> <code>docfixme</code>
</li><li> <code>replacements</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-enclosing_002dfull_002dstmt"></a><dl>
<dt><a name="index-enclosing_002dfull_002dstmt"></a>Generic Function: <strong>enclosing-full-stmt</strong> <em>software stmt</em></dt>
<dd><p>Return the first full statement in <code>software</code> holding <code>stmt</code>.
</p></dd></dl>
<a name="Method-enclosing_002dfull_002dstmt-_0028_0028obj-clang_0029-_0028stmt-clang_002dast_0029_0029"></a><dl>
<dt><a name="index-enclosing_002dfull_002dstmt-1"></a>Method: <strong>enclosing-full-stmt</strong> <em>(obj clang) (stmt clang-ast)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>stmt</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-extract_002dbaseline_002dfeatures"></a><dl>
<dt><a name="index-extract_002dbaseline_002dfeatures"></a>Generic Function: <strong>extract-baseline-features</strong> <em>styleable &amp;key features</em></dt>
<dd><p>For a <code>styleable</code>, extract <code>features</code> to establish baseline feature vectors.
Returns two values: a vector of feature vectors and a vector of metadata.
</p></dd></dl>
<a name="Method-extract_002dbaseline_002dfeatures-_0028_0028style-styleable_0029-_0026key-_0028features-_002afeature_002dextractors_002a_0029_0029"></a><dl>
<dt><a name="index-extract_002dbaseline_002dfeatures-1"></a>Method: <strong>extract-baseline-features</strong> <em>(style styleable) &amp;key (features *feature-extractors*)</em></dt>
<dd><p>For a styleable <code>style</code>, extract <code>features</code> to establish baseline feature vectors.
Return two values: a vector of feature vectors and a vector of metadata.
</p><ul>
<li> <code>style</code> a styleable software object
</li><li> <code>features</code> a list of style-features to extract (default: &lsquo;*feature-extractors*&rsquo;)
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-extract_002dfeature"></a><dl>
<dt><a name="index-extract_002dfeature"></a>Generic Function: <strong>extract-feature</strong> <em>styleable style-feature</em></dt>
<dd><p>For a <code>styleable</code> object, extract a single <code>style-feature</code>.
Updates the corresponding feature-vector and feature-vec-meta data in <code>styleable</code>
and returns two values: the extracted feature vector and its metadata.
</p></dd></dl>
<a name="Method-extract_002dfeature-_0028_0028style-styleable_0029-_0028feature-style_002dfeature_0029_0029"></a><dl>
<dt><a name="index-extract_002dfeature-1"></a>Method: <strong>extract-feature</strong> <em>(style styleable) (feature style-feature)</em></dt>
<dd><p>For a styleable <code>style</code> object, extract a single style-feature <code>feature</code>.
Updates the corresponding feature-vector and feature-vec-meta data in <code>style</code> and
returns two values: the extracted feature vector and its metadata.
</p><ul>
<li> <code>style</code> a styleable software object
</li><li> <code>feature</code> a style-feature to extract
</li></ul>
</dd></dl>
<a name="Variable-max_002ddepth_002dast_002dfeature"></a><dl>
<dt><a name="index-max_002ddepth_002dast_002dfeature"></a>Variable: <strong>max-depth-ast-feature</strong></dt>
<dd><p>Maximum depth of any node in the AST.
</p></dd></dl>
<a name="Macro-ignore_002dphenome_002derrors"></a><dl>
<dt><a name="index-ignore_002dphenome_002derrors"></a>Macro: <strong>ignore-phenome-errors</strong> <em>&amp;rest body</em></dt>
<dd><p>Handle errors in &lsquo;phenome&rsquo; execution by returning nil as the
first value from the &lsquo;phenome&rsquo; method.
</p></dd></dl>
<a name="Macro-to_002dclang_002dast"></a><dl>
<dt><a name="index-to_002dclang_002dast"></a>Macro: <strong>to-clang-ast</strong> <em>spec</em></dt>
<dd><p>Walk a potentially recursive clang-ast <code>spec</code> creating a &lsquo;clang-ast&rsquo;.
A <code>spec</code> should have the form
</p>
<div class="example">
<pre class="example">    (clang-ast-class &lt;optional-keyword-args-to-`make-clang-ast-node'&gt;
                     CHILDREN)
</pre></div>

<p>where <code>children</code> may themselves be specifications suitable for passing
to &lsquo;to-clang-ast&rsquo;.  <code>e</code>.g.,
</p>
<div class="example">
<pre class="example">    (to-clang-ast (:callexpr (:implicitcastexpr
                              :includes '(&quot;&lt;string.h&gt;&quot;)
                              &quot;&quot; &quot;(|strcpy|)&quot; &quot;&quot;)
                             &quot;(&quot; &quot;arg-1&quot; &quot;,&quot; &quot;arg-2&quot; &quot;)&quot;))
</pre></div>
</dd></dl>
<a name="Function-asm_002dsuper_002dmutant_002dtest_002dfunction"></a><dl>
<dt><a name="index-asm_002dsuper_002dmutant_002dtest_002dfunction"></a>Function: <strong>asm-super-mutant-test-function</strong> <em>asm-path func-name mutants-generator &amp;key io-dir var-address-file fitness-file-dir function-bounds-file</em></dt>
<dd><p>Create asm-super-mutant from .asm file at asm-path. Load i/o file
from &lt;io/dir&gt;/func-name. Run fitness tests on specified function,
and return optimal variant and fitness result.
<code>mutants-generator</code> should be a function which takes a fully set up
<code>asm-super-mutant</code> instance, and returns a sequence of <code>asm-heap</code> instances
representing the <code>mutants</code> (variants) of the target function.
</p></dd></dl>
<a name="Function-diff_002dfeature_002dvectors"></a><dl>
<dt><a name="index-diff_002dfeature_002dvectors"></a>Function: <strong>diff-feature-vectors</strong> <em>vec1 vec2</em></dt>
<dd><p>Return a vector of the absolute differences between items in VEC1 and VEC2.
</p></dd></dl>
<a name="Generic_002dFunction-elf"></a><dl>
<dt><a name="index-elf"></a>Generic Function: <strong>elf</strong> <em>elf</em></dt>
<dd><p>Return the <code>elf:elf</code> object associated with <code>elf</code>.
This takes the &lsquo;base&rsquo; of <code>elf</code> (which should not be changed), copies it,
and applies the changed data in &lsquo;genome&rsquo; of <code>elf</code>.
</p></dd></dl>
<a name="Method-elf-_0028_0028elf-elf_002drisc_0029_0029"></a><dl>
<dt><a name="index-elf-1"></a>Method: <strong>elf</strong> <em>(elf elf-risc)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-elf-_0028_0028elf-elf_002dcisc_0029_0029"></a><dl>
<dt><a name="index-elf-2"></a>Method: <strong>elf</strong> <em>(elf elf-cisc)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Class-elf"></a><dl>
<dt><a name="index-elf-3"></a>Class: <strong>elf</strong></dt>
<dd><p>Class precedence list: <code>elf, simple, software, standard-object, t</code>
</p>
<p><code>docfixme</code>
</p></dd></dl>
<a name="Function-error_002dfuncs"></a><dl>
<dt><a name="index-error_002dfuncs"></a>Function: <strong>error-funcs</strong> <em>software bad-traces good-traces</em></dt>
<dd><p>Find statements which call error functions.
</p>
<p>Error functions are defined as functions which are only called during
bad runs. Such functions often contain error-handling code which is
not itself faulty, so it&rsquo;s useful to identify their callers instead.
</p></dd></dl>
<a name="Function-expression_002dintern"></a><dl>
<dt><a name="index-expression_002dintern"></a>Function: <strong>expression-intern</strong> <em>string</em></dt>
<dd><p>Intern <code>string</code> for symbolic use in an expression.
This is used to intern string names by &lsquo;expression&rsquo;.
</p></dd></dl>
<a name="Function-expression_002dto_002dc"></a><dl>
<dt><a name="index-expression_002dto_002dc"></a>Function: <strong>expression-to-c</strong> <em>expression</em></dt>
<dd><p>Format <code>expression</code> as C source code.
* <code>expression</code> an expression tree
</p></dd></dl>
<a name="Function-find_002dbest_002dcondition"></a><dl>
<dt><a name="index-find_002dbest_002dcondition"></a>Function: <strong>find-best-condition</strong> <em>recorded-results envs conditions</em></dt>
<dd><p>Return the condition which correctly matches the largest number of recorded
results when evaluated under the corresponding environment.
* <code>recorded-results</code> list of strings &quot;0&quot; or &quot;1&quot; indicating values of abstract
conditions.
* <code>envs</code> list of environments, which are a list of assignment triples
(&quot;var&quot; &quot;type&quot; &quot;value&quot;)
* <code>conditions</code> a 4-tuple ([:eq|:neq] &quot;var&quot; &quot;type&quot; &quot;val&quot;) representing a
condition (var <code>==</code> val) or !(var <code>==</code> val)
</p></dd></dl>
<a name="Generic_002dFunction-find_002dsnippets"></a><dl>
<dt><a name="index-find_002dsnippets"></a>Generic Function: <strong>find-snippets</strong> <em>database &amp;key ast-class full-stmt decls limit</em></dt>
<dd><p>Find snippets in the fodder database <code>database</code>.
</p>
<ul>
<li> <code>ast-class</code>   AST class all snippets should match
</li><li> <code>full-stmt</code>   Limit results to full statements if non-nil.
</li><li> <code>decls</code>       Include decls in result if non-nil.
              Limit results to decls if the keyword <code>:only</code>.
</li><li> <code>limit</code>       Limit to <code>n</code> randomly drawn snippets
</li></ul>
</dd></dl>
<a name="Method-find_002dsnippets-_0028_0028obj-pliny_002ddatabase_0029-_0026key-ast_002dclass-full_002dstmt-decls-_0028limit-_0028_002d-_0028expt-2-32_0029-1_0029_0029_0029"></a><dl>
<dt><a name="index-find_002dsnippets-1"></a>Method: <strong>find-snippets</strong> <em>(obj pliny-database) &amp;key ast-class full-stmt decls (limit (- (expt 2 32) 1))</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>ast-class</code> <code>docfixme</code>
</li><li> <code>full-stmt</code> <code>docfixme</code>
</li><li> <code>decls</code> <code>docfixme</code>
</li><li> <code>limit</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-find_002dsnippets-_0028_0028db-in_002dmemory_002ddatabase_0029-_0026key-ast_002dclass-full_002dstmt-decls-limit_0029"></a><dl>
<dt><a name="index-find_002dsnippets-2"></a>Method: <strong>find-snippets</strong> <em>(db in-memory-database) &amp;key ast-class full-stmt decls limit</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>db</code> <code>docfixme</code>
</li><li> <code>ast-class</code> <code>docfixme</code>
</li><li> <code>full-stmt</code> <code>docfixme</code>
</li><li> <code>decls</code> <code>docfixme</code>
</li><li> <code>limit</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-find_002dtype"></a><dl>
<dt><a name="index-find_002dtype"></a>Generic Function: <strong>find-type</strong> <em>database hash</em></dt>
<dd><p>Find the type in the database
matching the parameter <code>hash</code>
</p></dd></dl>
<a name="Method-find_002dtype-_0028_0028obj-pliny_002ddatabase_0029-hash_0029"></a><dl>
<dt><a name="index-find_002dtype-1"></a>Method: <strong>find-type</strong> <em>(obj pliny-database) hash</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>hash</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-find_002dtype-_0028_0028db-in_002dmemory_002ddatabase_0029-hash_0029"></a><dl>
<dt><a name="index-find_002dtype-2"></a>Method: <strong>find-type</strong> <em>(db in-memory-database) hash</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>db</code>  <code>docfixme</code>
</li><li> <code>hash</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-find_002dtype-_0028_0028obj-clang_0029-hash_0029"></a><dl>
<dt><a name="index-find_002dtype-3"></a>Method: <strong>find-type</strong> <em>(obj clang) hash</em></dt>
<dd><p>Return the type in <code>obj</code> with the given type <code>hash</code>.
</p><ul>
<li> <code>obj</code> clang object to search for <code>hash</code>
</li><li> <code>hash</code> type hash to search for
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-finish_002dtest"></a><dl>
<dt><a name="index-finish_002dtest"></a>Generic Function: <strong>finish-test</strong> <em>test-process</em></dt>
<dd><p>Ensure that <code>test-process</code> either runs to completion or is killed.
Return the standard output, error output, and process exit code as strings.
</p>
<p>* <code>test-process</code> the &lsquo;process&rsquo; associated with the test case.
</p></dd></dl>
<a name="Method-finish_002dtest-_0028_0028test_002dprocess-process_0029_0029"></a><dl>
<dt><a name="index-finish_002dtest-1"></a>Method: <strong>finish-test</strong> <em>(test-process process)</em></dt>
<dd><p>Ensure that <code>test-process</code> either runs to completion or is killed.
Return the standard output, error output, and process exit code as strings.
</p>
<p>* <code>test-process</code> the &lsquo;process&rsquo; associated with the test case.
</p>
<p>See also &lsquo;*process-sleep-interval*&rsquo; and &lsquo;*process-kill-timeout*&rsquo;. If
<code>test-process</code> is still running when &lsquo;finish-test&rsquo; is called, alternate between
sleeping for &lsquo;*process-sleep-interval*&rsquo; seconds and checking again until either
&lsquo;*process-kill-timeout*&rsquo; seconds have elapsed or the process completes. After
the timeout, send a <code>sigterm</code> signal if <code>test-process</code> is still running, sleep for
&lsquo;*process-sleep-interval*&rsquo; seconds once more and then if the process is still
running, send a <code>sigkill</code> signal.
</p></dd></dl>
<a name="Function-fitness_002dbetter_002dp"></a><dl>
<dt><a name="index-fitness_002dbetter_002dp"></a>Function: <strong>fitness-better-p</strong> <em>fitness-a fitness-b</em></dt>
<dd><p>Check if <code>fitness-a</code> is strictly better than <code>fitness-b</code>.
</p></dd></dl>
<a name="Generic_002dFunction-force_002dinclude"></a><dl>
<dt><a name="index-force_002dinclude"></a>Generic Function: <strong>force-include</strong> <em>software include</em></dt>
<dd><p>Add an #include directive for an <code>include</code> to <code>software</code>
even if such an <code>include</code> already exists in <code>software</code>.
</p></dd></dl>
<a name="Method-force_002dinclude-_0028_0028obj-clang_0029-include_0029"></a><dl>
<dt><a name="index-force_002dinclude-1"></a>Method: <strong>force-include</strong> <em>(obj clang) include</em></dt>
<dd><p>Add an #include directive for an <code>include</code> to <code>obj</code>
even if such an <code>include</code> already exists in <code>obj</code>.
</p><ul>
<li> <code>obj</code> object to modify
</li><li> <code>include</code> header to include in <code>obj</code>
</li></ul>
</dd></dl>
<a name="Method-force_002dinclude-_0028_0028obj-java_0029-include_0029"></a><dl>
<dt><a name="index-force_002dinclude-2"></a>Method: <strong>force-include</strong> <em>(obj java) include</em></dt>
<dd><p>Add an import directive for an <code>include</code> to <code>obj</code> after the package declaration.
</p></dd></dl>
<a name="Generic_002dFunction-from_002dfile"></a><dl>
<dt><a name="index-from_002dfile"></a>Generic Function: <strong>from-file</strong> <em>software file</em></dt>
<dd><p>Initialize <code>software</code> with contents of <code>file</code>.
</p></dd></dl>
<a name="Method-from_002dfile-_0028_0028obj-pliny_002ddatabase_0029-db_0029"></a><dl>
<dt><a name="index-from_002dfile-1"></a>Method: <strong>from-file</strong> <em>(obj pliny-database) db</em></dt>
<dd><p>Create a Pliny database using the contents of <code>db</code>
</p></dd></dl>
<a name="Method-from_002dfile-_0028_0028obj-coq_0029-file_0029"></a><dl>
<dt><a name="index-from_002dfile-2"></a>Method: <strong>from-file</strong> <em>(obj coq) file</em></dt>
<dd><p>Load Coq <code>obj</code> from file <code>file</code>, initializing fields in <code>obj</code>.
Resets the SerAPI process so that imports are loaded but no definitions from the
file have been added.
</p></dd></dl>
<a name="Method-from_002dfile-before-_0028_0028obj-ancestral_0029-path_0029"></a><dl>
<dt><a name="index-before-from_002dfile"></a>Method: <strong>before from-file</strong> <em>(obj ancestral) path</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>path</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-from_002dfile-_0028_0028obj-java_002dproject_0029-project_002ddir_0029"></a><dl>
<dt><a name="index-from_002dfile-3"></a>Method: <strong>from-file</strong> <em>(obj java-project) project-dir</em></dt>
<dd><p>Build project and extract relevant java source files.
</p></dd></dl>
<a name="Method-from_002dfile-_0028_0028clang_002dproject-clang_002dproject_0029-project_002ddir_0029"></a><dl>
<dt><a name="index-from_002dfile-4"></a>Method: <strong>from-file</strong> <em>(clang-project clang-project) project-dir</em></dt>
<dd><p>Populate <code>clang-project</code> from the source code in <code>project-dir</code>.
</p><ul>
<li> <code>clang-project</code> to be populated from source in <code>project-dir</code>
</li><li> <code>project-dir</code> source code to populate <code>clang-project</code> with
</li></ul>
</dd></dl>
<a name="Method-from_002dfile-_0028_0028llvm-llvm_0029-path_0029"></a><dl>
<dt><a name="index-from_002dfile-5"></a>Method: <strong>from-file</strong> <em>(llvm llvm) path</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>llvm</code> <code>docfixme</code>
</li><li> <code>path</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-from_002dfile-_0028_0028forth-forth_0029-path-_0026aux-strings_0029"></a><dl>
<dt><a name="index-from_002dfile-6"></a>Method: <strong>from-file</strong> <em>(forth forth) path &amp;aux strings</em></dt>
<dd><p>Read forth script from <code>path</code> setting &lsquo;genome&rsquo; and &lsquo;shebang&rsquo;.
</p></dd></dl>
<a name="Method-from_002dfile-_0028_0028obj-clang_0029-path_0029"></a><dl>
<dt><a name="index-from_002dfile-7"></a>Method: <strong>from-file</strong> <em>(obj clang) path</em></dt>
<dd><p>Populate <code>obj</code> with the source code file at <code>path</code>
</p><ul>
<li> <code>obj</code> to be populated from source code at <code>path</code>
</li><li> <code>path</code> source code to populate <code>obj</code> with
</li></ul>
</dd></dl>
<a name="Method-from_002dfile-_0028_0028obj-java_0029-path_0029"></a><dl>
<dt><a name="index-from_002dfile-8"></a>Method: <strong>from-file</strong> <em>(obj java) path</em></dt>
<dd><p>Populate software object upon initialization
</p></dd></dl>
<a name="Method-from_002dfile-_0028_0028obj-source_0029-path_0029"></a><dl>
<dt><a name="index-from_002dfile-9"></a>Method: <strong>from-file</strong> <em>(obj source) path</em></dt>
<dd><p>Initialize <code>obj</code> with the contents of <code>path</code>
</p></dd></dl>
<a name="Method-from_002dfile-_0028_0028elf-elf_002drisc_0029-path_0029"></a><dl>
<dt><a name="index-from_002dfile-10"></a>Method: <strong>from-file</strong> <em>(elf elf-risc) path</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-from_002dfile-_0028_0028elf-elf_002dcsurf_0029-path_0029"></a><dl>
<dt><a name="index-from_002dfile-11"></a>Method: <strong>from-file</strong> <em>(elf elf-csurf) path</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-from_002dfile-_0028_0028elf-elf_002dcisc_0029-path_0029"></a><dl>
<dt><a name="index-from_002dfile-12"></a>Method: <strong>from-file</strong> <em>(elf elf-cisc) path</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-from_002dfile-_0028_0028elf-elf_0029-path_0029"></a><dl>
<dt><a name="index-from_002dfile-13"></a>Method: <strong>from-file</strong> <em>(elf elf) path</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-from_002dfile-_0028_0028asm-asm_002dheap_0029-file_0029"></a><dl>
<dt><a name="index-from_002dfile-14"></a>Method: <strong>from-file</strong> <em>(asm asm-heap) file</em></dt>
<dd><p>Initialize an &lsquo;asm-heap&rsquo; software object from a file.
</p></dd></dl>
<a name="Method-from_002dfile-_0028_0028asm-asm_002drange_0029-file_0029"></a><dl>
<dt><a name="index-from_002dfile-15"></a>Method: <strong>from-file</strong> <em>(asm asm-range) file</em></dt>
<dd><p>Initialize an &lsquo;asm-range&rsquo; software object from a file.
Note this is required as no &lsquo;from-file&rsquo; method is defined on the
&lsquo;range&rsquo; software object class.
</p></dd></dl>
<a name="Method-from_002dfile-_0028_0028lisp-lisp_0029-file_0029"></a><dl>
<dt><a name="index-from_002dfile-16"></a>Method: <strong>from-file</strong> <em>(lisp lisp) file</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>lisp</code> <code>docfixme</code>
</li><li> <code>file</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-from_002dfile-_0028_0028range-sw_002drange_0029-path_0029"></a><dl>
<dt><a name="index-from_002dfile-17"></a>Method: <strong>from-file</strong> <em>(range sw-range) path</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-from_002dfile-_0028_0028light-light_0029-path_0029"></a><dl>
<dt><a name="index-from_002dfile-18"></a>Method: <strong>from-file</strong> <em>(light light) path</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-from_002dfile-_0028_0028simple-simple_0029-_0028paths-list_0029_0029"></a><dl>
<dt><a name="index-from_002dfile-19"></a>Method: <strong>from-file</strong> <em>(simple simple) (paths list)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-from_002dfile-_0028_0028simple-simple_0029-path_0029"></a><dl>
<dt><a name="index-from_002dfile-20"></a>Method: <strong>from-file</strong> <em>(simple simple) path</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Function-full_002dstmt_002dfilter"></a><dl>
<dt><a name="index-full_002dstmt_002dfilter"></a>Function: <strong>full-stmt-filter</strong> <em>ast &amp;optional first-pick</em></dt>
<dd><p>Targeting filter returning true if AST is a full statement.
</p><ul>
<li> AST possible second targeting function pick
</li><li> <code>first-pick</code> first targeting function pick
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-full_002dstmt_002dp"></a><dl>
<dt><a name="index-full_002dstmt_002dp"></a>Generic Function: <strong>full-stmt-p</strong> <em>software statement</em></dt>
<dd><p>Check if <code>statement</code> is a full statement in <code>software</code>.
</p></dd></dl>
<a name="Method-full_002dstmt_002dp-_0028_0028obj-clang_0029-_0028stmt-clang_002dast_0029_0029"></a><dl>
<dt><a name="index-full_002dstmt_002dp-1"></a>Method: <strong>full-stmt-p</strong> <em>(obj clang) (stmt clang-ast)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>stmt</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-function_002dcontaining_002dast"></a><dl>
<dt><a name="index-function_002dcontaining_002dast"></a>Generic Function: <strong>function-containing-ast</strong> <em>object ast</em></dt>
<dd><p>Return the ast for the function containing AST in <code>object</code>.
</p></dd></dl>
<a name="Method-function_002dcontaining_002dast-_0028_0028clang-clang_0029-_0028ast-clang_002dast_0029_0029"></a><dl>
<dt><a name="index-function_002dcontaining_002dast-1"></a>Method: <strong>function-containing-ast</strong> <em>(clang clang) (ast clang-ast)</em></dt>
<dd><p>Return the function in <code>clang</code> containing AST.
</p><ul>
<li> <code>clang</code> software object containing AST and its parent function
</li><li> AST ast to search for the parent function of
</li></ul>
</dd></dl>
<a name="Function-function_002ddecl_002dp"></a><dl>
<dt><a name="index-function_002ddecl_002dp"></a>Function: <strong>function-decl-p</strong> <em>ast</em></dt>
<dd><p>Is AST a function (or method/constructor/destructor) decl?
</p></dd></dl>
<a name="Function-generational_002devolve"></a><dl>
<dt><a name="index-generational_002devolve"></a>Function: <strong>generational-evolve</strong> <em>reproduce evaluate-pop select &amp;key every-pre-fn every-post-fn analyze-mutation-fn test period period-fn max-generations max-evals max-time filter</em></dt>
<dd><p>Evolves &lsquo;*population*&rsquo; using <code>reproduce</code> <code>evaluate-pop</code> and <code>select</code>.
</p>
<p>Required arguments are as follows:
  <code>reproduce</code> <code>-----------</code> create new individuals from the current population
  <code>evaluate-pop</code> <code>--------</code> evaluate-pop the entire population
  <code>select</code> <code>--------------</code> select best individuals from the population
Keyword arguments are as follows:
  <code>max-generations</code> <code>-----</code> stop after this many generations
  <code>max-evals</code> <code>-----------</code> stop after this many fitness evaluations
  <code>max-time</code> <code>------------</code> stop after this many seconds
  <code>period</code> <code>--------------</code> interval of generations evaluations to run <code>period-fn</code>
  <code>period-fn</code> <code>-----------</code> function to run every <code>period</code> generations
  <code>every-pre-fn</code> <code>--------</code> function to run on each new individual before evaluation
  <code>every-post-fn</code> <code>-------</code> function to run on each new individual after evaluation
  <code>analyze-mutation-fn</code> <code>-</code> function to call to analyze mutation results
  <code>test</code> <code>----------------</code> fitness test function for mutation statistics
  <code>filter</code> <code>--------------</code> remove individuals for which <code>filter</code> returns false
</p></dd></dl>
<a name="Generic_002dFunction-genome"></a><dl>
<dt><a name="index-genome"></a>Generic Function: <strong>genome</strong> <em>software</em></dt>
<dd><p>The software genotype or &ldquo;code&rdquo;, exposed as a simplified data structure.
For example an AST genome, e.g., of a &lsquo;cil&rsquo; or &lsquo;lisp&rsquo; software object
my have a tree structure while the genome of an &lsquo;asm&rsquo; or &lsquo;llvm&rsquo;
software object will be a vector.
</p></dd></dl>
<a name="Method-genome-_0028_0028obj-super_002dmutant_0029_0029"></a><dl>
<dt><a name="index-genome-1"></a>Method: <strong>genome</strong> <em>(obj super-mutant)</em></dt>
<dd><p>Return a genome which combines all variants in <code>super-mutant</code>.
</p></dd></dl>
<a name="Method-genome-_0028_0028obj-project_0029_0029"></a><dl>
<dt><a name="index-genome-2"></a>Method: <strong>genome</strong> <em>(obj project)</em></dt>
<dd><p>Returns all genomes joined with separators.
</p></dd></dl>
<a name="Method-genome-_0028_0028obj-parseable_0029_0029"></a><dl>
<dt><a name="index-genome-3"></a>Method: <strong>genome</strong> <em>(obj parseable)</em></dt>
<dd><p>Return the source code in <code>obj</code>.
</p></dd></dl>
<a name="Method-genome-_0028_0028source-source_0029_0029"></a><dl>
<dt><a name="index-genome-4"></a>Method: <strong>genome</strong> <em>(source source)</em></dt>
<dd><p>automatically generated reader method
</p></dd></dl>
<a name="Method-genome-_0028_0028diff-diff_0029_0029"></a><dl>
<dt><a name="index-genome-5"></a>Method: <strong>genome</strong> <em>(diff diff)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-genome-_0028_0028lisp-lisp_0029_0029"></a><dl>
<dt><a name="index-genome-6"></a>Method: <strong>genome</strong> <em>(lisp lisp)</em></dt>
<dd><p>automatically generated reader method
</p></dd></dl>
<a name="Method-genome-_0028_0028simple-simple_0029_0029"></a><dl>
<dt><a name="index-genome-7"></a>Method: <strong>genome</strong> <em>(simple simple)</em></dt>
<dd><p>automatically generated reader method
</p></dd></dl>
<a name="Generic_002dFunction-genome_002dbytes"></a><dl>
<dt><a name="index-genome_002dbytes"></a>Generic Function: <strong>genome-bytes</strong> <em>elf</em></dt>
<dd><p>Return the bytes of the ELF&rsquo;s genome.
The result should be a simple array of type &rsquo;(UNSIGNED-BYTE 8).
</p></dd></dl>
<a name="Method-genome_002dbytes-_0028_0028elf-elf_0029_0029"></a><dl>
<dt><a name="index-genome_002dbytes-1"></a>Method: <strong>genome-bytes</strong> <em>(elf elf)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Generic_002dFunction-get_002dparent_002dast"></a><dl>
<dt><a name="index-get_002dparent_002dast"></a>Generic Function: <strong>get-parent-ast</strong> <em>obj ast</em></dt>
<dd><p>Return the parent node of AST in <code>obj</code>
</p></dd></dl>
<a name="Method-get_002dparent_002dast-_0028_0028obj-parseable_0029-_0028ast-ast_0029_0029"></a><dl>
<dt><a name="index-get_002dparent_002dast-1"></a>Method: <strong>get-parent-ast</strong> <em>(obj parseable) (ast ast)</em></dt>
<dd><p>Return the parent node of AST in <code>obj</code>
</p><ul>
<li> <code>obj</code> software object containing AST and its parent
</li><li> AST node to find the parent of
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-get_002dparent_002dasts"></a><dl>
<dt><a name="index-get_002dparent_002dasts"></a>Generic Function: <strong>get-parent-asts</strong> <em>obj ast</em></dt>
<dd><p>Return the parent nodes of AST in <code>obj</code>
</p></dd></dl>
<a name="Method-get_002dparent_002dasts-_0028_0028obj-parseable_0029-_0028ast-ast_0029_0029"></a><dl>
<dt><a name="index-get_002dparent_002dasts-1"></a>Method: <strong>get-parent-asts</strong> <em>(obj parseable) (ast ast)</em></dt>
<dd><p>Return the parent nodes of AST in <code>obj</code>
</p><ul>
<li> <code>obj</code> software object containing AST and its parents
</li><li> AST node to find the parents of
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-get_002dvars_002din_002dscope"></a><dl>
<dt><a name="index-get_002dvars_002din_002dscope"></a>Generic Function: <strong>get-vars-in-scope</strong> <em>software ast &amp;optional keep-globals</em></dt>
<dd><p>Return all variables in enclosing scopes.
</p></dd></dl>
<a name="Method-get_002dvars_002din_002dscope-_0028_0028obj-clang_0029-_0028ast-clang_002dast_0029-_0026optional-_0028keep_002dglobals-t_0029_0029"></a><dl>
<dt><a name="index-get_002dvars_002din_002dscope-1"></a>Method: <strong>get-vars-in-scope</strong> <em>(obj clang) (ast clang-ast) &amp;optional (keep-globals t)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> AST <code>docfixme</code>
</li><li> <code>keep-globals</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-good_002dstmts"></a><dl>
<dt><a name="index-good_002dstmts"></a>Generic Function: <strong>good-stmts</strong> <em>software</em></dt>
<dd><p>Return a list of all good statement asts in <code>software</code>.
</p></dd></dl>
<a name="Method-good_002dstmts-_0028_0028obj-coq_0029_0029"></a><dl>
<dt><a name="index-good_002dstmts-1"></a>Method: <strong>good-stmts</strong> <em>(obj coq)</em></dt>
<dd><p>Return a list of the indices of good statements in <code>obj</code>.
</p></dd></dl>
<a name="Method-good_002dstmts-_0028_0028clang-clang_0029_0029"></a><dl>
<dt><a name="index-good_002dstmts-2"></a>Method: <strong>good-stmts</strong> <em>(clang clang)</em></dt>
<dd><p>Return a list of all good statement ASTs in <code>clang</code>.
</p></dd></dl>
<a name="Class-insert_002delse_002dif"></a><dl>
<dt><a name="index-insert_002delse_002dif"></a>Class: <strong>insert-else-if</strong></dt>
<dd><p>Class precedence list: <code>insert-else-if, tighten-condition, refine-condition, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>insert an (empty) else-if clause after an existing if, e.g., if(foo) bar; becomes if(foo) bar; else if(abst_cond()) ;.
</p></dd></dl>
<a name="Generic_002dFunction-instrument"></a><dl>
<dt><a name="index-instrument"></a>Generic Function: <strong>instrument</strong> <em>obj &amp;key points functions functions-after trace-file trace-env instrument-exit filter num-threads</em></dt>
<dd><p>Instrument <code>obj</code> to print AST index before each full statement.
</p>
<p>The indices printed here are not clang-mutate counters, but rather the
position of the ast in (asts obj).
</p>
<p>Keyword arguments are as follows:
  <code>points</code> <code>---------------</code> alist of additional values to print at specific points
  <code>functions</code> <code>------------</code> functions to calculate instrumentation at each point
  <code>functions-after</code> <code>------</code> functions to calculate instrumentation after each point
  <code>trace-file</code> <code>-----------</code> file for trace output
  <code>trace-env</code> <code>------------</code> trace output to file specified by <code>env</code> variable
  <code>instrument-exit</code> <code>------</code> print counter of function body before exit
  <code>filter</code> <code>---------------</code> function to select a subset of ASTs for instrumentation
  <code>num-threads</code> <code>----------</code> number of threads to use for instrumentation
</p></dd></dl>
<a name="Method-instrument-_0028_0028clang_002dproject-clang_002dproject_0029-_0026rest-args-_0026aux-_0028names-_0028make_002dthread_002dsafe_002dhash_002dtable-test-_0023_0027equalp_0029_0029--_0028types-_0028make_002dthread_002dsafe_002dhash_002dtable-test-_0023_0027equalp_0029_0029-_0028type_002ddescriptions-_0028make_002dthread_002dsafe_002dhash_002dtable-test-_0023_0027equalp_0029_0029_0029"></a><dl>
<dt><a name="index-instrument-1"></a>Method: <strong>instrument</strong> <em>(clang-project clang-project) &amp;rest args &amp;aux (names (make-thread-safe-hash-table test (function equalp))) (types (make-thread-safe-hash-table test (function equalp))) (type-descriptions (make-thread-safe-hash-table test (function equalp)))</em></dt>
<dd><p>Instrument <code>clang-project</code> to print AST index before each full statement.
</p>
<ul>
<li> <code>clang-project</code> the project to instrument
</li><li> <code>args</code> passed through to the instrument method on underlying software objects.
</li></ul>
</dd></dl>
<a name="Method-instrument-_0028_0028instrumenter-clang_002dinstrumenter_0029-_0026key-points-functions-functions_002dafter-trace_002dfile-trace_002denv-instrument_002dexit-_0028filter-_0028constantly-t_0029_0029--_0028num_002dthreads-1_0029_0029"></a><dl>
<dt><a name="index-instrument-2"></a>Method: <strong>instrument</strong> <em>(instrumenter clang-instrumenter) &amp;key points functions functions-after trace-file trace-env instrument-exit (filter (constantly t)) (num-threads 1)</em></dt>
<dd><p>Use <code>instrumenter</code> to instrument a clang software object.
</p>
<ul>
<li> <code>instrumenter</code> current instrumentation state
</li><li> <code>points</code> alist of additional values to print at specific points
</li><li> <code>functions</code>  functions to calculate instrumentation at each point
</li><li> <code>functions-after</code> functions to calculate instrumentation after each point
</li><li> <code>trace-file</code> file or stream (stdout/stderr) for trace output
</li><li> <code>trace-env</code> trace output to file specified by <code>env</code> variable
</li><li> <code>instrument-exit</code> print counter of function body before exit
</li><li> <code>filter</code> function to select a subset of ASTs for instrumentation
         function should take a software object and an AST parameters,
         returning nil if the AST should be filtered from instrumentation
</li><li> <code>num-threads</code> number of threads to use for instrumentation
</li></ul>
</dd></dl>
<a name="Method-instrument-_0028_0028obj-clang_0029-_0026rest-args_0029"></a><dl>
<dt><a name="index-instrument-3"></a>Method: <strong>instrument</strong> <em>(obj clang) &amp;rest args</em></dt>
<dd><p>Instrumentation for clang software objects.
Creates a <code>clang-instrumenter</code> for <code>obj</code> and calls its instrument method.
</p>
<ul>
<li> <code>obj</code> the software object to instrument
</li><li> <code>args</code> additional arguments are passed through to the instrumenter method.
</li></ul>
</dd></dl>
<a name="Method-instrument-_0028_0028cil-cil_0029-_0026key-points-functions-functions_002dafter-trace_002dfile-trace_002denv-instrument_002dexit-filter-num_002dthreads_0029"></a><dl>
<dt><a name="index-instrument-4"></a>Method: <strong>instrument</strong> <em>(cil cil) &amp;key points functions functions-after trace-file trace-env instrument-exit filter num-threads</em></dt>
<dd><p>Instrument <code>cil</code> for traced execution.
Optionally specify the name of the file in which to save trace data.
</p></dd></dl>
<a name="Generic_002dFunction-instrumentation_002dfiles"></a><dl>
<dt><a name="index-instrumentation_002dfiles"></a>Generic Function: <strong>instrumentation-files</strong> <em>project</em></dt>
<dd><p>Return files in <code>project</code> in the order which they would be instrumented
</p></dd></dl>
<a name="Method-instrumentation_002dfiles-_0028_0028clang_002dproject-clang_002dproject_0029_0029"></a><dl>
<dt><a name="index-instrumentation_002dfiles-1"></a>Method: <strong>instrumentation-files</strong> <em>(clang-project clang-project)</em></dt>
<dd><p>Return files in <code>clang-project</code> in the order which they would be instrumented
* <code>clang-project</code> an instrumented project
</p></dd></dl>
<a name="Class-java"></a><dl>
<dt><a name="index-java"></a>Class: <strong>java</strong></dt>
<dd><p>Class precedence list: <code>java, source, software, standard-object, t</code>
</p>
<p>The java software object represents a single java file.
</p></dd></dl>
<a name="Class-java_002dtraceable_002dproject"></a><dl>
<dt><a name="index-java_002dtraceable_002dproject"></a>Class: <strong>java-traceable-project</strong></dt>
<dd><p>Class precedence list: <code>java-traceable-project, java-project, project, traceable, software, standard-object, t</code>
</p>
<p>Specialization of the traceable interface for java
project software objects.
</p></dd></dl>
<a name="Class-json_002ddatabase"></a><dl>
<dt><a name="index-json_002ddatabase"></a>Class: <strong>json-database</strong></dt>
<dd><p>Class precedence list: <code>json-database, in-memory-database, fodder-database, searchable, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>json-stream</code> &mdash; initarg: <code><span class="nolinebreak">:json-stream</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library::json-stream</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library::json-stream)</span><!-- /@w --></code>

<p>Stream of incoming <code>json</code>.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-lisp_002dreplace"></a><dl>
<dt><a name="index-lisp_002dreplace"></a>Class: <strong>lisp-replace</strong></dt>
<dd><p>Class precedence list: <code>lisp-replace, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p><code>docfixme</code>
</p></dd></dl>
<a name="Variable-_002abetter_002dbias_002a"></a><dl>
<dt><a name="index-_002abetter_002dbias_002a"></a>Variable: <strong>*better-bias*</strong></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Variable-_002amax_002dpopulation_002dsize_002a"></a><dl>
<dt><a name="index-_002amax_002dpopulation_002dsize_002a"></a>Variable: <strong>*max-population-size*</strong></dt>
<dd><p>Maximum allowable population size.
</p></dd></dl>
<a name="Variable-_002amutation_002dstats_002a"></a><dl>
<dt><a name="index-_002amutation_002dstats_002a"></a>Variable: <strong>*mutation-stats*</strong></dt>
<dd><p>Variable to hold mutation statistics.
</p></dd></dl>
<a name="Variable-ast_002dfull_002dstmt_002dbi_002dgrams_002dfeature"></a><dl>
<dt><a name="index-ast_002dfull_002dstmt_002dbi_002dgrams_002dfeature"></a>Variable: <strong>ast-full-stmt-bi-grams-feature</strong></dt>
<dd><p>Number of occurrences of AST node type bi-grams in each full statement in
an AST.
</p></dd></dl>
<a name="Generic_002dFunction-avg_002ddepth_002dast_002dextractor"></a><dl>
<dt><a name="index-avg_002ddepth_002dast_002dextractor"></a>Generic Function: <strong>avg-depth-ast-extractor</strong> <em>software</em></dt>
<dd><p>Return 1-element feature vector of the average depth of ASTs in <code>software</code>.
</p></dd></dl>
<a name="Generic_002dFunction-build_002dop"></a><dl>
<dt><a name="index-build_002dop"></a>Generic Function: <strong>build-op</strong> <em>software mutation</em></dt>
<dd><p>Build operation on <code>software</code> from a <code>mutation</code>.
</p></dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-insert_002delse_002dif_0029-software_0029"></a><dl>
<dt><a name="index-build_002dop-1"></a>Method: <strong>build-op</strong> <em>(mutation insert-else-if) software</em></dt>
<dd><p>Return an association list with the operations to apply
an insert-else-if <code>mutation</code> to <code>software</code>.
</p></dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-if_002dto_002dwhile_0029-software_0029"></a><dl>
<dt><a name="index-build_002dop-2"></a>Method: <strong>build-op</strong> <em>(mutation if-to-while) software</em></dt>
<dd><p>Return an association list with the operations to apply
an if-to-while <code>mutation</code> to <code>software</code>
</p></dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-if_002dto_002dwhile_002dtighten_002dcondition_0029-software_0029"></a><dl>
<dt><a name="index-build_002dop-3"></a>Method: <strong>build-op</strong> <em>(mutation if-to-while-tighten-condition) software</em></dt>
<dd><p>Return an association list with the operations to apply
an if-to-while-tighten-condition <code>mutation</code> to <code>software</code>.
</p></dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-add_002dcondition_0029-software_0029"></a><dl>
<dt><a name="index-build_002dop-4"></a>Method: <strong>build-op</strong> <em>(mutation add-condition) software</em></dt>
<dd><p>Return an association list with the operations to apply
a add-condition <code>mutation</code> to <code>software</code>.
</p></dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-refine_002dcondition_0029-software_0029"></a><dl>
<dt><a name="index-build_002dop-5"></a>Method: <strong>build-op</strong> <em>(mutation refine-condition) software</em></dt>
<dd><p>Return an association list with the operations to apply
a refine-condition <code>mutation</code> to <code>software</code>.
</p></dd></dl>
<a name="Method-build_002dop-_0028_0028mut-insert_002dfodder_002ddecl_002drep_0029-_0028obj-clang_002dw_002dfodder_0029_0029"></a><dl>
<dt><a name="index-build_002dop-6"></a>Method: <strong>build-op</strong> <em>(mut insert-fodder-decl-rep) (obj clang-w-fodder)</em></dt>
<dd><p>Return an association list with the operations to apply a
&lsquo;insert-fodder-decl-rep&rsquo; <code>mut</code> to <code>obj</code>.
</p><ul>
<li> <code>mut</code> defines the targets of the insertion operation
</li><li> <code>obj</code> object to be modified by the mutation
</li></ul>
</dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-rename_002dvariable_0029-software_0029"></a><dl>
<dt><a name="index-build_002dop-7"></a>Method: <strong>build-op</strong> <em>(mutation rename-variable) software</em></dt>
<dd><p>Return an association list with the operations to apply a &lsquo;rename-variable&rsquo;
<code>mutation</code> to <code>software</code>.
</p><ul>
<li> <code>mutation</code> defines the targets of the rename-variable operation
</li><li> <code>software</code> object to be modified by the mutation
</li></ul>
</dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-cut_002ddecl_0029-clang_0029"></a><dl>
<dt><a name="index-build_002dop-8"></a>Method: <strong>build-op</strong> <em>(mutation cut-decl) clang</em></dt>
<dd><p>Return an association list with the operations to apply a &lsquo;cut-decl&rsquo;
<code>mutation</code> to <code>clang</code>.
</p><ul>
<li> <code>mutation</code> defines the targets of the cut-decl operation
</li><li> <code>clang</code> object to be modified by the mutation
</li></ul>
</dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-coalesce_002dwhile_002dloop_0029-_0028obj-clang_0029_0029"></a><dl>
<dt><a name="index-build_002dop-9"></a>Method: <strong>build-op</strong> <em>(mutation coalesce-while-loop) (obj clang)</em></dt>
<dd><p>Return an association list with the operations to apply a
&lsquo;coalesce-while-loop&rsquo; <code>mutation</code> to <code>software</code>.
</p><ul>
<li> <code>mutation</code> defines the targets of the coalesce-while-loop operation
</li><li> <code>obj</code> object to be modified by the mutation
</li></ul>
</dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-explode_002dfor_002dloop_0029-_0028obj-clang_0029_0029"></a><dl>
<dt><a name="index-build_002dop-10"></a>Method: <strong>build-op</strong> <em>(mutation explode-for-loop) (obj clang)</em></dt>
<dd><p>Return an association list with the operations to apply an
&lsquo;explode-for-loop&rsquo; <code>mutation</code> to <code>obj</code>.
</p><ul>
<li> <code>mutation</code> defines the targets of the explode-for-loop operation
</li><li> <code>obj</code> object to be modified by the mutation
</li></ul>
</dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-clang_002dpromote_002dguarded_0029-software-_0026aux-_0028guarded-_0028targets-mutation_0029_0029_0029"></a><dl>
<dt><a name="index-build_002dop-11"></a>Method: <strong>build-op</strong> <em>(mutation clang-promote-guarded) software &amp;aux (guarded (targets mutation))</em></dt>
<dd><p>Return an association list with the operations to apply a
&lsquo;clang-promote-guarded&rsquo; <code>mutation</code> to <code>software</code>.
</p><ul>
<li> <code>mutation</code> defines the targets of the cut operation
</li><li> <code>software</code> object to be modified by the mutation
</li></ul>
</dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-clang_002dinsert_0029-software_0029"></a><dl>
<dt><a name="index-build_002dop-12"></a>Method: <strong>build-op</strong> <em>(mutation clang-insert) software</em></dt>
<dd><p>Return an association list with the operations to apply a &lsquo;clang-insert&rsquo;
<code>mutation</code> to <code>software</code>.
</p><ul>
<li> <code>mutation</code> defines targets of insertion operation
</li><li> <code>software</code> object to be modified by the mutation
</li></ul>
</dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-parseable_002dnop_0029-software_0029"></a><dl>
<dt><a name="index-build_002dop-13"></a>Method: <strong>build-op</strong> <em>(mutation parseable-nop) software</em></dt>
<dd><p>Return an association list with the operations to apply a &lsquo;nop&rsquo;
<code>mutation</code> to <code>software</code>.
</p><ul>
<li> <code>muation</code> defines teh targets of the nop operation
</li><li> <code>software</code> object to be modified by the mutation
</li></ul>
</dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-parseable_002dcut_0029-software_0029"></a><dl>
<dt><a name="index-build_002dop-14"></a>Method: <strong>build-op</strong> <em>(mutation parseable-cut) software</em></dt>
<dd><p>Return an association list with the operations to apply a &lsquo;parseable-cut&rsquo;
<code>mutation</code> to <code>software</code>.
</p><ul>
<li> <code>mutation</code> defines the targets of the cut operation
</li><li> <code>software</code> object to be modified by the mutation
</li></ul>
</dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-parseable_002dreplace_0029-software_0029"></a><dl>
<dt><a name="index-build_002dop-15"></a>Method: <strong>build-op</strong> <em>(mutation parseable-replace) software</em></dt>
<dd><p>Return an association list with the operations to apply an
&lsquo;parseable-replace&rsquo; <code>mutation</code> to <code>software</code>.
</p><ul>
<li> <code>mutation</code> defines targets of the replace operation
</li><li> <code>software</code> object to be modified by the mutation
</li></ul>
</dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-parseable_002dmove_0029-software_0029"></a><dl>
<dt><a name="index-build_002dop-16"></a>Method: <strong>build-op</strong> <em>(mutation parseable-move) software</em></dt>
<dd><p>Return an association list with the operations to apply a &lsquo;parseable-move&rsquo;
<code>mutation</code> to <code>software</code>.
</p><ul>
<li> <code>mutation</code> defines targets of the move operation
</li><li> <code>software</code> object to be modified by the mutation
</li></ul>
</dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-parseable_002dswap_0029-software_0029"></a><dl>
<dt><a name="index-build_002dop-17"></a>Method: <strong>build-op</strong> <em>(mutation parseable-swap) software</em></dt>
<dd><p>Return an association list with the operations to apply a &lsquo;parseable-swap&rsquo;
<code>mutation</code> to <code>software</code>.
</p><ul>
<li> <code>mutation</code> defines targets of the swap operation
</li><li> <code>software</code> object to be modified by the mutation
</li></ul>
</dd></dl>
<a name="Method-build_002dop-_0028_0028mutation-parseable_002dinsert_0029-software_0029"></a><dl>
<dt><a name="index-build_002dop-18"></a>Method: <strong>build-op</strong> <em>(mutation parseable-insert) software</em></dt>
<dd><p>Return an association list with the operations to apply a &lsquo;parseable-insert&rsquo;
<code>mutation</code> to <code>software</code>.
</p><ul>
<li> <code>mutation</code> defines targets of insertion operation
</li><li> <code>software</code> object to be modified by the mutation
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-coq_002dtype_002dchecks"></a><dl>
<dt><a name="index-coq_002dtype_002dchecks"></a>Generic Function: <strong>coq-type-checks</strong> <em>coq</em></dt>
<dd><p>Return the fraction of ASTs in <code>coq</code> software object that typecheck.
</p></dd></dl>
<a name="Method-coq_002dtype_002dchecks-_0028_0028obj-coq_0029_0029"></a><dl>
<dt><a name="index-coq_002dtype_002dchecks-1"></a>Method: <strong>coq-type-checks</strong> <em>(obj coq)</em></dt>
<dd><p>Return the fraction of ASTs in Coq software <code>obj</code> that typecheck.
Return <code>nil</code> if source strings cannot be looked up.
</p></dd></dl>
<a name="Macro-define_002dmutation"></a><dl>
<dt><a name="index-define_002dmutation"></a>Macro: <strong>define-mutation</strong> <em>class-name superclasses slots &amp;rest options</em></dt>
<dd><p>Like &lsquo;defclass&rsquo; but inherits <code>targeter</code> slot-options from <code>mutation</code>.
Also, ensures <code>mutation</code> is a member of superclasses
</p></dd></dl>
<a name="Macro-evolve"></a><dl>
<dt><a name="index-evolve"></a>Macro: <strong>evolve</strong> <em>test &amp;key max-evals max-time period period-fn every-pre-fn every-post-fn filter analyze-mutation-fn super-mutant-count</em></dt>
<dd><p>Evolves &lsquo;*population*&rsquo; using &lsquo;new-individual&rsquo; and <code>test</code>.
</p>
<ul>
<li> <code>super-mutant-count</code> evaluate this number of mutants at once in a
  combined genome

</li></ul>
<p>Other keyword arguments are used as defined in the &lsquo;-search&rsquo; function.
</p></dd></dl>
<a name="Function-asm_002dnth_002dinstruction"></a><dl>
<dt><a name="index-asm_002dnth_002dinstruction"></a>Function: <strong>asm-nth-instruction</strong> <em>asm n</em></dt>
<dd><p>Extract the string portion of the Nth instruction from the genome of ASM.
</p></dd></dl>
<a name="Generic_002dFunction-from_002dstring"></a><dl>
<dt><a name="index-from_002dstring"></a>Generic Function: <strong>from-string</strong> <em>software string</em></dt>
<dd><p>Initialize <code>software</code> with contents of <code>string</code>.
</p></dd></dl>
<a name="Method-from_002dstring-_0028_0028obj-pliny_002ddatabase_0029-arg_0029"></a><dl>
<dt><a name="index-from_002dstring-1"></a>Method: <strong>from-string</strong> <em>(obj pliny-database) arg</em></dt>
<dd><p>Parse a database argument in the form &quot;&lt;HOST|FILE&gt;:PORT&quot;
</p></dd></dl>
<a name="Method-from_002dstring-before-_0028_0028obj-ancestral_0029-string_0029"></a><dl>
<dt><a name="index-before-from_002dstring"></a>Method: <strong>before from-string</strong> <em>(obj ancestral) string</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>string</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-from_002dstring-before-_0028_0028obj-clang_002dw_002dfodder_0029-string_0029"></a><dl>
<dt><a name="index-before-from_002dstring-1"></a>Method: <strong>before from-string</strong> <em>(obj clang-w-fodder) string</em></dt>
<dd><p>Ensure the fodder database has been initialized prior to creating
a &lsquo;clang-w-fodder&rsquo; software <code>obj</code> from <code>string</code>.
</p><ul>
<li> <code>obj</code> object to be populated from source in <code>string</code>
</li><li> <code>string</code> source code to populate <code>obj</code> with
</li></ul>
</dd></dl>
<a name="Method-from_002dstring-_0028_0028obj-clang_0029-string_0029"></a><dl>
<dt><a name="index-from_002dstring-2"></a>Method: <strong>from-string</strong> <em>(obj clang) string</em></dt>
<dd><p>Populate <code>obj</code> with the source code in <code>string</code>
</p><ul>
<li> <code>obj</code> to be populated from source in <code>string</code>
</li><li> <code>string</code> source code to populate <code>obj</code> with
</li></ul>
</dd></dl>
<a name="Function-full_002dpath"></a><dl>
<dt><a name="index-full_002dpath"></a>Function: <strong>full-path</strong> <em>rel-path</em></dt>
<dd><p>Prepend current build directory to a relative path.
</p></dd></dl>
<a name="Function-get_002dfiles_002djar"></a><dl>
<dt><a name="index-get_002dfiles_002djar"></a>Function: <strong>get-files-jar</strong> <em>jar-path</em></dt>
<dd><p>Returns a list of class files in a jar or directory.
Jars within jars are recursivly extracted
to the depth of 3 within the built jar
</p></dd></dl>
<a name="Generic_002dFunction-get_002dimmediate_002dchildren"></a><dl>
<dt><a name="index-get_002dimmediate_002dchildren"></a>Generic Function: <strong>get-immediate-children</strong> <em>obj ast</em></dt>
<dd><p>Return the immediate children of AST in <code>obj</code>.
</p></dd></dl>
<a name="Method-get_002dimmediate_002dchildren-_0028_0028obj-parseable_0029-_0028ast-ast_0029_0029"></a><dl>
<dt><a name="index-get_002dimmediate_002dchildren-1"></a>Method: <strong>get-immediate-children</strong> <em>(obj parseable) (ast ast)</em></dt>
<dd><p>Return the immediate children of AST in <code>obj</code>.
</p><ul>
<li> <code>obj</code> software object containing AST and its children
</li><li> AST node to find the children of
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-get_002dunbound_002dfuns"></a><dl>
<dt><a name="index-get_002dunbound_002dfuns"></a>Generic Function: <strong>get-unbound-funs</strong> <em>software ast</em></dt>
<dd><p>Functions used (but not defined) within the AST.
</p></dd></dl>
<a name="Method-get_002dunbound_002dfuns-_0028_0028software-clang_0029-_0028ast-clang_002dast_002dnode_0029_0029"></a><dl>
<dt><a name="index-get_002dunbound_002dfuns-1"></a>Method: <strong>get-unbound-funs</strong> <em>(software clang) (ast clang-ast-node)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>software</code> <code>docfixme</code>
</li><li> AST <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-get_002dunbound_002dfuns-_0028_0028software-clang_0029-_0028ast-clang_002dast_0029_0029"></a><dl>
<dt><a name="index-get_002dunbound_002dfuns-2"></a>Method: <strong>get-unbound-funs</strong> <em>(software clang) (ast clang-ast)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>software</code> <code>docfixme</code>
</li><li> AST <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-good_002dmutation_002dtargets"></a><dl>
<dt><a name="index-good_002dmutation_002dtargets"></a>Generic Function: <strong>good-mutation-targets</strong> <em>software &amp;key filter</em></dt>
<dd><p>Return a list of all good mutation targets in
<code>software</code> matching <code>filter</code>.
</p></dd></dl>
<a name="Method-good_002dmutation_002dtargets-_0028_0028clang-clang_0029-_0026key-filter_0029"></a><dl>
<dt><a name="index-good_002dmutation_002dtargets-1"></a>Method: <strong>good-mutation-targets</strong> <em>(clang clang) &amp;key filter</em></dt>
<dd><p>Return a list of all good statement ASTs in <code>clang</code> matching <code>filter</code>.
</p><ul>
<li> <code>clang</code> software object to query for good statements
</li><li> <code>filter</code> predicate taking an AST parameter to allow for filtering
</li></ul>
</dd></dl>
<a name="Method-good_002dmutation_002dtargets-_0028_0028obj-parseable_0029-_0026key-filter_0029"></a><dl>
<dt><a name="index-good_002dmutation_002dtargets-2"></a>Method: <strong>good-mutation-targets</strong> <em>(obj parseable) &amp;key filter</em></dt>
<dd><p>Return a list of all good mutation targets in <code>obj</code> matching <code>filter</code>.
</p><ul>
<li> <code>obj</code> software object to query for good mutation targets
</li><li> <code>filter</code> predicate taking an AST parameter to allow for filtering
</li></ul>
</dd></dl>
<a name="Function-incorporate"></a><dl>
<dt><a name="index-incorporate"></a>Function: <strong>incorporate</strong> <em>software</em></dt>
<dd><p>Incorporate <code>software</code> into <code>population</code>, keeping <code>population</code> size constant.
</p></dd></dl>
<a name="Generic_002dFunction-instrumented_002dp"></a><dl>
<dt><a name="index-instrumented_002dp"></a>Generic Function: <strong>instrumented-p</strong> <em>obj</em></dt>
<dd><p>Return true if <code>obj</code> is instrumented
</p></dd></dl>
<a name="Method-instrumented_002dp-_0028_0028clang_002dproject-clang_002dproject_0029_0029"></a><dl>
<dt><a name="index-instrumented_002dp-1"></a>Method: <strong>instrumented-p</strong> <em>(clang-project clang-project)</em></dt>
<dd><p>Return true if <code>clang-project</code> is instrumented
* <code>clang-project</code> a clang-project software object
</p></dd></dl>
<a name="Method-instrumented_002dp-_0028_0028clang-clang_0029_0029"></a><dl>
<dt><a name="index-instrumented_002dp-2"></a>Method: <strong>instrumented-p</strong> <em>(clang clang)</em></dt>
<dd><p>Return true if <code>clang</code> is instrumented
* <code>clang</code> a clang software object
</p></dd></dl>
<a name="Class-light"></a><dl>
<dt><a name="index-light"></a>Class: <strong>light</strong></dt>
<dd><p>Class precedence list: <code>light, simple, software, standard-object, t</code>
</p>
<p><code>docfixme</code>
</p></dd></dl>
<a name="Function-java_002dmake_002dliteral"></a><dl>
<dt><a name="index-java_002dmake_002dliteral"></a>Function: <strong>java-make-literal</strong> <em>kind value</em></dt>
<dd><p>Returns simple representations of the input literal.
</p></dd></dl>
<a name="Function-lexicase_002dselect"></a><dl>
<dt><a name="index-lexicase_002dselect"></a>Function: <strong>lexicase-select</strong> <em>population max-size</em></dt>
<dd><p>Choose max-size individuals from the population by lexicase selection.
The same individual may be selected multiple times.
</p></dd></dl>
<a name="Function-lexicase_002dselect_002dbest"></a><dl>
<dt><a name="index-lexicase_002dselect_002dbest"></a>Function: <strong>lexicase-select-best</strong> <em>group &amp;key predicate</em></dt>
<dd><p>Choose best individuals by lexicase selection.
</p>
<p>If there is a tie after all tests, return all remaining individuals.
</p>
<p>Set the value of &lsquo;*tournament-selector*&rsquo; to &lsquo;lexicase-select-best&rsquo; to
use lexicase-style selection in tournament selection.
</p></dd></dl>
<a name="Generic_002dFunction-lines"></a><dl>
<dt><a name="index-lines"></a>Generic Function: <strong>lines</strong> <em>software</em></dt>
<dd><p>Return the lines of code of the &lsquo;genome&rsquo; of <code>software</code>.
</p></dd></dl>
<a name="Method-lines-_0028_0028obj-source_0029_0029"></a><dl>
<dt><a name="index-lines-1"></a>Method: <strong>lines</strong> <em>(obj source)</em></dt>
<dd><p>Return a list of lines of source in <code>obj</code>
</p></dd></dl>
<a name="Method-lines-_0028_0028elf-elf_002drisc_0029_0029"></a><dl>
<dt><a name="index-lines-2"></a>Method: <strong>lines</strong> <em>(elf elf-risc)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-lines-_0028_0028elf-elf_002dcisc_0029_0029"></a><dl>
<dt><a name="index-lines-3"></a>Method: <strong>lines</strong> <em>(elf elf-cisc)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-lines-_0028_0028asm-asm_002dheap_0029_0029"></a><dl>
<dt><a name="index-lines-4"></a>Method: <strong>lines</strong> <em>(asm asm-heap)</em></dt>
<dd><p>Return the list of text lines of the genome.
</p></dd></dl>
<a name="Method-lines-_0028_0028range-sw_002drange_0029_0029"></a><dl>
<dt><a name="index-lines-5"></a>Method: <strong>lines</strong> <em>(range sw-range)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-lines-_0028_0028light-light_0029_0029"></a><dl>
<dt><a name="index-lines-6"></a>Method: <strong>lines</strong> <em>(light light)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-lines-_0028_0028simple-simple_0029_0029"></a><dl>
<dt><a name="index-lines-7"></a>Method: <strong>lines</strong> <em>(simple simple)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Class-llvm"></a><dl>
<dt><a name="index-llvm"></a>Class: <strong>llvm</strong></dt>
<dd><p>Class precedence list: <code>llvm, source, software, standard-object, t</code>
</p>
<p>Low Level Virtual Machine <code>(llvm) </code>intermediate representation <code>(ir)</code>.
See http://llvm.org).
</p></dd></dl>
<a name="Generic_002dFunction-lookup_002dsource_002dstrings"></a><dl>
<dt><a name="index-lookup_002dsource_002dstrings"></a>Generic Function: <strong>lookup-source-strings</strong> <em>software &amp;key include-imports</em></dt>
<dd><p>Return a list of source strings for the ASTs in <code>software</code>.
Set <code>include-imports</code> to <code>t</code> to include import statements in the result.
</p></dd></dl>
<a name="Method-lookup_002dsource_002dstrings-_0028_0028obj-coq_0029-_0026key-include_002dimports_0029"></a><dl>
<dt><a name="index-lookup_002dsource_002dstrings-1"></a>Method: <strong>lookup-source-strings</strong> <em>(obj coq) &amp;key include-imports</em></dt>
<dd><p>Return a list of source strings for the ASTs in <code>coq</code>.
Set <code>include-imports</code> to <code>t</code> to include import statements in the result.
</p></dd></dl>
<a name="Class-loosen_002dcondition"></a><dl>
<dt><a name="index-loosen_002dcondition"></a>Class: <strong>loosen-condition</strong></dt>
<dd><p>Class precedence list: <code>loosen-condition, refine-condition, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Add an abstract condition to make a guard more permissive.
<code>e</code>.g., if(foo) becomes if(foo || abst_cond()).
</p></dd></dl>
<a name="Class-replace_002dfodder_002dsame"></a><dl>
<dt><a name="index-replace_002dfodder_002dsame"></a>Class: <strong>replace-fodder-same</strong></dt>
<dd><p>Class precedence list: <code>replace-fodder-same, clang-replace, clang-mutation, parseable-replace, parseable-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Replace an AST in a clang software object with a fodder
AST of the same class.
</p></dd></dl>
<a name="Variable-_002adatabase_002a"></a><dl>
<dt><a name="index-_002adatabase_002a"></a>Variable: <strong>*database*</strong></dt>
<dd><p>Database utilized for fodder selection
</p></dd></dl>
<a name="Variable-_002atarget_002dfitness_002dp_002a"></a><dl>
<dt><a name="index-_002atarget_002dfitness_002dp_002a"></a>Variable: <strong>*target-fitness-p*</strong></dt>
<dd><p>Predicate indicating whether an individual has reached the target fitness.
</p></dd></dl>
<a name="Constant-_002bc_002dnumeric_002dtypes_002b"></a><dl>
<dt><a name="index-_002bc_002dnumeric_002dtypes_002b"></a>Constant: <strong>+c-numeric-types+</strong></dt>
<dd><p>C Numeric type names.
</p></dd></dl>
<a name="Variable-ast_002dnode_002dtype_002dtf_002dfeature"></a><dl>
<dt><a name="index-ast_002dnode_002dtype_002dtf_002dfeature"></a>Variable: <strong>ast-node-type-tf-feature</strong></dt>
<dd><p>Term frequency of AST node types.
</p></dd></dl>
<a name="Generic_002dFunction-at_002dtargets"></a><dl>
<dt><a name="index-at_002dtargets"></a>Generic Function: <strong>at-targets</strong> <em>mutation targets &amp;key object &amp;allow-other-keys</em></dt>
<dd><p>Return a copy of <code>mutation</code> with &lsquo;targets&rsquo; set to <code>targets</code>.
</p></dd></dl>
<a name="Method-at_002dtargets-_0028_0028mut-mutation_0029-targets-_0026key-_0028object-_0028object-mut_0029_0029_0029"></a><dl>
<dt><a name="index-at_002dtargets-1"></a>Method: <strong>at-targets</strong> <em>(mut mutation) targets &amp;key (object (object mut))</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>mut</code> <code>docfixme</code>
</li><li> <code>targets</code> <code>docfixme</code>
</li><li> <code>object</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Macro-mcmc"></a><dl>
<dt><a name="index-mcmc"></a>Macro: <strong>mcmc</strong> <em>original test &amp;key accept-fn max-evals max-time period period-fn every-pre-fn every-post-fn filter analyze-mutation-fn</em></dt>
<dd><p><code>mcmc</code> search from <code>original</code> using &lsquo;mcmc-step&rsquo; and <code>test</code>.
If keyword argument <code>accept-fn</code> is given it is used to determine when a
newly found candidate replaces the current candidate.  If <code>accept-fn</code> is
not supplied <code>mcmc</code> defaults to using Metropolis Hastings.
</p>
<p>Other keyword arguments are used as defined in the &lsquo;-search&rsquo; function.
</p></dd></dl>
<a name="Macro-with_002dtemp_002dbuild_002ddir"></a><dl>
<dt><a name="index-with_002dtemp_002dbuild_002ddir"></a>Macro: <strong>with-temp-build-dir</strong> <em>(src-dir) &amp;body body</em></dt>
<dd><p>Create a temporary copy of src-dir, and rebind *build-dir* to that
path within <code>body</code>.
</p></dd></dl>
<a name="Function-fitness_002dequal_002dp"></a><dl>
<dt><a name="index-fitness_002dequal_002dp"></a>Function: <strong>fitness-equal-p</strong> <em>fitness-a fitness-b</em></dt>
<dd><p>Return true if <code>fitness-a</code> and <code>fitness-b</code> are equal
</p></dd></dl>
<a name="Function-instrumentation_002dexprs"></a><dl>
<dt><a name="index-instrumentation_002dexprs"></a>Function: <strong>instrumentation-exprs</strong> <em>obj point type</em></dt>
<dd><p>Return a list of additional expressions to instrument during condition
synthesis. Finds all expressions of the given type which are in scope
at the repair point, and generates comparisons for all of them. These
expressions can be passed as <code>extra-instrumentation-exprs</code> to
&lsquo;synthesize-condition&rsquo;.
</p>
<ul>
<li> <code>obj</code> software object
</li><li> <code>point</code> repair point for which to generate instrumentation
</li><li> <code>type</code> type description alist (:types :array :pointer :compare)
       Where :compare is a format template for the comparison
       expressions, and the other fields are matched against
       the type <code>db</code>.
</li></ul>
</dd></dl>
<a name="Function-make_002darray_002dsubscript_002dexpr"></a><dl>
<dt><a name="index-make_002darray_002dsubscript_002dexpr"></a>Function: <strong>make-array-subscript-expr</strong> <em>array-expr subscript-expr &amp;rest rest</em></dt>
<dd><p>Create a array subscript expression AST.
</p><ul>
<li> <code>array-expr</code> AST expression with an array type
</li><li> <code>subscript-expr</code> AST expression with an integer type to be used as array
  subscript
</li><li> <code>rest</code> additional arguments to &lsquo;make-statement&rsquo;
</li></ul>
</dd></dl>
<a name="Function-make_002dblock"></a><dl>
<dt><a name="index-make_002dblock"></a>Function: <strong>make-block</strong> <em>children &amp;rest rest</em></dt>
<dd><p>Create a compount statement AST.
</p><ul>
<li> <code>children</code> children of the AST node
</li><li> <code>rest</code> additional arguments to &lsquo;make-statement&rsquo;
</li></ul>
</dd></dl>
<a name="Function-make_002dbreak_002dstmt"></a><dl>
<dt><a name="index-make_002dbreak_002dstmt"></a>Function: <strong>make-break-stmt</strong> <em>&amp;rest rest</em></dt>
<dd><p>Create a break statement AST.
* <code>rest</code> additional arguments to &lsquo;make-statement&rsquo;
</p></dd></dl>
<a name="Function-make_002dbuild_002ddir"></a><dl>
<dt><a name="index-make_002dbuild_002ddir"></a>Function: <strong>make-build-dir</strong> <em>src-dir &amp;key path</em></dt>
<dd><p>Create a temporary copy of a build directory for use during evolution.
</p></dd></dl>
<a name="Function-make_002dcall_002dexpr"></a><dl>
<dt><a name="index-make_002dcall_002dexpr"></a>Function: <strong>make-call-expr</strong> <em>name args syn-ctx &amp;rest rest</em></dt>
<dd><p>Create a call expression AST.
</p><ul>
<li> <code>name</code> Name of the function
</li><li> <code>args</code> list of ast arguments to the function
</li><li> <code>syn-ctx</code> surrounding syntactic context of the AST node
</li><li> <code>rest</code> additional arguments to &lsquo;make-statement&rsquo;
</li></ul>
</dd></dl>
<a name="Function-make_002dcast_002dexpr"></a><dl>
<dt><a name="index-make_002dcast_002dexpr"></a>Function: <strong>make-cast-expr</strong> <em>type child &amp;rest rest</em></dt>
<dd><p>Create a c-style cast expression AST.
</p><ul>
<li> <code>type</code> clang-type to cast the expression to
</li><li> <code>child</code> ast to be cast
</li><li> <code>rest</code> additional arguments to &lsquo;make-statement&rsquo;
</li></ul>
</dd></dl>
<a name="Function-make_002dfor_002dstmt"></a><dl>
<dt><a name="index-make_002dfor_002dstmt"></a>Function: <strong>make-for-stmt</strong> <em>syn-ctx initialization condition update body &amp;rest rest</em></dt>
<dd><p>Create a for loop AST.
</p><ul>
<li> <code>syn-ctx</code> surrounding syntactic context of the AST node
</li><li> <code>initialization</code> ast for the initialization of the loop
</li><li> <code>condition</code> ast for the loop conditional
</li><li> <code>update</code> ast for the loop update
</li><li> <code>body</code> ast for the loop body
</li><li> <code>rest</code> additional arguments to &lsquo;make-statement&rsquo;
</li></ul>
</dd></dl>
<a name="Function-make_002dlabel"></a><dl>
<dt><a name="index-make_002dlabel"></a>Function: <strong>make-label</strong> <em>name child &amp;rest rest</em></dt>
<dd><p>Create a label AST.
</p><ul>
<li> <code>name</code> name of the label
</li><li> <code>child</code> ast to be labeled
</li></ul>
</dd></dl>
<a name="Function-make_002dliteral"></a><dl>
<dt><a name="index-make_002dliteral"></a>Function: <strong>make-literal</strong> <em>value &amp;optional kind &amp;rest rest</em></dt>
<dd><p>Create a literal AST of <code>value</code>.
</p><ul>
<li> Optional value <code>kind</code> specified the type of literal to
  create (:integer, :unsigned, :float, :string, :quoated-string).
  Defaults based on the type of value
</li><li> <code>value</code> value for the literal AST to have
</li><li> <code>rest</code> additional arguments to &lsquo;make-statement&rsquo;
</li></ul>
</dd></dl>
<a name="Function-make_002doperator"></a><dl>
<dt><a name="index-make_002doperator"></a>Function: <strong>make-operator</strong> <em>syn-ctx opcode child-asts &amp;rest rest</em></dt>
<dd><p>Create a unary or binary operator AST.
</p><ul>
<li> <code>syn-ctx</code> surrounding syntactic context of the AST node
</li><li> <code>opcode</code> name of the operation for Unary/BinaryOp AST nodes
</li><li> <code>child-asts</code> children of the AST node
</li><li> <code>rest</code> additional arguments to &lsquo;make-statement&rsquo;
</li></ul>
</dd></dl>
<a name="Function-make_002dparens"></a><dl>
<dt><a name="index-make_002dparens"></a>Function: <strong>make-parens</strong> <em>children &amp;rest rest</em></dt>
<dd><p>Create a parenthesis expression AST.
</p><ul>
<li> <code>children</code> children of the AST node
</li><li> <code>rest</code> additional arguments to &lsquo;make-statement&rsquo;
</li></ul>
</dd></dl>
<a name="Function-make_002dstatement"></a><dl>
<dt><a name="index-make_002dstatement"></a>Function: <strong>make-statement</strong> <em>class syn-ctx children &amp;key expr-type full-stmt guard-stmt opcode types unbound-funs unbound-vals declares includes aux-data</em></dt>
<dd><p>Create a statement AST.
</p>
<p><code>types</code>, <code>unbound-funs</code>, and <code>unbound-vals</code> will be computed from children
if not given.
</p>
<ul>
<li> <code>class</code> class name of the AST node
</li><li> <code>syn-ctx</code> surrounding syntactic context of the AST node
</li><li> <code>children</code> children of the AST node
</li><li> <code>expr-type</code> type hash of the expression represented by the AST node
</li><li> <code>full-stmt</code> boolean indicating if the AST represents a complete statement
</li><li> <code>guard-stmt</code>  boolean indicating if the AST is a control-flow predicate
</li><li> <code>opcode</code> name of the operation for Unary/BinaryOp AST nodes
</li><li> <code>types</code> list of type hashes for types used in the AST node
</li><li> <code>unbound-funs</code> list of free function in the AST node
</li><li> <code>unbound-vals</code> list of free variables in the AST node
</li><li> <code>declares</code> list of identifiers declared by the AST node
</li><li> <code>includes</code> header files used by the AST node
</li></ul>
</dd></dl>
<a name="Function-make_002dswitch_002dstmt"></a><dl>
<dt><a name="index-make_002dswitch_002dstmt"></a>Function: <strong>make-switch-stmt</strong> <em>value cases &amp;rest rest</em></dt>
<dd><p>Create a switch statement AST.
</p><ul>
<li> <code>value</code> the AST of the expression to switch on
</li><li> <code>cases</code> list of cases
</li><li> <code>syn-ctx</code> surrounding syntactic context of the AST node
</li><li> <code>rest</code> additional arguments to &lsquo;make-statement&rsquo;

</li></ul>
<p>Each element of <code>cases</code> has the form ((values ...) stmts ), where each
value is an integer (or <code>t</code> for the default case) and each stmt is a
full-statement AST. Don&rsquo;t forget to include BreakStmt ASTs as they
will not be generated automatically.
</p></dd></dl>
<a name="Function-make_002dvar_002ddecl"></a><dl>
<dt><a name="index-make_002dvar_002ddecl"></a>Function: <strong>make-var-decl</strong> <em>name type &amp;optional initializer &amp;rest rest</em></dt>
<dd><p>Create a variable declaration AST.
</p><ul>
<li> <code>name</code> name of the variable to declare
</li><li> <code>type</code> type of the variable
</li><li> <code>initializer</code> optional AST to initialize the variable
</li><li> <code>rest</code> additional arguments to &lsquo;make-statement&rsquo;
</li></ul>
</dd></dl>
<a name="Function-make_002dvar_002dreference"></a><dl>
<dt><a name="index-make_002dvar_002dreference"></a>Function: <strong>make-var-reference</strong> <em>name type &amp;rest rest</em></dt>
<dd><p>Create a variable reference AST.
</p><ul>
<li> <code>name</code> name of the variable to reference
</li><li> <code>type</code> type of the variable to reference
</li><li> <code>rest</code> optional additional arguments to &lsquo;make-statement&rsquo;
</li></ul>
</dd></dl>
<a name="Function-make_002dwhile_002dstmt"></a><dl>
<dt><a name="index-make_002dwhile_002dstmt"></a>Function: <strong>make-while-stmt</strong> <em>syn-ctx condition body &amp;rest rest</em></dt>
<dd><p>Create a while loop AST.
</p><ul>
<li> <code>syn-ctx</code> surrounding syntactic context of the AST node
</li><li> <code>condition</code> ast conditional for the while statement
</li><li> <code>body</code> ast body for the while statement
</li><li> <code>rest</code> additional arguments to &lsquo;make-statement&rsquo;
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-max_002ddepth_002dast"></a><dl>
<dt><a name="index-max_002ddepth_002dast"></a>Generic Function: <strong>max-depth-ast</strong> <em>software asts</em></dt>
<dd><p>Return the maximum depth of the <code>asts</code> in <code>software</code>.
</p></dd></dl>
<a name="Method-max_002ddepth_002dast-_0028_0028clang-clang_0029-asts_0029"></a><dl>
<dt><a name="index-max_002ddepth_002dast-1"></a>Method: <strong>max-depth-ast</strong> <em>(clang clang) asts</em></dt>
<dd><p>Return the maximum depth of the <code>asts</code> in <code>clang</code>.
All depths are relative to the top-level of the <code>clang</code> software object (not
relative to elements in the list of ASTs).
</p><ul>
<li> <code>clang</code> software object
</li><li> <code>asts</code> list of ASTs for which to determine the depth
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-max_002ddepth_002dast_002dextractor"></a><dl>
<dt><a name="index-max_002ddepth_002dast_002dextractor"></a>Generic Function: <strong>max-depth-ast-extractor</strong> <em>software</em></dt>
<dd><p>Return 1-element feature vector of the max depth of any AST in <code>software</code>.
</p></dd></dl>
<a name="Generic_002dFunction-mcmc_002dstep"></a><dl>
<dt><a name="index-mcmc_002dstep"></a>Generic Function: <strong>mcmc-step</strong> <em>software</em></dt>
<dd><p>Change software in a way amenable to <code>mcmc</code>.
Specifically every step should be reversible, and the resulting walk
should be ergodic.
</p></dd></dl>
<a name="Method-mcmc_002dstep-_0028_0028simple-simple_0029_0029"></a><dl>
<dt><a name="index-mcmc_002dstep-1"></a>Method: <strong>mcmc-step</strong> <em>(simple simple)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Function-merge_002dmax"></a><dl>
<dt><a name="index-merge_002dmax"></a>Function: <strong>merge-max</strong> <em>vec1 meta1 vec2 meta2</em></dt>
<dd><p>Return a new vector of the pair-wise maximums for values in VEC1 and VEC2.
Metadata, META1 and META2 is ignored.
</p></dd></dl>
<a name="Function-merge_002dmeans"></a><dl>
<dt><a name="index-merge_002dmeans"></a>Function: <strong>merge-means</strong> <em>means1 lens1 means2 lens2</em></dt>
<dd><p>Return a new vector merging vectors MEANS1 and MEANS2 whose elements are means.
Each element of MEANS1 and MEANS2 represents the mean of a set whose size is the
corresponding element in vector LENS1 or LENS2, respectively. The result is two
values: a vector of the combined means, and a vector of the pair-wise sums of
LENS1 and LENS2 (i.e., the sizes of the combined sets each combined mean
represents).
</p></dd></dl>
<a name="Function-mutant"></a><dl>
<dt><a name="index-mutant"></a>Function: <strong>mutant</strong> <em>&amp;optional new</em></dt>
<dd><p>Generate a new mutant from a <code>*population*</code>.
</p></dd></dl>
<a name="Generic_002dFunction-mutate"></a><dl>
<dt><a name="index-mutate"></a>Generic Function: <strong>mutate</strong> <em>software</em></dt>
<dd><p>Mutate the software.  May throw a &lsquo;mutate&rsquo; error.
</p></dd></dl>
<a name="Method-mutate-_0028_0028obj-project_0029_0029"></a><dl>
<dt><a name="index-mutate-1"></a>Method: <strong>mutate</strong> <em>(obj project)</em></dt>
<dd><p>Randomly pick one file to mutate.
</p></dd></dl>
<a name="Method-mutate-_0028_0028llvm-llvm_0029_0029"></a><dl>
<dt><a name="index-mutate-2"></a>Method: <strong>mutate</strong> <em>(llvm llvm)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-mutate-_0028_0028clang-clang_0029_0029"></a><dl>
<dt><a name="index-mutate-3"></a>Method: <strong>mutate</strong> <em>(clang clang)</em></dt>
<dd><p>Select a random mutation and mutate <code>clang</code>.
</p></dd></dl>
<a name="Method-mutate-_0028_0028obj-source_0029_0029"></a><dl>
<dt><a name="index-mutate-4"></a>Method: <strong>mutate</strong> <em>(obj source)</em></dt>
<dd><p>Apply a mutation to <code>obj</code>
</p></dd></dl>
<a name="Method-mutate-_0028_0028elf-elf_0029_0029"></a><dl>
<dt><a name="index-mutate-5"></a>Method: <strong>mutate</strong> <em>(elf elf)</em></dt>
<dd><p>Randomly mutate <code>elf</code>.
</p></dd></dl>
<a name="Method-mutate-_0028_0028lisp-lisp_0029_0029"></a><dl>
<dt><a name="index-mutate-6"></a>Method: <strong>mutate</strong> <em>(lisp lisp)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-mutate-_0028_0028simple-simple_0029_0029"></a><dl>
<dt><a name="index-mutate-7"></a>Method: <strong>mutate</strong> <em>(simple simple)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Condition-mutate"></a><dl>
<dt><a name="index-mutate-8"></a>Condition: <strong>mutate</strong></dt>
<dd><p>Class precedence list: <code>mutate, error, serious-condition, condition, t</code>
</p>
<p>Mutation errors are thrown when a mutation fails.
These may often be safely ignored.  A common restart is
&lsquo;ignore-failed-mutation&rsquo;.
</p></dd></dl>
<a name="Generic_002dFunction-mutation_002dkey"></a><dl>
<dt><a name="index-mutation_002dkey"></a>Generic Function: <strong>mutation-key</strong> <em>software mutation</em></dt>
<dd><p>Key used to organize mutations in *mutation-stats*.
</p></dd></dl>
<a name="Method-mutation_002dkey-_0028_0028obj-clang_0029-op_0029"></a><dl>
<dt><a name="index-mutation_002dkey-1"></a>Method: <strong>mutation-key</strong> <em>(obj clang) op</em></dt>
<dd><p>Return key used to organize mutations in *mutation-stats* hashtable.
</p><ul>
<li> <code>obj</code> object mutation is to be applied to
</li><li> <code>op</code> operation to be performed
</li></ul>
</dd></dl>
<a name="Method-mutation_002dkey-_0028_0028obj-software_0029-_0028mutation-mutation_0029_0029"></a><dl>
<dt><a name="index-mutation_002dkey-2"></a>Method: <strong>mutation-key</strong> <em>(obj software) (mutation mutation)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mutation</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-mutation_002dkey-_0028_0028obj-software_0029-mutation_0029"></a><dl>
<dt><a name="index-mutation_002dkey-3"></a>Method: <strong>mutation-key</strong> <em>(obj software) mutation</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>mutation</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-mutation_002dtargets"></a><dl>
<dt><a name="index-mutation_002dtargets"></a>Generic Function: <strong>mutation-targets</strong> <em>software &amp;key filter stmt-pool</em></dt>
<dd><p>Return a list of target ASTs in <code>software</code> from
<code>stmt-pool</code> for mutation, filtering using <code>filter</code>, and throwing a
&rsquo;no-mutation-targets exception if none are available.
</p></dd></dl>
<a name="Method-mutation_002dtargets-_0028_0028clang-clang_0029-_0026key-_0028filter-nil_0029-_0028stmt_002dpool-_0023_0027stmt_002dasts_0029_0029"></a><dl>
<dt><a name="index-mutation_002dtargets-1"></a>Method: <strong>mutation-targets</strong> <em>(clang clang) &amp;key (filter nil) (stmt-pool (function stmt-asts))</em></dt>
<dd><p>Return a list of target ASTs from <code>stmt-pool</code> for mutation, throwing
a &rsquo;no-mutation-targets exception if none are available.
</p>
<ul>
<li> <code>clang</code> software object to query for mutation targets
</li><li> <code>filter</code> filter AST from consideration when this function returns nil
</li><li> <code>stmt-pool</code> method on <code>clang</code> returning a list of ASTs
</li></ul>
</dd></dl>
<a name="Method-mutation_002dtargets-_0028_0028obj-parseable_0029-_0026key-_0028filter-nil_0029-_0028stmt_002dpool-_0023_0027asts-stmt_002dpool_002dsupplied_002dp_0029_0029"></a><dl>
<dt><a name="index-mutation_002dtargets-2"></a>Method: <strong>mutation-targets</strong> <em>(obj parseable) &amp;key (filter nil) (stmt-pool (function asts) stmt-pool-supplied-p)</em></dt>
<dd><p>Return a list of target ASTs from <code>stmt-pool</code> for mutation, throwing
a &rsquo;no-mutation-targets exception if none are available.
</p>
<ul>
<li> <code>obj</code> software object to query for mutation targets
</li><li> <code>filter</code> filter AST from consideration when this function returns nil
</li><li> <code>stmt-pool</code> method on <code>obj</code> returning a list of ASTs
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-nop_002dp"></a><dl>
<dt><a name="index-nop_002dp"></a>Generic Function: <strong>nop-p</strong> <em>elf bytes</em></dt>
<dd><p>Return non-nil if <code>bytes</code> is a <code>nop</code> for <code>elf</code>.
</p></dd></dl>
<a name="Method-nop_002dp-_0028_0028elf-elf_002darm_0029-bytes_0029"></a><dl>
<dt><a name="index-nop_002dp-1"></a>Method: <strong>nop-p</strong> <em>(elf elf-arm) bytes</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-nop_002dp-_0028_0028elf-elf_002dx86_0029-bytes_0029"></a><dl>
<dt><a name="index-nop_002dp-2"></a>Method: <strong>nop-p</strong> <em>(elf elf-x86) bytes</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Function-normalize_002dvector"></a><dl>
<dt><a name="index-normalize_002dvector"></a>Function: <strong>normalize-vector</strong> <em>vec</em></dt>
<dd><p>Return a copy of <code>vec</code> whose elements have been normalized to sum to 1.
</p>
<p>* <code>vec</code> a vector of numeric values.
</p></dd></dl>
<a name="Function-number_002dgenome"></a><dl>
<dt><a name="index-number_002dgenome"></a>Function: <strong>number-genome</strong> <em>asm</em></dt>
<dd><p>Number each element in the genome of ASM by adding an <code>:id</code> association.
</p></dd></dl>
<a name="Generic_002dFunction-pad_002dnops"></a><dl>
<dt><a name="index-pad_002dnops"></a>Generic Function: <strong>pad-nops</strong> <em>elf num-bytes</em></dt>
<dd><p>Return NOP(s) sufficient to fill num-bytes
</p></dd></dl>
<a name="Method-pad_002dnops-_0028_0028elf-elf_002darm_0029-num_002dbytes_0029"></a><dl>
<dt><a name="index-pad_002dnops-1"></a>Method: <strong>pad-nops</strong> <em>(elf elf-arm) num-bytes</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-pad_002dnops-_0028_0028elf-elf_002dx86_0029-num_002dbytes_0029"></a><dl>
<dt><a name="index-pad_002dnops-2"></a>Method: <strong>pad-nops</strong> <em>(elf elf-x86) num-bytes</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Function-parse_002dsource_002dsnippet"></a><dl>
<dt><a name="index-parse_002dsource_002dsnippet"></a>Function: <strong>parse-source-snippet</strong> <em>snippet unbound-vals &amp;key includes macros preamble top-level keep-comments</em></dt>
<dd><p>Build ASTs for <code>snippet</code>, returning a list of root asts.
</p>
<ul>
<li> <code>snippet</code> may include one or more full statements. It should compile in
  a context where all <code>unbound-vals</code> are defined and all <code>includes</code> are
  included.

</li><li> <code>unbound-vals</code> should have the form ((name clang-type) ... )

</li><li> <code>includes</code> is a list of files to include.

</li><li> <code>macros</code> is a list of macros to define

</li><li> <code>preamble</code> source to add prior to snippet

</li><li> <code>top-level</code> indicates that the snippet is a construct which can exist
  outside a function body, such as a type or function declaration.

</li><li> <code>keep-comments</code> indicates comments should be retained
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-phenome"></a><dl>
<dt><a name="index-phenome"></a>Generic Function: <strong>phenome</strong> <em>software &amp;key bin src</em></dt>
<dd><p>Phenotype of the software.
This method will link, compile or serialize the software object as
necessary returning an executable version of the software suitable for
testing and evaluation.  Returns multiple values holding in order; (1)
the binary path to which the executable was compiled, (2) the errno,
or a numeric indication of success, of the compilation process, (3)
<code>stderr</code> of the compilation process, or a string holding error output
relevant to phenome generation, (4) <code>stdout</code> of the compilation process,
or a string holding non-error output relevant to phenome
generation, (5) the source file name used during compilation. 
</p></dd></dl>
<a name="Method-phenome-_0028_0028obj-super_002dmutant_0029-_0026key-_0028bin-_0028temp_002dfile_002dname_0029_0029_0029"></a><dl>
<dt><a name="index-phenome-1"></a>Method: <strong>phenome</strong> <em>(obj super-mutant) &amp;key (bin (temp-file-name))</em></dt>
<dd><p>Phenotype of the software.
This method will link, compile or serialize the software object as
necessary returning an executable version of the software suitable for
testing and evaluation.  Returns multiple values holding in order; (1)
the binary path to which the executable was compiled, (2) the errno,
or a numeric indication of success, of the compilation process, (3)
<code>stderr</code> of the compilation process, or a string holding error output
relevant to phenome generation, (4) <code>stdout</code> of the compilation process,
or a string holding non-error output relevant to phenome
generation, (5) the source file name used during compilation. 
</p></dd></dl>
<a name="Method-phenome-_0028_0028obj-project_0029-_0026key-_0028bin-_0028temp_002dfile_002dname_0029_0029_0029"></a><dl>
<dt><a name="index-phenome-2"></a>Method: <strong>phenome</strong> <em>(obj project) &amp;key (bin (temp-file-name))</em></dt>
<dd><p>Build the software project <code>obj</code> and copy build artifact(s) to <code>bin</code>.
</p></dd></dl>
<a name="Method-phenome-_0028_0028llvm-llvm_0029-_0026key-_0028bin-_0028temp_002dfile_002dname_0029_0029_0029"></a><dl>
<dt><a name="index-phenome-3"></a>Method: <strong>phenome</strong> <em>(llvm llvm) &amp;key (bin (temp-file-name))</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>llvm</code> <code>docfixme</code>
</li><li> <code>bin</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-phenome-_0028_0028forth-forth_0029-_0026key-_0028bin-_0028temp_002dfile_002dname_0029_0029_0029"></a><dl>
<dt><a name="index-phenome-4"></a>Method: <strong>phenome</strong> <em>(forth forth) &amp;key (bin (temp-file-name))</em></dt>
<dd><p>Write <code>forth</code> to an executable script suitable for evaluation.
</p></dd></dl>
<a name="Method-phenome-_0028_0028obj-java_0029-_0026key-_0028bin-_0028temp_002dfile_002dname_0029_0029_0029"></a><dl>
<dt><a name="index-phenome-5"></a>Method: <strong>phenome</strong> <em>(obj java) &amp;key (bin (temp-file-name))</em></dt>
<dd><p>Compiles the software object to a jar and converts it to a linux executable
</p></dd></dl>
<a name="Method-phenome-_0028_0028obj-source_0029-_0026key-_0028bin-_0028temp_002dfile_002dname_0029_0029_0029"></a><dl>
<dt><a name="index-phenome-6"></a>Method: <strong>phenome</strong> <em>(obj source) &amp;key (bin (temp-file-name))</em></dt>
<dd><p>Compile <code>obj</code> to create an executable version of the software
on the filesystem at <code>bin</code>.
</p></dd></dl>
<a name="Method-phenome-_0028_0028elf-elf_0029-_0026key-_0028bin-_0028temp_002dfile_002dname_0029_0029_0029"></a><dl>
<dt><a name="index-phenome-7"></a>Method: <strong>phenome</strong> <em>(elf elf) &amp;key (bin (temp-file-name))</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-phenome-_0028_0028asm-csurf_002dasm_0029-_0026key-_0028bin-_0028temp_002dfile_002dname_0029_0029_0029"></a><dl>
<dt><a name="index-phenome-8"></a>Method: <strong>phenome</strong> <em>(asm csurf-asm) &amp;key (bin (temp-file-name))</em></dt>
<dd><p>Assemble and link ASM into binary <code>bin</code>.
1. Run &lsquo;assembler&rsquo; with &lsquo;asm-flags&rsquo;. If unsuccessful, return early.
2. If ASM contains &lsquo;weak-symbols&rsquo;, mark them as weakly required
   (see &lsquo;elf-weaken-gmon-start&rsquo;).
3. Run &lsquo;linker&rsquo; with &lsquo;flags&rsquo;.
4. If &lsquo;redirect-file&rsquo; is specified, run &lsquo;elf-copy-redirect&rsquo;.
</p></dd></dl>
<a name="Method-phenome-_0028_0028asm-asm_002dsuper_002dmutant_0029-_0026key-_0028bin-_0028temp_002dfile_002dname-out_0029_0029-_0028src-_0028temp_002dfile_002dname-asm_0029_0029_0029"></a><dl>
<dt><a name="index-phenome-9"></a>Method: <strong>phenome</strong> <em>(asm asm-super-mutant) &amp;key (bin (temp-file-name out)) (src (temp-file-name asm))</em></dt>
<dd><p>Create ASM file, assemble it, and link to create binary <code>bin</code>.
</p></dd></dl>
<a name="Method-phenome-_0028_0028asm-asm_0029-_0026key-_0028bin-_0028temp_002dfile_002dname_0029_0029_0029"></a><dl>
<dt><a name="index-phenome-10"></a>Method: <strong>phenome</strong> <em>(asm asm) &amp;key (bin (temp-file-name))</em></dt>
<dd><p>Runs the &lsquo;linker&rsquo; for ASM, using the specified &lsquo;flags&rsquo; for ASM and returns
multiple values holding in order: (1) the binary path <code>bin</code> to which the
executable was compiled, (2) the errno, or a numeric indication of success, of
the linking process, (3) <code>stderr</code> of the linking process, (4) <code>stdout</code> of the
linking process, (5) the source file name used during linking.
</p></dd></dl>
<a name="Generic_002dFunction-phenome_002dp"></a><dl>
<dt><a name="index-phenome_002dp"></a>Generic Function: <strong>phenome-p</strong> <em>software</em></dt>
<dd><p>Return non-nil if <code>software</code> has a phenotype.
</p></dd></dl>
<a name="Generic_002dFunction-pick"></a><dl>
<dt><a name="index-pick"></a>Generic Function: <strong>pick</strong> <em>software key &amp;optional func</em></dt>
<dd><p>Pick an element of <code>genome</code> based on <code>key</code> of each element.
<code>key</code> is passed to &lsquo;proportional-pick&rsquo; to return an index.  Optional
argument <code>func</code> processes the index to return a result.
</p></dd></dl>
<a name="Generic_002dFunction-pick_002dbad"></a><dl>
<dt><a name="index-pick_002dbad"></a>Generic Function: <strong>pick-bad</strong> <em>software</em></dt>
<dd><p>Pick a &rsquo;bad&rsquo; index into a software object.
Used to target mutation.
</p></dd></dl>
<a name="Method-pick_002dbad-_0028_0028obj-coq_0029_0029"></a><dl>
<dt><a name="index-pick_002dbad-1"></a>Method: <strong>pick-bad</strong> <em>(obj coq)</em></dt>
<dd><p>Return a randomly selected index of a bad statement in <code>obj</code>.
Remove statements containing Coq location info from consideration.
If none exist, raise a &lsquo;no-mutation-targets&rsquo; error.
</p></dd></dl>
<a name="Method-pick_002dbad-_0028_0028clang-clang_0029_0029"></a><dl>
<dt><a name="index-pick_002dbad-2"></a>Method: <strong>pick-bad</strong> <em>(clang clang)</em></dt>
<dd><p>Pick a random AST in <code>clang</code> from the &lsquo;bad-stmt&rsquo; pool.
</p></dd></dl>
<a name="Method-pick_002dbad-_0028_0028obj-parseable_0029_0029"></a><dl>
<dt><a name="index-pick_002dbad-3"></a>Method: <strong>pick-bad</strong> <em>(obj parseable)</em></dt>
<dd><p>Pick a &rsquo;bad&rsquo; index into a software object.
Used to target mutation.
</p></dd></dl>
<a name="Method-pick_002dbad-_0028_0028elf-elf_0029_0029"></a><dl>
<dt><a name="index-pick_002dbad-4"></a>Method: <strong>pick-bad</strong> <em>(elf elf)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Generic_002dFunction-pick_002dbad_002dbad"></a><dl>
<dt><a name="index-pick_002dbad_002dbad"></a>Generic Function: <strong>pick-bad-bad</strong> <em>software &amp;key filter bad-pool &amp;allow-other-keys</em></dt>
<dd><p>Pick two &rsquo;bad&rsquo; indexes into a software object.
Used to target mutation.
</p></dd></dl>
<a name="Method-pick_002dbad_002dbad-_0028_0028clang-clang_0029-_0026key-filter-_0028bad_002dpool-_0023_0027bad_002dstmts_0029_0029"></a><dl>
<dt><a name="index-pick_002dbad_002dbad-1"></a>Method: <strong>pick-bad-bad</strong> <em>(clang clang) &amp;key filter (bad-pool (function bad-stmts))</em></dt>
<dd><p>Pick two ASTs from <code>clang</code>, both from the &lsquo;bad-asts&rsquo; pool,
excluding those ASTs removed by <code>filter</code>.
</p><ul>
<li> <code>clang</code> object to perform picks for
</li><li> <code>filter</code> function taking two AST parameters and returning non-nil if the
</li></ul>
<p>second should be included as a possible pick
* <code>bad-pool</code> function returning a pool of &rsquo;bad&rsquo; ASTs in <code>software</code>
</p></dd></dl>
<a name="Method-pick_002dbad_002dbad-_0028_0028software-parseable_0029-_0026key-filter-_0028bad_002dpool-_0023_0027bad_002dasts_0029_0029"></a><dl>
<dt><a name="index-pick_002dbad_002dbad-2"></a>Method: <strong>pick-bad-bad</strong> <em>(software parseable) &amp;key filter (bad-pool (function bad-asts))</em></dt>
<dd><p>Pick two ASTs from <code>software</code>, both from the &lsquo;bad-asts&rsquo; pool,
excluding those ASTs removed by <code>filter</code>.
</p><ul>
<li> <code>software</code> object to perform picks for
</li><li> <code>filter</code> function taking two AST parameters and returning non-nil if the
</li></ul>
<p>second should be included as a possible pick
* <code>bad-pool</code> function returning a pool of &rsquo;bad&rsquo; ASTs in <code>software</code>
</p></dd></dl>
<a name="Generic_002dFunction-pick_002dbad_002dgood"></a><dl>
<dt><a name="index-pick_002dbad_002dgood"></a>Generic Function: <strong>pick-bad-good</strong> <em>software &amp;key filter bad-pool good-pool &amp;allow-other-keys</em></dt>
<dd><p>Pick a &rsquo;bad&rsquo; and a &rsquo;good&rsquo; indexes into a software object.
Used to target mutation.
</p></dd></dl>
<a name="Method-pick_002dbad_002dgood-_0028_0028clang-clang_0029-_0026key-filter-_0028bad_002dpool-_0023_0027bad_002dstmts_0029-_0028good_002dpool-_0023_0027good_002dstmts_0029_0029"></a><dl>
<dt><a name="index-pick_002dbad_002dgood-1"></a>Method: <strong>pick-bad-good</strong> <em>(clang clang) &amp;key filter (bad-pool (function bad-stmts)) (good-pool (function good-stmts))</em></dt>
<dd><p>Pick two ASTs from <code>clang</code>, both from the &lsquo;bad-asts&rsquo; pool,
excluding those ASTs removed by <code>filter</code>.
</p><ul>
<li> <code>clang</code> object to perform picks for
</li><li> <code>filter</code> function taking two AST parameters and returning non-nil if the
</li></ul>
<p>second should be included as a possible pick
</p><ul>
<li> <code>bad-pool</code> function returning a pool of &rsquo;bad&rsquo; ASTs in <code>software</code>
</li><li> <code>good-pool</code> function returning a pool of &rsquo;good&rsquo; ASTs in <code>software</code>
</li></ul>
</dd></dl>
<a name="Method-pick_002dbad_002dgood-_0028_0028software-parseable_0029-_0026key-filter-_0028bad_002dpool-_0023_0027bad_002dasts_0029-_0028good_002dpool-_0023_0027good_002dasts_0029_0029"></a><dl>
<dt><a name="index-pick_002dbad_002dgood-2"></a>Method: <strong>pick-bad-good</strong> <em>(software parseable) &amp;key filter (bad-pool (function bad-asts)) (good-pool (function good-asts))</em></dt>
<dd><p>Pick two ASTs from <code>software</code>, first from &lsquo;bad-pool&rsquo; followed
by &lsquo;good-pool&rsquo;, excluding those ASTs removed by <code>filter</code>.
</p><ul>
<li> <code>software</code> object to perform picks for
</li><li> <code>filter</code> function taking two AST parameters and returning non-nil if the
</li></ul>
<p>second should be included as a possible pick
</p><ul>
<li> <code>bad-pool</code> function returning a pool of &rsquo;bad&rsquo; ASTs in <code>software</code>
</li><li> <code>good-pool</code> function returning a pool of &rsquo;good&rsquo; ASTs in <code>software</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-pick_002dbad_002donly"></a><dl>
<dt><a name="index-pick_002dbad_002donly"></a>Generic Function: <strong>pick-bad-only</strong> <em>software &amp;key filter bad-pool &amp;allow-other-keys</em></dt>
<dd><p>Pick a single &rsquo;bad&rsquo; index into a software object.
Used to target mutation.
</p></dd></dl>
<a name="Method-pick_002dbad_002donly-_0028_0028clang-clang_0029-_0026key-filter-_0028bad_002dpool-_0023_0027bad_002dstmts_0029_0029"></a><dl>
<dt><a name="index-pick_002dbad_002donly-1"></a>Method: <strong>pick-bad-only</strong> <em>(clang clang) &amp;key filter (bad-pool (function bad-stmts))</em></dt>
<dd><p>Pick a single AST from <code>clang</code> from &lsquo;bad-pool&rsquo;,
excluding those ASTs removed by <code>filter</code>.
</p><ul>
<li> <code>clang</code> object to perform picks for
</li><li> <code>filter</code> function taking two AST parameters and returning non-nil if the
</li></ul>
<p>second should be included as a possible pick
* <code>bad-pool</code> function returning a pool of &rsquo;bad&rsquo; ASTs in <code>software</code>
</p></dd></dl>
<a name="Method-pick_002dbad_002donly-_0028_0028software-parseable_0029-_0026key-filter-_0028bad_002dpool-_0023_0027bad_002dasts_0029_0029"></a><dl>
<dt><a name="index-pick_002dbad_002donly-2"></a>Method: <strong>pick-bad-only</strong> <em>(software parseable) &amp;key filter (bad-pool (function bad-asts))</em></dt>
<dd><p>Pick a single AST from <code>software</code> from &lsquo;bad-pool&rsquo;,
excluding those ASTs removed by <code>filter</code>.
</p><ul>
<li> <code>software</code> object to perform picks for
</li><li> <code>filter</code> function taking two AST parameters and returning non-nil if the
</li></ul>
<p>second should be included as a possible pick
* <code>bad-pool</code> function returning a pool of &rsquo;bad&rsquo; ASTs in <code>software</code>
</p></dd></dl>
<a name="Generic_002dFunction-pick_002dsnippet"></a><dl>
<dt><a name="index-pick_002dsnippet"></a>Generic Function: <strong>pick-snippet</strong> <em>clang-w-fodder &amp;key full class pt decl</em></dt>
<dd><p>Return a snippet from the fodder database.
</p>
<p>With keyword <code>:full</code> t, select a full statement element.
</p>
<p>With keyword argument <code>:class</code>, select an element of the specified class.
</p>
<p>With keyword argument <code>:pt</code> select an element similar to that at <code>:pt</code> in
<code>clang-w-fodder</code> in a method-dependent fashion.
</p>
<p>With keyword argument :decl select a declaration.
</p></dd></dl>
<a name="Method-pick_002dsnippet-_0028_0028obj-clang_002dw_002dfodder_0029-_0026key-full-class-pt-decl_0029"></a><dl>
<dt><a name="index-pick_002dsnippet-1"></a>Method: <strong>pick-snippet</strong> <em>(obj clang-w-fodder) &amp;key full class pt decl</em></dt>
<dd><p>Return a snippet from the fodder database.
</p><ul>
<li> <code>obj</code> software object to pick a fodder snippet for
</li><li> <code>full</code> select a full statement element if true
</li><li> <code>class</code> select an element of the specified class
</li><li> <code>pt</code> select an element similar to <code>pt</code> in <code>obj</code> in a method-dependent fashion
</li><li> <code>decl</code> select a decl AST if true
</li></ul>
</dd></dl>
<a name="Class-project"></a><dl>
<dt><a name="index-project"></a>Class: <strong>project</strong></dt>
<dd><p>Class precedence list: <code>project, software, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>build-command</code> &mdash; initarg: <code><span class="nolinebreak">:build-command</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:build-command</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:build-command)</span><!-- /@w --></code>

<p>Shell command to build the project.
</p></li><li> <code>artifacts</code> &mdash; initarg: <code>:artifacts<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:artifacts</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:artifacts)</span><!-- /@w --></code>

<p>Artifacts (e.g., executables) of the project build.
</p></li><li> <code>evolve-files</code> &mdash; initarg: <code><span class="nolinebreak">:evolve-files</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:evolve-files</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:evolve-files)</span><!-- /@w --></code>

<p>Files within the project to mutate.
This holds a list of cons cells of the form (path . software-object-for-path).
</p></li><li> <code>other-files</code> &mdash; initarg: <code><span class="nolinebreak">:other-files</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:other-files</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:other-files)</span><!-- /@w --></code>

<p>Source files which may be used (e.g., instrumented) but not evolved.
This holds a list of cons cells of the form (path . software-object-for-path).
</p></li></ul>

<p>A project is composed of multiple component software objects.
<code>e</code>.g., a multi-file C software project may include multiple clang
software objects in it&rsquo;s &lsquo;evolve-files&rsquo;.
</p></dd></dl>
<a name="Generic_002dFunction-random_002dpoint_002din_002dfunction"></a><dl>
<dt><a name="index-random_002dpoint_002din_002dfunction"></a>Generic Function: <strong>random-point-in-function</strong> <em>software prototype</em></dt>
<dd><p>Return the index of a random point in <code>prototype</code> in <code>software</code>.
If <code>prototype</code> has an empty function body in <code>software</code> return nil.
</p></dd></dl>
<a name="Method-random_002dpoint_002din_002dfunction-_0028_0028clang-clang_0029-function_0029"></a><dl>
<dt><a name="index-random_002dpoint_002din_002dfunction-1"></a>Method: <strong>random-point-in-function</strong> <em>(clang clang) function</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>clang</code> <code>docfixme</code>
</li><li> <code>function</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-reference"></a><dl>
<dt><a name="index-reference"></a>Generic Function: <strong>reference</strong> <em>software</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-reference-_0028_0028diff-diff_0029_0029"></a><dl>
<dt><a name="index-reference-1"></a>Method: <strong>reference</strong> <em>(diff diff)</em></dt>
<dd><p>automatically generated reader method
</p></dd></dl>
<a name="Method-reference-_0028_0028range-sw_002drange_0029_0029"></a><dl>
<dt><a name="index-reference-2"></a>Method: <strong>reference</strong> <em>(range sw-range)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Generic_002dFunction-_0028setf-reference_0029"></a><dl>
<dt><a name="index-_0028setf-reference_0029"></a>Generic Function: <strong>(setf reference)</strong> <em>software new</em></dt>
<dd><p>Set the value of <code>reference</code> to <code>new</code>, and update the <code>genome</code>.
</p></dd></dl>
<a name="Method-_0028setf-reference_0029-_0028new_002dvalue-_0028diff-diff_0029_0029"></a><dl>
<dt><a name="index-_0028setf-reference_0029-1"></a>Method: <strong>(setf reference)</strong> <em>new-value (diff diff)</em></dt>
<dd><p>automatically generated writer method
</p></dd></dl>
<a name="Method-_0028setf-reference_0029-_0028new-_0028range-sw_002drange_0029_0029"></a><dl>
<dt><a name="index-_0028setf-reference_0029-2"></a>Method: <strong>(setf reference)</strong> <em>new (range sw-range)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Class-refine_002dcondition"></a><dl>
<dt><a name="index-refine_002dcondition"></a>Class: <strong>refine-condition</strong></dt>
<dd><p>Class precedence list: <code>refine-condition, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Add an additional Boolean clause to an if condition.
</p></dd></dl>
<a name="Class-software"></a><dl>
<dt><a name="index-software"></a>Class: <strong>software</strong></dt>
<dd><p>Class precedence list: <code>software, standard-object, t</code>
</p>
<p>Base class for all software objects.
</p></dd></dl>
<a name="Class-test_002dsuite"></a><dl>
<dt><a name="index-test_002dsuite-1"></a>Class: <strong>test-suite</strong></dt>
<dd><p>Class precedence list: <code>test-suite, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>test-cases</code> &mdash; initarg: <code><span class="nolinebreak">:test-cases</span><!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:test-cases</span><!-- /@w --></code>; writer: <code>(setf&nbsp;<span class="nolinebreak">software-evolution-library:test-cases)</span><!-- /@w --></code>

<p>List of &lsquo;test-case&rsquo; objects that make up the test suite.
</p></li></ul>

<p>A suite of unit tests.
</p></dd></dl>
<a name="Variable-_002aclang_002dw_002dfodder_002dmutation_002dtypes_002a"></a><dl>
<dt><a name="index-_002aclang_002dw_002dfodder_002dmutation_002dtypes_002a"></a>Variable: <strong>*clang-w-fodder-mutation-types*</strong></dt>
<dd><p>Cumulative distribution of normalized probabilities of weighted mutations.
Currently the weights are assigned so that we roughly preserve the
total fraction of decl, swap, and cut mutations from
&lsquo;*clang-mutation-types*&rsquo;.  By contrast the fraction of insert, swap,
and replace mutations are decreased precipitously to make room for the
new fodder mutations.  Fodder mutations make up 2/5 of all
mutations.
</p></dd></dl>
<a name="Generic_002dFunction-evaluate"></a><dl>
<dt><a name="index-evaluate"></a>Generic Function: <strong>evaluate</strong> <em>function software &amp;rest extra-keys &amp;key &amp;allow-other-keys</em></dt>
<dd><p>Evaluate the software returning a numerical fitness.
</p></dd></dl>
<a name="Method-evaluate-_0028phenome-_0028test_002dsuite-test_002dsuite_0029-_0026rest-extra_002dkeys-_0026key-_0026allow_002dother_002dkeys_0029"></a><dl>
<dt><a name="index-evaluate-1"></a>Method: <strong>evaluate</strong> <em>phenome (test-suite test-suite) &amp;rest extra-keys &amp;key &amp;allow-other-keys</em></dt>
<dd><p>Evaluate all test-cases in <code>test-suite</code> aggregating their output.
By default, sum the results of applying &lsquo;evaluate&rsquo; to each test-case using
&lsquo;reduce&rsquo;. Keyword arguments &lsquo;:function&rsquo; and &lsquo;:initial-value&rsquo; may be used as in
&lsquo;reduce&rsquo; to specify an aggregation function and starting value.
</p></dd></dl>
<a name="Method-evaluate-_0028phenome-_0028obj-test_002dcase_0029-_0026rest-extra_002dkeys-_0026key-_0026allow_002dother_002dkeys_0029"></a><dl>
<dt><a name="index-evaluate-2"></a>Method: <strong>evaluate</strong> <em>phenome (obj test-case) &amp;rest extra-keys &amp;key &amp;allow-other-keys</em></dt>
<dd><p>Run &lsquo;test-case&rsquo; <code>obj</code> on <code>phenome</code> and return a fitness score (as
opposed to the output and exit code returned by &lsquo;finish-test&lsquo;).
Default behavior is to return 1 if the exit code is 0 and 0 otherwise.
</p>
<p>Override this method if you want to use other criteria, such as
test output, to determine the fitness score.
</p>
<ul>
<li> <code>phenome</code> the phenome of the &lsquo;software&rsquo; object under test.

</li><li> <code>obj</code> the &lsquo;test-case&rsquo; to run.

</li><li> <code>extra-keys</code> additional keyword arguments to pass to &lsquo;run-test&rsquo;. See the
</li></ul>
<p>&lsquo;start-test&rsquo; documentation for more information.
</p></dd></dl>
<a name="Method-evaluate-_0028_0028test-function_0029-_0028super-super_002dmutant_0029-_0026rest-extra_002dkeys-_0026key-_0026allow_002dother_002dkeys_0029"></a><dl>
<dt><a name="index-evaluate-3"></a>Method: <strong>evaluate</strong> <em>(test function) (super super-mutant) &amp;rest extra-keys &amp;key &amp;allow-other-keys</em></dt>
<dd><p>Evaluate <code>super-mutant</code>, setting fitness for all variants.
</p></dd></dl>
<a name="Method-evaluate-_0028_0028test-symbol_0029-_0028asm_002dsuper-asm_002dsuper_002dmutant_0029-_0026rest-extra_002dkeys-_0026key-_0026allow_002dother_002dkeys_0029"></a><dl>
<dt><a name="index-evaluate-4"></a>Method: <strong>evaluate</strong> <em>(test symbol) (asm-super asm-super-mutant) &amp;rest extra-keys &amp;key &amp;allow-other-keys</em></dt>
<dd><p>Create phenome (binary executable) and call it to generate fitness results.
The variants need to already be created (stored in mutants slot) and the io-file
needs to have been loaded, along with the var-table by <code>parse-sanity-file</code>.
</p></dd></dl>
<a name="Macro-sequence_002dmutations"></a><dl>
<dt><a name="index-sequence_002dmutations"></a>Macro: <strong>sequence-mutations</strong> <em>class-name mut-a mut-b &amp;rest options</em></dt>
<dd><p>Define a new mutation named <code>class-name</code> sequencing <code>mut-a</code> and <code>mut-b</code>.
<code>mut-a</code> and <code>mut-b</code> are instances of mutations.  Instead of collecting
targets for A and then targets for <code>b</code> and then applying A and <code>b</code> as done
by &lsquo;compose-mutations&rsquo;, &lsquo;sequence-mutations&rsquo; first targets and applies A and then targets and applied <code>b</code>.
</p></dd></dl>
<a name="Function-create_002dtarget"></a><dl>
<dt><a name="index-create_002dtarget"></a>Function: <strong>create-target</strong> <em>asm-super</em></dt>
<dd><p>Returns an <code>asm-heap</code> software object which contains only the target lines.
</p></dd></dl>
<a name="Function-load_002dio_002dfile"></a><dl>
<dt><a name="index-load_002dio_002dfile"></a>Function: <strong>load-io-file</strong> <em>super-asm filename</em></dt>
<dd><p>Load the file containing input and output state information
</p></dd></dl>
<a name="Function-make_002dif_002dstmt"></a><dl>
<dt><a name="index-make_002dif_002dstmt"></a>Function: <strong>make-if-stmt</strong> <em>condition then &amp;optional else &amp;rest rest</em></dt>
<dd><p>Create an if statement AST.
</p><ul>
<li> <code>condition</code> ast for the if statement conditional
</li><li> <code>then</code> ast for the if statement then body
</li><li> <code>else</code> optional ast for the if statement else
</li><li> <code>rest</code> optional additional arguments to &lsquo;make-statement&rsquo;
</li></ul>
</dd></dl>
<a name="Function-pareto_002dselector"></a><dl>
<dt><a name="index-pareto_002dselector"></a>Function: <strong>pareto-selector</strong> <em>candidates &amp;key predicate comparison-set</em></dt>
<dd><p>Return members of <code>candidates</code> which dominate a random <code>comparison-set</code>.
</p>
<p>Set &lsquo;*tournament-selector*&rsquo; to &lsquo;pareto-selector&rsquo; to use Pareto selection in
tournaments.
</p></dd></dl>
<a name="Function-pick_002dleast_002dcrowded"></a><dl>
<dt><a name="index-pick_002dleast_002dcrowded"></a>Function: <strong>pick-least-crowded</strong> <em>candidates &amp;key predicate</em></dt>
<dd><p>Pick candidate with the greatest crowding distance.
</p>
<p>Crowding distance is a fitness sharing metric adapted from <code>nsga-ii</code>. For each
fitness component, it sums the distance between an individual and its nearest
neighbors. Individuals with the greater crowding distance are in sparse areas of
the fitness landscape and should be preferred.
</p></dd></dl>
<a name="Generic_002dFunction-pick_002dmutation_002dtype"></a><dl>
<dt><a name="index-pick_002dmutation_002dtype"></a>Generic Function: <strong>pick-mutation-type</strong> <em>software</em></dt>
<dd><p>Select a type of mutation to apply to <code>software</code>.
</p></dd></dl>
<a name="Method-pick_002dmutation_002dtype-_0028_0028obj-coq_0029_0029"></a><dl>
<dt><a name="index-pick_002dmutation_002dtype-1"></a>Method: <strong>pick-mutation-type</strong> <em>(obj coq)</em></dt>
<dd><p>Randomly select a mutation that may be performed on <code>obj</code>.
</p></dd></dl>
<a name="Method-pick_002dmutation_002dtype-_0028_0028obj-clang_002dw_002dfodder_0029_0029"></a><dl>
<dt><a name="index-pick_002dmutation_002dtype-2"></a>Method: <strong>pick-mutation-type</strong> <em>(obj clang-w-fodder)</em></dt>
<dd><p>Select type of mutation to apply to <code>obj</code>.
</p></dd></dl>
<a name="Method-pick_002dmutation_002dtype-_0028_0028obj-clang_0029_0029"></a><dl>
<dt><a name="index-pick_002dmutation_002dtype-3"></a>Method: <strong>pick-mutation-type</strong> <em>(obj clang)</em></dt>
<dd><p>Select type of mutation to apply to <code>obj</code>.
</p></dd></dl>
<a name="Method-pick_002dmutation_002dtype-_0028_0028asm-asm_0029_0029"></a><dl>
<dt><a name="index-pick_002dmutation_002dtype-4"></a>Method: <strong>pick-mutation-type</strong> <em>(asm asm)</em></dt>
<dd><p>Return a symbol naming a randomly selected ASM mutation.
</p></dd></dl>
<a name="Method-pick_002dmutation_002dtype-_0028_0028obj-expression_0029_0029"></a><dl>
<dt><a name="index-pick_002dmutation_002dtype-5"></a>Method: <strong>pick-mutation-type</strong> <em>(obj expression)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-pick_002dmutation_002dtype-_0028_0028obj-lisp_0029_0029"></a><dl>
<dt><a name="index-pick_002dmutation_002dtype-6"></a>Method: <strong>pick-mutation-type</strong> <em>(obj lisp)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-pick_002dmutation_002dtype-_0028_0028obj-simple_0029_0029"></a><dl>
<dt><a name="index-pick_002dmutation_002dtype-7"></a>Method: <strong>pick-mutation-type</strong> <em>(obj simple)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Function-prepare_002dfodder"></a><dl>
<dt><a name="index-prepare_002dfodder"></a>Function: <strong>prepare-fodder</strong> <em>obj database snippet pt</em></dt>
<dd><p>Prepare <code>snippet</code> for insertion into <code>obj</code> at <code>pt</code>.
</p><ul>
<li> <code>obj</code> clang software object to be injected with <code>snippet</code>
</li><li> <code>database</code> fodder database containing snippet
</li><li> <code>snippet</code> fodder snippet to inject
</li><li> <code>pt</code> point where fodder snippet is to be injected
</li></ul>
</dd></dl>
<a name="Function-reset_002dancestry_002did"></a><dl>
<dt><a name="index-reset_002dancestry_002did"></a>Function: <strong>reset-ancestry-id</strong></dt>
<dd><p>Reset the ancestry <code>id</code>.
</p></dd></dl>
<a name="Generic_002dFunction-reset_002dand_002dload_002dimports"></a><dl>
<dt><a name="index-reset_002dand_002dload_002dimports"></a>Generic Function: <strong>reset-and-load-imports</strong> <em>coq &amp;key imports</em></dt>
<dd><p>Reset the SerAPI process and load <code>imports</code> for <code>coq</code> software object.
</p></dd></dl>
<a name="Method-reset_002dand_002dload_002dimports-_0028_0028project-coq_002dproject_0029-_0026key-imports_0029"></a><dl>
<dt><a name="index-reset_002dand_002dload_002dimports-1"></a>Method: <strong>reset-and-load-imports</strong> <em>(project coq-project) &amp;key imports</em></dt>
<dd><p>Reset the SerAPI process and load <code>imports</code> for each Coq object in <code>project</code>.
If <code>imports</code> is <code>nil</code>, it defaults to the list of &lsquo;imports&rsquo; for each Coq object in
<code>project</code>.
</p></dd></dl>
<a name="Method-reset_002dand_002dload_002dimports-_0028_0028obj-coq_0029-_0026key-_0028imports-_0028imports-obj_0029_0029_0029"></a><dl>
<dt><a name="index-reset_002dand_002dload_002dimports-2"></a>Method: <strong>reset-and-load-imports</strong> <em>(obj coq) &amp;key (imports (imports obj))</em></dt>
<dd><p>Reset the SerAPI process and load <code>imports</code> for <code>coq</code> software object.
<code>imports</code> defaults to the list of &lsquo;imports&rsquo; in <code>coq</code>.
</p></dd></dl>
<a name="Function-rinard"></a><dl>
<dt><a name="index-rinard"></a>Function: <strong>rinard</strong> <em>count obj stmt-counts</em></dt>
<dd><p>Spectrum-based fault localization from <code>spr</code> and Prophet.
</p><ul>
<li> <code>count</code> size of prioritized list to return
</li><li> <code>obj</code> software object under test
</li><li> <code>stmt-counts</code> aggregated trace results, collected from &lsquo;rinard-incremental&rsquo;
</li></ul>
</dd></dl>
<a name="Function-rinard_002dcompare"></a><dl>
<dt><a name="index-rinard_002dcompare"></a>Function: <strong>rinard-compare</strong> <em>a b</em></dt>
<dd><p>Return non-nil if A is more suspicious than <code>b</code>.
</p></dd></dl>
<a name="Function-rinard_002dread_002din"></a><dl>
<dt><a name="index-rinard_002dread_002din"></a>Function: <strong>rinard-read-in</strong> <em>path</em></dt>
<dd><p>Read in previously-written fault localization info.
</p><ul>
<li> <code>path</code> full system path to read in from, previously
       written out by &lsquo;rinard-write-out&rsquo;.
</li></ul>
</dd></dl>
<a name="Function-rinard_002dwrite_002dout"></a><dl>
<dt><a name="index-rinard_002dwrite_002dout"></a>Function: <strong>rinard-write-out</strong> <em>path data</em></dt>
<dd><p>Write out fault localization to speed up subsequent trials.
</p>
<ul>
<li> <code>path</code> full system path to write to.
</li><li> <code>data</code> fault loc data, as returned by &lsquo;rinard&rsquo;.
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-roots"></a><dl>
<dt><a name="index-roots"></a>Generic Function: <strong>roots</strong> <em>obj</em></dt>
<dd><p>Return all top-level ASTs in <code>obj</code>.
</p></dd></dl>
<a name="Method-roots-_0028_0028asts-list_0029_0029"></a><dl>
<dt><a name="index-roots-1"></a>Method: <strong>roots</strong> <em>(asts list)</em></dt>
<dd><p>Return all top-level ASTs in <code>asts</code>.
* <code>asts</code> list of ASTs to search for roots
</p></dd></dl>
<a name="Method-roots-_0028_0028obj-parseable_0029_0029"></a><dl>
<dt><a name="index-roots-2"></a>Method: <strong>roots</strong> <em>(obj parseable)</em></dt>
<dd><p>Return all top-level ASTs in <code>obj</code>.
* <code>obj</code> software object to search for roots
</p></dd></dl>
<a name="Generic_002dFunction-run_002dtest"></a><dl>
<dt><a name="index-run_002dtest"></a>Generic Function: <strong>run-test</strong> <em>phenome test-case &amp;rest extra-keys &amp;key &amp;allow-other-keys</em></dt>
<dd><p>Run <code>test-case</code> on <code>phenome</code> and return the results.
Return the standard output, error output, and process exit code as strings.
</p></dd></dl>
<a name="Method-run_002dtest-_0028phenome-_0028test_002dcase-test_002dcase_0029-_0026rest-extra_002dkeys-_0026key-_0026allow_002dother_002dkeys_0029"></a><dl>
<dt><a name="index-run_002dtest-1"></a>Method: <strong>run-test</strong> <em>phenome (test-case test-case) &amp;rest extra-keys &amp;key &amp;allow-other-keys</em></dt>
<dd><p>Run <code>test-case</code> on <code>phenome</code> and return the results.
Return three values: output printed to standard out, error output, and exit
status. Th default behavior is simply to run &lsquo;start-test&rsquo; and &lsquo;finish-test&rsquo;.
</p></dd></dl>
<a name="Generic_002dFunction-select_002dcrossover_002dpoints"></a><dl>
<dt><a name="index-select_002dcrossover_002dpoints"></a>Generic Function: <strong>select-crossover-points</strong> <em>a b</em></dt>
<dd><p>Select suitable crossover points in A and <code>b</code>.
If no suitable points are found the returned points may be nil.
</p></dd></dl>
<a name="Method-select_002dcrossover_002dpoints-_0028_0028a-clang_0029-_0028b-clang_0029_0029"></a><dl>
<dt><a name="index-select_002dcrossover_002dpoints-1"></a>Method: <strong>select-crossover-points</strong> <em>(a clang) (b clang)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> A <code>docfixme</code>
</li><li> <code>b</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-select_002dintraprocedural_002dpair"></a><dl>
<dt><a name="index-select_002dintraprocedural_002dpair"></a>Generic Function: <strong>select-intraprocedural-pair</strong> <em>software</em></dt>
<dd><p>Randomly select an AST within a function body and then select
another point within the same function.  If there are no ASTs
within a function body, return null.
</p></dd></dl>
<a name="Method-select_002dintraprocedural_002dpair-_0028_0028clang-clang_0029_0029"></a><dl>
<dt><a name="index-select_002dintraprocedural_002dpair-1"></a>Method: <strong>select-intraprocedural-pair</strong> <em>(clang clang)</em></dt>
<dd><p><code>docfixme</code>
* <code>clang</code> <code>docfixme</code>
</p></dd></dl>
<a name="Generic_002dFunction-similar_002dsnippets"></a><dl>
<dt><a name="index-similar_002dsnippets"></a>Generic Function: <strong>similar-snippets</strong> <em>searchable target &amp;key predicate metric key limit ast-class limit-considered filter</em></dt>
<dd><p>Return snippets from <code>searchable</code> similar to <code>target</code>
</p><ul>
<li> <code>searchable</code> <code>docfixme</code>
</li><li> <code>target</code> <code>docfixme</code>
</li><li> <code>:predicate</code> predicate for similarity metric
</li><li> <code>:metric</code> a function to generate a similarity metric
</li><li> <code>:key</code> a function called on each snippet before metric
</li><li> <code>:limit</code> only return the <code>many</code> most similar snippets
</li><li> <code>:ast-class</code> only consider snippets matching this AST class
</li><li> <code>:limit-considered</code>  limit search to <code>many-considered</code> random snippets
</li><li> <code>:filter</code> limit search to snippets for which <code>filter</code> returns false
</li></ul>
</dd></dl>
<a name="Method-similar_002dsnippets-_0028_0028obj-pliny_002ddatabase_0029-target-_0026key-predicate-metric-key-ast_002dclass-limit_002dconsidered-_0028limit-_0028_002d-_0028expt-2-32_0029-1_0029_0029-_0028filter-_0023_0027null_0029_0029"></a><dl>
<dt><a name="index-similar_002dsnippets-1"></a>Method: <strong>similar-snippets</strong> <em>(obj pliny-database) target &amp;key predicate metric key ast-class limit-considered (limit (- (expt 2 32) 1)) (filter (function null))</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> <code>predicate</code> <code>docfixme</code>
</li><li> <code>metric</code> <code>docfixme</code>
</li><li> <code>key</code> <code>docfixme</code>
</li><li> <code>ast-class</code> <code>docfixme</code>
</li><li> <code>limit-considered</code> <code>docfixme</code>
</li><li> <code>limit</code> <code>docfixme</code>
</li><li> <code>filter</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-similar_002dsnippets-_0028_0028db-searchable_0029-target-_0026key-key-ast_002dclass-limit-_0028predicate-_0023_0027_003c_0029-_0028metric-_0023_0027diff_002dscalar_0029-_0028filter-_0023_0027null_0029-_0028limit_002dconsidered-infinity_0029_0029"></a><dl>
<dt><a name="index-similar_002dsnippets-2"></a>Method: <strong>similar-snippets</strong> <em>(db searchable) target &amp;key key ast-class limit (predicate (function &lt;)) (metric (function diff-scalar)) (filter (function null)) (limit-considered infinity)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Generic_002dFunction-size"></a><dl>
<dt><a name="index-size"></a>Generic Function: <strong>size</strong> <em>software</em></dt>
<dd><p>Return the size of the &lsquo;genome&rsquo; of <code>software</code>.
</p></dd></dl>
<a name="Method-size-_0028_0028db-in_002dmemory_002ddatabase_0029_0029"></a><dl>
<dt><a name="index-size-1"></a>Method: <strong>size</strong> <em>(db in-memory-database)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-size-_0028_0028obj-project_0029_0029"></a><dl>
<dt><a name="index-size-2"></a>Method: <strong>size</strong> <em>(obj project)</em></dt>
<dd><p>Return summed size across all &lsquo;evolve-files&rsquo;.
</p></dd></dl>
<a name="Method-size-before-_0028_0028obj-parseable_0029_0029"></a><dl>
<dt><a name="index-before-size"></a>Method: <strong>before size</strong> <em>(obj parseable)</em></dt>
<dd><p>Ensure the &lsquo;asts&rsquo; field is set on <code>obj</code> prior to access.
</p></dd></dl>
<a name="Method-size-_0028_0028obj-parseable_0029_0029"></a><dl>
<dt><a name="index-size-3"></a>Method: <strong>size</strong> <em>(obj parseable)</em></dt>
<dd><p>Return the number of ASTs in <code>obj</code>.
</p></dd></dl>
<a name="Method-size-_0028_0028obj-source_0029_0029"></a><dl>
<dt><a name="index-size-4"></a>Method: <strong>size</strong> <em>(obj source)</em></dt>
<dd><p>Return the size of <code>obj</code>
</p></dd></dl>
<a name="Method-size-_0028_0028asm-asm_002dheap_0029_0029"></a><dl>
<dt><a name="index-size-5"></a>Method: <strong>size</strong> <em>(asm asm-heap)</em></dt>
<dd><p>Return the number of lines in the program.
</p></dd></dl>
<a name="Method-size-_0028_0028lisp-lisp_0029_0029"></a><dl>
<dt><a name="index-size-6"></a>Method: <strong>size</strong> <em>(lisp lisp)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-size-_0028_0028range-sw_002drange_0029_0029"></a><dl>
<dt><a name="index-size-7"></a>Method: <strong>size</strong> <em>(range sw-range)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-size-_0028_0028obj-simple_0029_0029"></a><dl>
<dt><a name="index-size-8"></a>Method: <strong>size</strong> <em>(obj simple)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Generic_002dFunction-start_002dtest"></a><dl>
<dt><a name="index-start_002dtest"></a>Generic Function: <strong>start-test</strong> <em>phenome test-case &amp;rest extra-keys &amp;key &amp;allow-other-keys</em></dt>
<dd><p>Start an external process to run <code>test-case</code> on <code>phenome</code>.
Return the &lsquo;process&rsquo;.
</p>
<ul>
<li> <code>phenome</code> the phenome of the &lsquo;software&rsquo; object under test.
</li><li> <code>test-case</code> the &lsquo;test-case&rsquo; to run.
</li><li> <code>extra-keys</code> additional keyword arguments.
</li></ul>
</dd></dl>
<a name="Method-start_002dtest-_0028phenome-_0028test_002dcase-test_002dcase_0029-_0026rest-extra_002dkeys-_0026key-_0026allow_002dother_002dkeys_0029"></a><dl>
<dt><a name="index-start_002dtest-1"></a>Method: <strong>start-test</strong> <em>phenome (test-case test-case) &amp;rest extra-keys &amp;key &amp;allow-other-keys</em></dt>
<dd><p>Start an external process to run <code>test-case</code> on <code>phenome</code>.
Return the &lsquo;process&rsquo;. This is a wrapper around &lsquo;uiop:launch-program&rsquo;, and any
<code>extra-keys</code> will be passed through to that method.
</p>
<ul>
<li> <code>phenome</code> the phenome of the &lsquo;software&rsquo; object under test.
</li><li> <code>test-case</code> the &lsquo;test-case&rsquo; to run.
</li><li> <code>extra-keys</code> additional keyword arguments to pass to &lsquo;uiop:launch-program&rsquo;.

</li></ul>
<p>Some <code>extra-keys</code> that may be useful are:
</p><ul>
<li> :output and :error-output <code>-</code> to specify how output and error streams are
  handled. In some cases, these are sent to /dev/null by default, making 
  inaccessible after the process completes, so it&rsquo;s often useful to set one or
  both of these to &lsquo;:stream&rsquo; to capture the output.

</li><li> :wait <code>-</code> whether to wait for the process to complete before continuing.
  The default is to wait; however, some components (such as &lsquo;traceable&rsquo;) may
  elect not to wait and instead to stream results through a named pipe.

</li><li> :env <code>-</code> to set environment variables
</li></ul>
</dd></dl>
<a name="Condition-trace_002derror"></a><dl>
<dt><a name="index-trace_002derror"></a>Condition: <strong>trace-error</strong></dt>
<dd><p>Class precedence list: <code>trace-error, error, serious-condition, condition, t</code>
</p>
<p>Error thrown when trace collection fails unexpectedly
</p></dd></dl>
<a name="Class-rename_002dvariable"></a><dl>
<dt><a name="index-rename_002dvariable"></a>Class: <strong>rename-variable</strong></dt>
<dd><p>Class precedence list: <code>rename-variable, clang-mutation, mutation, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Replace a variable in a statement with another in scope variable name.
</p></dd></dl>
<a name="Class-searchable"></a><dl>
<dt><a name="index-searchable"></a>Class: <strong>searchable</strong></dt>
<dd><p>Class precedence list: <code>searchable, standard-object, t</code>
</p>
<p><code>docfixme</code>
</p></dd></dl>
<a name="Class-sw_002drange"></a><dl>
<dt><a name="index-sw_002drange"></a>Class: <strong>sw-range</strong></dt>
<dd><p>Class precedence list: <code>sw-range, simple, software, standard-object, t</code>
</p>
<p>Alternative to <code>simple</code> software objects which should use less memory.
Instead of directly holding code in the <code>genome</code>, each <code>genome</code> is a list
of range references to an external <code>reference</code> code array.
</p></dd></dl>
<a name="Function-get_002dfresh_002dancestry_002did"></a><dl>
<dt><a name="index-get_002dfresh_002dancestry_002did"></a>Function: <strong>get-fresh-ancestry-id</strong></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Function-merge_002dnormalized"></a><dl>
<dt><a name="index-merge_002dnormalized"></a>Function: <strong>merge-normalized</strong> <em>vec1 denom1 vec2 denom2</em></dt>
<dd><p>Merge two vectors VEC1 and VEC2 which have been normalized using the
denominators DENOM1 and DENOM2, respectively
</p><ul>
<li> VEC1 normalized vector of numeric values
</li><li> DENOM1 denominator used to normalize VEC1
</li><li> VEC2 normalized vector of numeric values
</li><li> DENOM2 denominator used to normalize VEC2
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-merge_002dstyleables"></a><dl>
<dt><a name="index-merge_002dstyleables"></a>Generic Function: <strong>merge-styleables</strong> <em>styleable1 styleable2 &amp;key result</em></dt>
<dd><p>Merge all feature vectors from STYLEABLE1 and STYLEABLE2.
Update and return <code>result</code> to be a &lsquo;styleable&rsquo; object containing the merged
feature vectors and metadata.
</p></dd></dl>
<a name="Method-merge_002dstyleables-_0028_0028style1-styleable_0029-_0028style2-styleable_0029-_0026key-_0028result-_0028make_002dinstance-_0027styleable_0029_0029_0029"></a><dl>
<dt><a name="index-merge_002dstyleables-1"></a>Method: <strong>merge-styleables</strong> <em>(style1 styleable) (style2 styleable) &amp;key (result (make-instance (quote styleable)))</em></dt>
<dd><p>Merge all feature vectors from STYLE1 and STYLE2. Update and return <code>result</code>
to be a &lsquo;styleable&rsquo; object containing the merged feature vectors and metadata.
</p><ul>
<li> STYLE1 a styleable software object
</li><li> STYLE2 a styleable software object
</li><li> <code>result</code> a styleable software object in which to save merged vectors. May be
</li></ul>
<p>&lsquo;eq&rsquo; to STYLE1 or STYLE2.
</p></dd></dl>
<a name="Function-multi_002dobjective_002dscalar"></a><dl>
<dt><a name="index-multi_002dobjective_002dscalar"></a>Function: <strong>multi-objective-scalar</strong> <em>fitness</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Generic_002dFunction-pick_002dguarded_002dcompound"></a><dl>
<dt><a name="index-pick_002dguarded_002dcompound"></a>Generic Function: <strong>pick-guarded-compound</strong> <em>software</em></dt>
<dd><p>Pick a guarded compound statement in <code>software</code>.
</p></dd></dl>
<a name="Method-pick_002dguarded_002dcompound-_0028_0028obj-clang_0029_0029"></a><dl>
<dt><a name="index-pick_002dguarded_002dcompound-1"></a>Method: <strong>pick-guarded-compound</strong> <em>(obj clang)</em></dt>
<dd><p>Return a guarded statement in <code>obj</code> from the &lsquo;bad-stmts&rsquo; pool.
* <code>obj</code> software object to pick from
</p></dd></dl>
<a name="Function-random_002dfunction_002dname"></a><dl>
<dt><a name="index-random_002dfunction_002dname"></a>Function: <strong>random-function-name</strong> <em>protos &amp;key original-name arity</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>protos</code> <code>docfixme</code>
</li><li> <code>original-name</code> <code>docfixme</code>
</li><li> <code>arity</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-replace_002din_002dast"></a><dl>
<dt><a name="index-replace_002din_002dast"></a>Generic Function: <strong>replace-in-ast</strong> <em>ast replacements &amp;key test</em></dt>
<dd><p>Make arbitrary replacements within AST, returning a new
AST.
</p></dd></dl>
<a name="Method-replace_002din_002dast-_0028_0028ast-string_0029-replacements-_0026key-_0028test-_0023_0027equalp_0029_0029"></a><dl>
<dt><a name="index-replace_002din_002dast-1"></a>Method: <strong>replace-in-ast</strong> <em>(ast string) replacements &amp;key (test (function equalp))</em></dt>
<dd><p>Make arbritrary replacements within AST, returning a new AST.
</p><ul>
<li> AST node to perform modifications to
</li><li> <code>replacements</code> association list of key, value pairs to replace in AST
</li><li> <code>test</code> function to test if a given replacement key can be found in AST
</li></ul>
</dd></dl>
<a name="Method-replace_002din_002dast-_0028_0028ast-ast_0029-replacements-_0026key-_0028test-_0023_0027equalp_0029_0029"></a><dl>
<dt><a name="index-replace_002din_002dast-2"></a>Method: <strong>replace-in-ast</strong> <em>(ast ast) replacements &amp;key (test (function equalp))</em></dt>
<dd><p>Make arbritrary replacements within AST, returning a new AST.
</p><ul>
<li> AST node to perform modifications to
</li><li> <code>replacements</code> association list of key, value pairs to replace in AST
</li><li> <code>test</code> function to test if a given replacement key can be found in AST
</li></ul>
</dd></dl>
<a name="Function-rinard_002dincremental"></a><dl>
<dt><a name="index-rinard_002dincremental"></a>Function: <strong>rinard-incremental</strong> <em>trace-stream stmt-counts is-good-trace cur_test</em></dt>
<dd><p>Process a single trace&rsquo;s output, return the aggregated results.
</p><ul>
<li> <code>trace-stream</code> an open file representing the trace result, generally
        with statments of the form (<code>(f . x) </code>(C . Y)) where <code>x</code> is the
        file id and <code>y</code> is the statement id
</li><li> <code>stmt-counts</code> aggregated results, returned from this function
</li><li> <code>is-good-trace</code> test outcome was positive/negative
</li><li> CUR_TEST unique test identifier
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-scopes"></a><dl>
<dt><a name="index-scopes"></a>Generic Function: <strong>scopes</strong> <em>software ast</em></dt>
<dd><p>Return lists of variables in each enclosing scope.
Each variable is represented by an alist containing <code>:name</code>, <code>:decl</code>, <code>:type</code>,
and <code>:scope</code>.
</p></dd></dl>
<a name="Method-scopes-_0028_0028software-clang_0029-_0028ast-clang_002dast_0029_0029"></a><dl>
<dt><a name="index-scopes-1"></a>Method: <strong>scopes</strong> <em>(software clang) (ast clang-ast)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>software</code> <code>docfixme</code>
</li><li> AST <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Function-simple_002devaluate"></a><dl>
<dt><a name="index-simple_002devaluate"></a>Function: <strong>simple-evaluate</strong> <em>test new-children</em></dt>
<dd><p>Evaluate <code>new-children</code> using <code>test</code> assigning each a fitness.
</p></dd></dl>
<a name="Function-simple_002dreproduce"></a><dl>
<dt><a name="index-simple_002dreproduce"></a>Function: <strong>simple-reproduce</strong> <em>population</em></dt>
<dd><p>Reproduce using every individual in <code>population</code>.
Return a list of the resulting children and as optional extra value a
list of the mutations applied to produce those children.
</p></dd></dl>
<a name="Generic_002dFunction-source_002dtext"></a><dl>
<dt><a name="index-source_002dtext"></a>Generic Function: <strong>source-text</strong> <em>ast</em></dt>
<dd><p>Source code corresponding to an AST.
</p></dd></dl>
<a name="Method-source_002dtext-_0028_0028str-string_0029_0029"></a><dl>
<dt><a name="index-source_002dtext-1"></a>Method: <strong>source-text</strong> <em>(str string)</em></dt>
<dd><p>Return the source code corresponding to <code>str</code>.
* <code>str</code> string to retrieve source code for
</p></dd></dl>
<a name="Method-source_002dtext-_0028_0028node-ast_002dnode_0029_0029"></a><dl>
<dt><a name="index-source_002dtext-2"></a>Method: <strong>source-text</strong> <em>(node ast-node)</em></dt>
<dd><p>Return a source text representation of a single, immutable,
AST node.
</p></dd></dl>
<a name="Method-source_002dtext-_0028_0028ast-ast_0029_0029"></a><dl>
<dt><a name="index-source_002dtext-3"></a>Method: <strong>source-text</strong> <em>(ast ast)</em></dt>
<dd><p>Return the source code corresponding to AST.
* AST ast to retrieve source code for
</p></dd></dl>
<a name="Generic_002dFunction-stmt_002drange"></a><dl>
<dt><a name="index-stmt_002drange"></a>Generic Function: <strong>stmt-range</strong> <em>software function</em></dt>
<dd><p>The indices of the first and last statements in a function.
</p>
<p>Return as a list of (first-index last-index). Indices are positions in
the list returned by (asts software).
</p></dd></dl>
<a name="Method-stmt_002drange-_0028_0028software-clang_0029-_0023_0027clang_002dast_0029"></a><dl>
<dt><a name="index-stmt_002drange-1"></a>Method: <strong>stmt-range</strong> <em>(software clang) (function clang-ast)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>software</code> <code>docfixme</code>
</li><li> <code>function</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Function-stmts_002din_002dfile"></a><dl>
<dt><a name="index-stmts_002din_002dfile"></a>Function: <strong>stmts-in-file</strong> <em>trace file-id</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>trace</code> <code>docfixme</code>
</li><li> <code>file-id</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Function-summarize_002dmutation_002dstats"></a><dl>
<dt><a name="index-summarize_002dmutation_002dstats"></a>Function: <strong>summarize-mutation-stats</strong></dt>
<dd><p><code>docfixme</code>
* <code>results</code> <code>docfixme</code>
</p></dd></dl>
<a name="Function-synthesize_002dcondition"></a><dl>
<dt><a name="index-synthesize_002dcondition"></a>Function: <strong>synthesize-condition</strong> <em>software test-suite repair-mutation &amp;key extra-instrumentation-exprs</em></dt>
<dd><p>Apply <code>repair-mutation</code> to <code>software</code>, attempting to synthesize a
condition which increases the number of tests in <code>test-suite</code> that pass.
Return a copy of <code>software</code> with a synthesized condition inserted at the
target of <code>repair-mutation</code>.
</p>
<ul>
<li> <code>test-suite</code> a &lsquo;test-suite&rsquo; containing both positive and negative test cases.
</li><li> <code>repair-mutation</code> a &lsquo;mutation&rsquo; that inserts an abstract condition.
</li><li> <code>extra-instrumentation-exprs</code> a list of additional expressions to
  print at each instrumentation point. It should have the form &rsquo;((expr
  . ((:type . &quot;typename&quot;)))). These expressions can be generated
  with &lsquo;instrumentation-exprs&rsquo;.
</li></ul>
</dd></dl>
<a name="Function-synthesize_002dconditions"></a><dl>
<dt><a name="index-synthesize_002dconditions"></a>Function: <strong>synthesize-conditions</strong> <em>envs</em></dt>
<dd><p>For each assignment in each environment in <code>envs</code>, create a list of condition
triples representing (x <code>==</code> v) and !(x <code>==</code> v).
Return a list of synthesized condition triples, by prepending :eq or :neq to each
assignment in the environments in <code>env</code>.
* <code>envs</code> a list of environments, each of which contains a list of triples:
(&quot;var&quot; &quot;type&quot; &quot;value&quot;).
</p></dd></dl>
<a name="Function-tag_002dloc_002dinfo"></a><dl>
<dt><a name="index-tag_002dloc_002dinfo"></a>Function: <strong>tag-loc-info</strong> <em>sexpr</em></dt>
<dd><p>Return <code>sexpr</code> with Coq location info replaced by &lsquo;(:loc NIL)&rsquo;.
See also &lsquo;is-loc-info&rsquo; and &lsquo;untag-loc-info&rsquo;.
</p></dd></dl>
<a name="Function-target_002dfunction"></a><dl>
<dt><a name="index-target_002dfunction"></a>Function: <strong>target-function</strong> <em>asm-super start-addr end-addr</em></dt>
<dd><p>Define the target function by specifying start address and end address
</p></dd></dl>
<a name="Function-target_002dfunction_002dname"></a><dl>
<dt><a name="index-target_002dfunction_002dname"></a>Function: <strong>target-function-name</strong> <em>asm function-name</em></dt>
<dd><p>Specify target function by name. The name can be a symbol or a string. If
a symbol, the <code>symbol-name</code> of the symbol is used.
</p></dd></dl>
<a name="Generic_002dFunction-to_002dalist"></a><dl>
<dt><a name="index-to_002dalist"></a>Generic Function: <strong>to-alist</strong> <em>struct</em></dt>
<dd><p>Convert struct to alist representation.
</p></dd></dl>
<a name="Generic_002dFunction-to_002dfeature_002dvector"></a><dl>
<dt><a name="index-to_002dfeature_002dvector"></a>Generic Function: <strong>to-feature-vector</strong> <em>feature-values sorted-keys</em></dt>
<dd><p>Convert a set of <code>feature-values</code> into a feature vector.
The elements of the vector are the values corresponding to <code>sorted-keys</code>.
</p></dd></dl>
<a name="Method-to_002dfeature_002dvector-_0028_0028feature_002dvalues-hash_002dtable_0029-_0028sorted_002dkeys-list_0029_0029"></a><dl>
<dt><a name="index-to_002dfeature_002dvector-1"></a>Method: <strong>to-feature-vector</strong> <em>(feature-values hash-table) (sorted-keys list)</em></dt>
<dd><p>Convert a set of <code>feature-values</code> into a feature vector.
Return a vector whose elements are the values from <code>feature-values</code> that are
mapped to the keys in <code>sorted-keys</code>.
</p><ul>
<li> <code>feature-values</code> a hash-table
</li><li> <code>sorted-keys</code> a list of keys from hash table whose values will be
  added to the resulting feature vector
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-to_002dfile"></a><dl>
<dt><a name="index-to_002dfile"></a>Generic Function: <strong>to-file</strong> <em>software file</em></dt>
<dd><p>Write <code>software</code> to <code>file</code>
</p></dd></dl>
<a name="Method-to_002dfile-_0028_0028obj-coq_0029-path_0029"></a><dl>
<dt><a name="index-to_002dfile-1"></a>Method: <strong>to-file</strong> <em>(obj coq) path</em></dt>
<dd><p>Look up source strings for Coq <code>obj</code> ASTs and write to <code>path</code>.
</p></dd></dl>
<a name="Method-to_002dfile-_0028_0028clang_002dproject-clang_002dproject_0029-path_0029"></a><dl>
<dt><a name="index-to_002dfile-2"></a>Method: <strong>to-file</strong> <em>(clang-project clang-project) path</em></dt>
<dd><p>Write <code>clang-project</code> to the path directory.
</p><ul>
<li> <code>clang-project</code> project to output
</li><li> <code>path</code> directory to write the project to
</li></ul>
</dd></dl>
<a name="Method-to_002dfile-_0028_0028asm-asm_002dheap_0029-file_0029"></a><dl>
<dt><a name="index-to_002dfile-3"></a>Method: <strong>to-file</strong> <em>(asm asm-heap) file</em></dt>
<dd><p>Save the assembly for ASM to <code>file</code>.
</p></dd></dl>
<a name="Method-to_002dfile-_0028_0028lisp-lisp_0029-path_0029"></a><dl>
<dt><a name="index-to_002dfile-4"></a>Method: <strong>to-file</strong> <em>(lisp lisp) path</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>lisp</code> <code>docfixme</code>
</li><li> <code>path</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Method-to_002dfile-_0028_0028simple-simple_0029-file_0029"></a><dl>
<dt><a name="index-to_002dfile-5"></a>Method: <strong>to-file</strong> <em>(simple simple) file</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Generic_002dFunction-tokens"></a><dl>
<dt><a name="index-tokens"></a>Generic Function: <strong>tokens</strong> <em>software &amp;optional roots</em></dt>
<dd><p>Return a list of keyword tokens in <code>software</code>.
Optional argument <code>roots</code> limits to tokens below elements of <code>root</code> ASTs in
<code>software</code>.
</p></dd></dl>
<a name="Method-tokens-_0028_0028clang-clang_0029-_0026optional-_0028roots-_0028roots-clang_0029_0029_0029"></a><dl>
<dt><a name="index-tokens-1"></a>Method: <strong>tokens</strong> <em>(clang clang) &amp;optional (roots (roots clang))</em></dt>
<dd><p>Return a list of keyword tokens representing the ASTs in <code>software</code> below <code>roots</code>.
</p><ul>
<li> <code>clang</code> software object to tokenize
</li><li> <code>roots</code> limit to tokens below elements of <code>root</code> ASTs in <code>clang</code>
</li></ul>
</dd></dl>
<a name="Function-tournament"></a><dl>
<dt><a name="index-tournament"></a>Function: <strong>tournament</strong> <em>&amp;key predicate tie-breaker-predicate size</em></dt>
<dd><p>Select an individual from <code>*population*</code> with a tournament.
</p></dd></dl>
<a name="Generic_002dFunction-traceable_002dstmt_002dp"></a><dl>
<dt><a name="index-traceable_002dstmt_002dp"></a>Generic Function: <strong>traceable-stmt-p</strong> <em>software ast</em></dt>
<dd><p>Return <code>true</code> if AST is a traceable statement in <code>software</code>.
</p></dd></dl>
<a name="Method-traceable_002dstmt_002dp-_0028_0028obj-clang_0029-_0028ast-clang_002dast_0029_0029"></a><dl>
<dt><a name="index-traceable_002dstmt_002dp-1"></a>Method: <strong>traceable-stmt-p</strong> <em>(obj clang) (ast clang-ast)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> AST <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-two_002dpoint_002dcrossover"></a><dl>
<dt><a name="index-two_002dpoint_002dcrossover"></a>Generic Function: <strong>two-point-crossover</strong> <em>software-a software-b</em></dt>
<dd><p>Crossover between two points.
</p></dd></dl>
<a name="Method-two_002dpoint_002dcrossover-_0028_0028a-sw_002drange_0029-_0028b-sw_002drange_0029_0029"></a><dl>
<dt><a name="index-two_002dpoint_002dcrossover-1"></a>Method: <strong>two-point-crossover</strong> <em>(a sw-range) (b sw-range)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Method-two_002dpoint_002dcrossover-_0028_0028a-simple_0029-_0028b-simple_0029_0029"></a><dl>
<dt><a name="index-two_002dpoint_002dcrossover-2"></a>Method: <strong>two-point-crossover</strong> <em>(a simple) (b simple)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Generic_002dFunction-type_002ddecl_002dstring"></a><dl>
<dt><a name="index-type_002ddecl_002dstring"></a>Generic Function: <strong>type-decl-string</strong> <em>type &amp;key qualified</em></dt>
<dd><p>The source text used to declare variables of <code>type</code>.
</p>
<p>This will have stars on the right, e.g. char**. 
</p></dd></dl>
<a name="Method-type_002ddecl_002dstring-_0028_0028type-clang_002dtype_0029-_0026key-_0028qualified-t_0029_0029"></a><dl>
<dt><a name="index-type_002ddecl_002dstring-1"></a>Method: <strong>type-decl-string</strong> <em>(type clang-type) &amp;key (qualified t)</em></dt>
<dd><p>Return the source text used to declare variables of <code>type</code>.
</p><ul>
<li> <code>type</code> type to convert to a declaration string
</li><li> <code>qualified</code> add type qualifiers such as const or volatile if non-nil.
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-type_002dfrom_002dtrace_002dstring"></a><dl>
<dt><a name="index-type_002dfrom_002dtrace_002dstring"></a>Generic Function: <strong>type-from-trace-string</strong> <em>name</em></dt>
<dd><p>Create a clang-type from a name used in an execution trace.
The resulting type will not be added to any clang object and will not have a
valid hash.
</p></dd></dl>
<a name="Method-type_002dfrom_002dtrace_002dstring-_0028_0028name-string_0029_0029"></a><dl>
<dt><a name="index-type_002dfrom_002dtrace_002dstring-1"></a>Method: <strong>type-from-trace-string</strong> <em>(name string)</em></dt>
<dd><p>Create a clang-type from a name used in an execution trace.
The resulting type will not be added to any clang object and will not have a
valid hash.
</p>
<p>* <code>name</code> type name as expressed in an execution trace
</p></dd></dl>
<a name="Generic_002dFunction-type_002dtrace_002dstring"></a><dl>
<dt><a name="index-type_002dtrace_002dstring"></a>Generic Function: <strong>type-trace-string</strong> <em>type &amp;key qualified</em></dt>
<dd><p>The text used to describe <code>type</code> in an execution trace.
</p>
<p>This will have stars on the left, e.g **char.
</p></dd></dl>
<a name="Method-type_002dtrace_002dstring-_0028_0028type-clang_002dtype_0029-_0026key-_0028qualified-t_0029_0029"></a><dl>
<dt><a name="index-type_002dtrace_002dstring-1"></a>Method: <strong>type-trace-string</strong> <em>(type clang-type) &amp;key (qualified t)</em></dt>
<dd><p>Return the text used to describe <code>type</code> in an execution trace.
</p><ul>
<li> <code>type</code> type to convert to a trace string
</li><li> <code>qualified</code> add type qualifiers such as const or volatile if non-nil.
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-typedef_002dtype"></a><dl>
<dt><a name="index-typedef_002dtype"></a>Generic Function: <strong>typedef-type</strong> <em>software type</em></dt>
<dd><p>Return the underlying type if <code>type</code> is a typedef
</p></dd></dl>
<a name="Method-typedef_002dtype-_0028_0028obj-clang_0029-_0028type-clang_002dtype_0029_0029"></a><dl>
<dt><a name="index-typedef_002dtype-1"></a>Method: <strong>typedef-type</strong> <em>(obj clang) (type clang-type)</em></dt>
<dd><p>Return the underlying type in <code>obj</code> if <code>type</code> is a typedef
</p></dd></dl>
<a name="Generic_002dFunction-uni_002dgrams"></a><dl>
<dt><a name="index-uni_002dgrams"></a>Generic Function: <strong>uni-grams</strong> <em>items &amp;key key uni-grams-ht</em></dt>
<dd><p>Update <code>uni-grams-ht</code> with counts of uni-gram occurrences in <code>items</code>.
Use <code>key</code> to specify a function applied to each item to generate a value used as
a key. The data structure <code>uni-grams-ht</code> is both updated and returned as
the result.
</p></dd></dl>
<a name="Method-uni_002dgrams-_0028_0028items-list_0029-_0026key-_0028key-_0023_0027identity_0029-_0028uni_002dgrams_002dht-_0028make_002dhash_002dtable-test-_0023_0027equal_0029_0029_0029"></a><dl>
<dt><a name="index-uni_002dgrams-1"></a>Method: <strong>uni-grams</strong> <em>(items list) &amp;key (key (function identity)) (uni-grams-ht (make-hash-table test (function equal)))</em></dt>
<dd><p>Update <code>uni-grams-ht</code> with counts of uni-gram occurrences in <code>items</code>.
Use <code>key</code> to specify a function applied to each item to generate a value used as
the hash-table key. The hash-table <code>uni-grams-ht</code> is both updated and returned as
the result
</p><ul>
<li> <code>items</code> a list of elements
</li><li> <code>key</code> a function applied to each item in <code>items</code> to generate a hash-table key
</li><li> <code>uni-grams-ht</code> a hash table mapping keys to numbers of occurrences
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-uninstrument"></a><dl>
<dt><a name="index-uninstrument"></a>Generic Function: <strong>uninstrument</strong> <em>obj &amp;key num-threads</em></dt>
<dd><p>Remove instrumentation from <code>obj</code>
</p>
<p>Keyword arguments are as follows:
  <code>num-threads</code> <code>----------</code> number of threads to use for uninstrumenting
</p></dd></dl>
<a name="Method-uninstrument-_0028_0028java_002dproject-java_002dproject_0029-_0026key-_0028num_002dthreads-1_0029_0029"></a><dl>
<dt><a name="index-uninstrument-1"></a>Method: <strong>uninstrument</strong> <em>(java-project java-project) &amp;key (num-threads 1)</em></dt>
<dd><p>Remove instrumentation from <code>java-project</code>.
</p></dd></dl>
<a name="Method-uninstrument-_0028_0028clang_002dproject-clang_002dproject_0029-_0026key-_0028num_002dthreads-1_0029_0029"></a><dl>
<dt><a name="index-uninstrument-2"></a>Method: <strong>uninstrument</strong> <em>(clang-project clang-project) &amp;key (num-threads 1)</em></dt>
<dd><p>Remove instrumentation from <code>clang-project</code>
</p></dd></dl>
<a name="Method-uninstrument-_0028_0028clang-clang_0029-_0026key-_0028num_002dthreads-1_0029_0029"></a><dl>
<dt><a name="index-uninstrument-3"></a>Method: <strong>uninstrument</strong> <em>(clang clang) &amp;key (num-threads 1)</em></dt>
<dd><p>Remove instrumentation from <code>clang</code>
</p></dd></dl>
<a name="Generic_002dFunction-valid_002dtargets"></a><dl>
<dt><a name="index-valid_002dtargets"></a>Generic Function: <strong>valid-targets</strong> <em>mutation software</em></dt>
<dd><p>Return a list of the locations in <code>software</code> where <code>mutation</code> can be applied.
</p></dd></dl>
<a name="Method-valid_002dtargets-_0028_0028mutation-insert_002delse_002dif_0029-software_0029"></a><dl>
<dt><a name="index-valid_002dtargets-1"></a>Method: <strong>valid-targets</strong> <em>(mutation insert-else-if) software</em></dt>
<dd><p>Return a list of the locations in <code>software</code> where &lsquo;insert-else-if&rsquo; <code>mutation</code> can be applied.
</p></dd></dl>
<a name="Method-valid_002dtargets-_0028_0028mutation-if_002dto_002dwhile_0029-software_0029"></a><dl>
<dt><a name="index-valid_002dtargets-2"></a>Method: <strong>valid-targets</strong> <em>(mutation if-to-while) software</em></dt>
<dd><p>Return a list of the locations in <code>software</code> where &lsquo;if-to-while&rsquo; <code>mutation</code> can be applied.
</p></dd></dl>
<a name="Method-valid_002dtargets-_0028_0028mutation-add_002dcondition_0029-software_0029"></a><dl>
<dt><a name="index-valid_002dtargets-3"></a>Method: <strong>valid-targets</strong> <em>(mutation add-condition) software</em></dt>
<dd><p>Return a list of the locations in <code>software</code> where &lsquo;add-condition&rsquo; <code>mutation</code> can be applied.
</p></dd></dl>
<a name="Method-valid_002dtargets-_0028_0028mutation-refine_002dcondition_0029-software_0029"></a><dl>
<dt><a name="index-valid_002dtargets-4"></a>Method: <strong>valid-targets</strong> <em>(mutation refine-condition) software</em></dt>
<dd><p>Return a list of the locations in <code>software</code> where &lsquo;refine-condition&rsquo; <code>mutation</code> can be applied.
</p></dd></dl>
<a name="Generic_002dFunction-var_002dinstrument"></a><dl>
<dt><a name="index-var_002dinstrument"></a>Generic Function: <strong>var-instrument</strong> <em>key instrumenter ast &amp;key print-strings</em></dt>
<dd><p>Generate ASTs for variable instrumentation.
</p><ul>
<li> <code>key</code> a function used to pull the variable list out of AST
</li><li> <code>instrumenter</code> current instrumentation state
</li><li> AST the AST to instrument
</li></ul>
</dd></dl>
<a name="Method-var_002dinstrument-_0028key-_0028instrumenter-instrumenter_0029-_0028ast-clang_002dast_0029-_0026key-print_002dstrings_0029"></a><dl>
<dt><a name="index-var_002dinstrument-1"></a>Method: <strong>var-instrument</strong> <em>key (instrumenter instrumenter) (ast clang-ast) &amp;key print-strings</em></dt>
<dd><p>Generate ASTs for variable instrumentation.
</p><ul>
<li> <code>key</code> a function used to pull the variable list out of AST
</li><li> <code>instrumenter</code> current instrumentation state
</li><li> AST the AST to instrument
</li></ul>
</dd></dl>
<a name="Macro-with_002dbuild_002ddir"></a><dl>
<dt><a name="index-with_002dbuild_002ddir"></a>Macro: <strong>with-build-dir</strong> <em>(build-dir) &amp;body body</em></dt>
<dd><p>Rebind *build-dir* within <code>body</code>
</p></dd></dl>
<a name="Function-same_002dclass_002dfilter"></a><dl>
<dt><a name="index-same_002dclass_002dfilter"></a>Function: <strong>same-class-filter</strong> <em>ast &amp;optional first-pick</em></dt>
<dd><p>Targeting filter returning true if AST and <code>first-pick</code> have the same AST class.
</p><ul>
<li> AST possible second targeting function pick
</li><li> <code>first-pick</code> first targeting function pick
</li></ul>
</dd></dl>
<a name="Function-untag_002dloc_002dinfo"></a><dl>
<dt><a name="index-untag_002dloc_002dinfo"></a>Function: <strong>untag-loc-info</strong> <em>sexpr</em></dt>
<dd><p>Return <code>sexpr</code> with occurrences of &lsquo;(:loc NIL)&rsquo; replaced by <code>nil</code>.
See also &lsquo;tag-loc-info&rsquo;.
</p></dd></dl>
<a name="Generic_002dFunction-update_002dasts"></a><dl>
<dt><a name="index-update_002dasts"></a>Generic Function: <strong>update-asts</strong> <em>software</em></dt>
<dd><p>Update the store of asts associated with <code>software</code>.
</p></dd></dl>
<a name="Method-update_002dasts-_0028_0028obj-clang_002dproject_0029_0029"></a><dl>
<dt><a name="index-update_002dasts-1"></a>Method: <strong>update-asts</strong> <em>(obj clang-project)</em></dt>
<dd><p>Call &lsquo;update-asts&rsquo; on all &lsquo;evolve-files&rsquo; of <code>obj</code>.
</p></dd></dl>
<a name="Method-update_002dasts-_0028_0028obj-clang_0029_0029"></a><dl>
<dt><a name="index-update_002dasts-2"></a>Method: <strong>update-asts</strong> <em>(obj clang)</em></dt>
<dd><p>Parse and return the ASTs in <code>obj</code> using &lsquo;clang-mutate&rsquo;.
</p><ul>
<li> <code>obj</code> object to parse
</li><li> <code>clang-mutate-args</code> arguments to pass to &lsquo;clang-mutate&rsquo;
</li></ul>
</dd></dl>
<a name="Method-update_002dasts-around-_0028_0028obj-parseable_0029_0029"></a><dl>
<dt><a name="index-around-update_002dasts"></a>Method: <strong>around update-asts</strong> <em>(obj parseable)</em></dt>
<dd><p>Wrap update-asts to only parse <code>obj</code> when the &lsquo;asts-changed-p&rsquo;
field indicates the object has changed since the last parse.
</p></dd></dl>
<a name="Function-update_002dmutation_002dtypes"></a><dl>
<dt><a name="index-update_002dmutation_002dtypes"></a>Function: <strong>update-mutation-types</strong> <em>mutation-types</em></dt>
<dd><p><code>docfixme</code>
</p>
<ul>
<li> <code>mutation-types</code> <code>docfixme</code>
</li><li> <code>by-type</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Function-update_002dproject_002dfeatures"></a><dl>
<dt><a name="index-update_002dproject_002dfeatures"></a>Function: <strong>update-project-features</strong> <em>project &amp;key features</em></dt>
<dd><p>Update feature values for <code>features</code> in <code>project</code> by re-merging feature-vectors
and metadata for all software objects in the project.
</p><ul>
<li> <code>project</code> a project object
</li><li> <code>features</code> a list of style-features whose values are to be re-computed.
</li></ul>
<p>May be a subset of the features tracked in project.
</p></dd></dl>
<a name="Generic_002dFunction-weighted_002dpick"></a><dl>
<dt><a name="index-weighted_002dpick"></a>Generic Function: <strong>weighted-pick</strong> <em>searchable target weight &amp;key predicate metric key limit ast-class filter limit-considered</em></dt>
<dd><p>Perform a random pick weighted by weight from &lsquo;similar-snippets&rsquo;.
All other arguments are passed through to sorted snippets.
</p></dd></dl>
<a name="Method-weighted_002dpick-_0028_0028obj-searchable_0029-target-weight-_0026key-key-limit-ast_002dclass-_0028predicate-_0023_0027_003c_0029-_0028metric-_0023_0027diff_002dscalar_0029-_0028filter-_0023_0027null_0029-_0028limit_002dconsidered-infinity_0029_0029"></a><dl>
<dt><a name="index-weighted_002dpick-1"></a>Method: <strong>weighted-pick</strong> <em>(obj searchable) target weight &amp;key key limit ast-class (predicate (function &lt;)) (metric (function diff-scalar)) (filter (function null)) (limit-considered infinity)</em></dt>
<dd><p><code>docfixme</code>
</p></dd></dl>
<a name="Generic_002dFunction-wrap_002dast"></a><dl>
<dt><a name="index-wrap_002dast"></a>Generic Function: <strong>wrap-ast</strong> <em>software ast</em></dt>
<dd><p>Wrap AST in <code>software</code> in a compound statement.
Known issue with ifdefs <code>--</code> consider this snippet:
</p>
<div class="example">
<pre class="example">    if (x) {
      var=1;
    #ifdef SOMETHING
    } else if (y) {
      var=2;
    #endif
    }
</pre></div>

<p>it will transform this into:
</p>
<div class="example">
<pre class="example">    if (x) {
      var=1;
    #ifdef SOMETHING
    } else {
        if (y) {
          var=2;
    #endif
        }  // spurious -- now won't compile.
    }
</pre></div>
</dd></dl>
<a name="Method-wrap_002dast-_0028_0028obj-clang_0029-_0028ast-clang_002dast_0029_0029"></a><dl>
<dt><a name="index-wrap_002dast-1"></a>Method: <strong>wrap-ast</strong> <em>(obj clang) (ast clang-ast)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> AST <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-wrap_002dchild"></a><dl>
<dt><a name="index-wrap_002dchild"></a>Generic Function: <strong>wrap-child</strong> <em>software ast index</em></dt>
<dd><p>Wrap <code>index</code> child of AST in <code>software</code> in a compound stmt.
</p></dd></dl>
<a name="Method-wrap_002dchild-_0028_0028obj-clang_0029-_0028ast-clang_002dast_0029-_0028index-integer_0029_0029"></a><dl>
<dt><a name="index-wrap_002dchild-1"></a>Method: <strong>wrap-child</strong> <em>(obj clang) (ast clang-ast) (index integer)</em></dt>
<dd><p><code>docfixme</code>
</p><ul>
<li> <code>obj</code> <code>docfixme</code>
</li><li> AST <code>docfixme</code>
</li><li> <code>index</code> <code>docfixme</code>
</li></ul>
</dd></dl>
<a name="Generic_002dFunction-write_002dgenome_002dto_002dfiles"></a><dl>
<dt><a name="index-write_002dgenome_002dto_002dfiles"></a>Generic Function: <strong>write-genome-to-files</strong> <em>obj</em></dt>
<dd><p>Overwrite evolved files with current genome.
</p></dd></dl>


<hr>
<div class="header">
<p>
Next: <a href="SEL-Utility-API.html#SEL-Utility-API" accesskey="n" rel="next">SEL Utility API</a>, Previous: <a href="SEL-API-Concept-Index.html#SEL-API-Concept-Index" accesskey="p" rel="prev">SEL API Concept Index</a>, Up: <a href="SEL-API.html#SEL-API" accesskey="u" rel="up">SEL API</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html#Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
