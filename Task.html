<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This file documents the Software Evolution library

Copyright (C) 2014-2018 Eric Schulte and GrammaTech

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with the Invariant Section being "GNU GENERAL PUBLIC LICENSE,"
A copy of the license is included in the section entitled
"GNU Free Documentation License." -->
<!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Task (Software Evolution Library)</title>

<meta name="description" content="Task (Software Evolution Library)">
<meta name="keywords" content="Task (Software Evolution Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Utilities.html#Utilities" rel="up" title="Utilities">
<link href="Usage.html#Usage" rel="next" title="Usage">
<link href="View.html#View" rel="prev" title="View">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<a name="Task"></a>
<div class="header">
<p>
Next: <a href="Usage.html#Usage" accesskey="n" rel="next">Usage</a>, Previous: <a href="View.html#View" accesskey="p" rel="prev">View</a>, Up: <a href="Utilities.html#Utilities" accesskey="u" rel="up">Utilities</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html#Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Task-1"></a>
<h3 class="section">4.3 Task</h3>
<p>Functions to run multiple tasks (such as mutations and fitness
tests) on multiple threads.
</p>
<p>This module makes use of Bordeaux Threads. See the documentation
here:
https://trac.common-lisp.net/bordeaux-threads/wiki/ApiDocumentation
</p>
<ul>
<li> Job: a function which returns a series of Tasks, one Task each
       time it is called. When the series is exhausted, it will
       return <code>nil</code>.

</li><li> Task: a thin wrapper over a Lisp object (typically a <code>software</code>
        instance, but could be anything).  The task can be used to
        customize how to process the object after fitness testing
        (basically a completion routine) and to customize how it
        spins off child Jobs.

</li><li> Worker: one or more Worker threads can be created to process
          Jobs.  When all jobs are finished, all the Worker
          threads will exit.  Therefore you create Jobs first,
          then the Workers.

</li></ul>
<a name="Description"></a>
<h4 class="subsection">4.3.1 Description</h4>

<p>A <code>task</code> is an operation to be performed by the multi-threaded
<code>task-runner</code>. A <code>task</code> can be customized by the client to generate
a job (child series of tasks) by implementing the <code>task-job</code> method,
and the code to be performed when processing a <code>task</code> is defined by the
<code>process-task</code> method.
</p>
<p>A job is a Lisp function, which takes no arguments, and which will
produce a <code>task</code> each time it is called, or <code>nil</code> when all of its tasks are
complete. Think of a job as a lazy sequence of <code>task</code>.
</p>
<p><code>task-runner-jobs</code> is a stack of jobs. Worker threads will call the
first job on the stack, and process the task returned.
</p>
<p>A task may add 1 or more jobs to the top of the stack, causing worker
threads to immediately start processing those jobs since they are now
higher on the stack and therefore have priority over other tasks.
</p>
<p>When the <code>jobs</code> stack is empty/NIL, then all worker threads will exit.
</p>
<a name="Example-use"></a>
<h4 class="subsection">4.3.2 Example use</h4>

<div class="example">
<pre class="example">    (setf *runner* (run-task (make-instance 'single-cut-all :object *orig*)
                             10))
     ;; When (task-runner-worker-count *runner*) = 0,
     ;; it means all threads are finished.
</pre></div>

<a name="Complex-Example-use"></a>
<h4 class="subsection">4.3.3 Complex Example use</h4>

<div class="example">
<pre class="example">    (defmacro task-map (num-threads function sequence)
      &quot;Run FUNCTION over SEQUENCE using a `simple-job' `task-job'.&quot;
      (with-gensyms (task-map task-item)
        `(if (= 1 ,num-threads)
             (mapcar ,function ,sequence) ; No threading.
             (progn                     ; Multi-threaded implementation.
               (defclass ,task-map (task) ())  ; Task to map over SEQUENCE.
               (defclass ,task-item (task) ()) ; Task to process elements.
               (defmethod task-job ((task ,task-map) runner)
                 (declare (ignore runner))
                 (let ((objs (task-object task))) ; Enclose SEQUENCE for fn.
                   (lambda () (when objs ; Return nil when SEQUENCE is empty.
                               ;; Return a task-item whose task-object run
                               ;; FUNCTION on the next element of SEQUENCE.
                           (make-instance ',task-item :object
                                          (curry ,function (pop objs)))))))
               (defmethod process-task ((task ,task-item) runner)
                 ;; Evaluate the task-object for this item as created in
                 ;; the task-job method above.  Save the results.
                 (task-save-result runner (funcall (task-object task))))
               (task-runner-results ; Return results from the results obj.
                ;; Create the task-map object, and run until exhausted.
                (run-task-and-block
                 (make-instance ',task-map :object ,sequence)
                 ,num-threads))))))
</pre></div>

<p>The above example uses the tasks API to implement a simple
parallel map spread across a configurable number of workers.  When
more than one worker thread is requested the following objects and
methods are created to implement the parallel map.
</p>
<ul>
<li> A <code>task-map</code> <code>task</code> is created to hold the sequence.

</li><li> The <code>task-job</code> method is defined for this <code>task-map</code>.  This method
  returns a function which has access to the <code>sequence</code> in a
  closure.  The function will continually pop the first element
  off the top of the sequence and wrap it in a <code>task-item</code> object to
  be returned until the <code>sequence</code> is empty at which point the
  function returns nil causing all worker threads to exit.

</li><li> The <code>task-item</code> <code>task</code> is created to hold tasks for every item in
  the sequence.

</li><li> The <code>process-task</code> method is defined for this <code>task-item</code>.  This
  method evaluates the function stored in the <code>task-object</code> of this
  <code>task-item</code> and saves the result into the task runner&rsquo;s results.

</li></ul>
<p>Finally, with the above objects and methods defined, the <code>task-map</code>
macro wraps the sequence into a <code>task-map</code> <code>task</code> object and passes
this to the <code>run-task-and-block</code> function yielding a runner and the
contents of that runner are extracted and returned using the
<code>task-runner-results</code> accessor.
</p>
<p>See the actual implementation of <code>task-map</code> in the <code>sel/utility</code>
package for a more efficient implementation which doesn&rsquo;t use a
macro or require new objects and methods to be defined on the fly.
</p>

<hr>
<div class="header">
<p>
Next: <a href="Usage.html#Usage" accesskey="n" rel="next">Usage</a>, Previous: <a href="View.html#View" accesskey="p" rel="prev">View</a>, Up: <a href="Utilities.html#Utilities" accesskey="u" rel="up">Utilities</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html#Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
