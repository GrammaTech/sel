<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This file documents the Software Evolution library

Copyright (C) 2014-2018 Eric Schulte and GrammaTech

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with the Invariant Section being "GNU GENERAL PUBLIC LICENSE,"
A copy of the license is included in the section entitled
"GNU Free Documentation License." -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>sel-sw-ast (Software Evolution Library)</title>

<meta name="description" content="sel-sw-ast (Software Evolution Library)">
<meta name="keywords" content="sel-sw-ast (Software Evolution Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="SEL-Packages.html" rel="up" title="SEL Packages">
<link href="sel_002dsw_002dcil.html" rel="next" title="sel-sw-cil">
<link href="sel_002dsw_002dasm_002dsuper_002dmutant.html" rel="prev" title="sel-sw-asm-super-mutant">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<span id="sel_002dsw_002dast"></span><div class="header">
<p>
Next: <a href="sel_002dsw_002dcil.html" accesskey="n" rel="next">sel-sw-cil</a>, Previous: <a href="sel_002dsw_002dasm_002dsuper_002dmutant.html" accesskey="p" rel="prev">sel-sw-asm-super-mutant</a>, Up: <a href="SEL-Packages.html" accesskey="u" rel="up">SEL Packages</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="sel_002dsw_002dast-1"></span><h3 class="section">C.10 sel-sw-ast</h3>
<span id="Structure-ast"></span><dl>
<dt id="index-ast">Structure: <strong>ast</strong></dt>
<dd><p>Class precedence list: <code>ast, structure-object, t</code>
</p>
<p>Base structure of mutable portion of ast nodes.
</p></dd></dl>
<span id="Generic_002dFunction-ast_002dchildren"></span><dl>
<dt id="index-ast_002dchildren">Generic Function: <strong>ast-children</strong> <em>a</em></dt>
<dd><p>Genericized version of children reader for AST structs
</p></dd></dl>
<span id="Generic_002dFunction-_0028setf-ast_002dchildren_0029"></span><dl>
<dt id="index-_0028setf-ast_002dchildren_0029">Generic Function: <strong>(setf ast-children)</strong> <em>v a</em></dt>
<dd><p>Genericized version of children writer for AST structs
</p></dd></dl>
<span id="Generic_002dFunction-ast_002dclass"></span><dl>
<dt id="index-ast_002dclass">Generic Function: <strong>ast-class</strong> <em>ast</em></dt>
<dd><p>Class of AST.
</p></dd></dl>
<span id="Generic_002dFunction-ast_002dclass_002dmeld_003f"></span><dl>
<dt id="index-ast_002dclass_002dmeld_003f">Generic Function: <strong>ast-class-meld?</strong> <em>ast-class ast</em></dt>
<dd><p>Dispatches on the ast-class of an ast to compute &lsquo;ast-meld-p&rsquo;
</p></dd></dl>
<span id="Generic_002dFunction-ast_002dequal_002dp"></span><dl>
<dt id="index-ast_002dequal_002dp">Generic Function: <strong>ast-equal-p</strong> <em>ast-a ast-b</em></dt>
<dd><p>Return <code>t</code> <code>ast-a</code> and <code>ast-b</code> are equal for differencing.
</p></dd></dl>
<span id="Generic_002dFunction-ast_002dhash"></span><dl>
<dt id="index-ast_002dhash">Generic Function: <strong>ast-hash</strong> <em>ast</em></dt>
<dd><p>A hash value for the AST, which is a nonnegative
integer.  It should be the case that (ast-equal-p x y) implies
(eql (ast-hash x) (ast-hash y)), and that if (not (ast-equal-p x y))
then the equality of the hashes is unlikely.
</p></dd></dl>
<span id="Function-ast_002dlater_002dp"></span><dl>
<dt id="index-ast_002dlater_002dp">Function: <strong>ast-later-p</strong> <em>ast-a ast-b</em></dt>
<dd><p>Is <code>ast-a</code> later in the genome than <code>ast-b</code>?
</p>
<p>Use this to sort AST asts for mutations that perform multiple
operations.
</p></dd></dl>
<span id="Generic_002dFunction-ast_002dmeld_002dp"></span><dl>
<dt id="index-ast_002dmeld_002dp">Generic Function: <strong>ast-meld-p</strong> <em>ast</em></dt>
<dd><p>Returns true if the children of AST are to be combined on merge conflict.
</p></dd></dl>
<span id="Structure-ast_002dnode"></span><dl>
<dt id="index-ast_002dnode">Structure: <strong>ast-node</strong></dt>
<dd><p>Class precedence list: <code>ast-node, structure-object, t</code>
</p>
<p>Base type of immutable portion of ast nodes.
</p></dd></dl>
<span id="Generic_002dFunction-ast_002dpath"></span><dl>
<dt id="index-ast_002dpath">Generic Function: <strong>ast-path</strong> <em>a</em></dt>
<dd><p>Genericized version of path reader for AST structs
</p></dd></dl>
<span id="Generic_002dFunction-_0028setf-ast_002dpath_0029"></span><dl>
<dt id="index-_0028setf-ast_002dpath_0029">Generic Function: <strong>(setf ast-path)</strong> <em>v a</em></dt>
<dd><p>Genericized version of path writer for AST structs
</p></dd></dl>
<span id="Generic_002dFunction-ast_002dstored_002dhash"></span><dl>
<dt id="index-ast_002dstored_002dhash">Generic Function: <strong>ast-stored-hash</strong> <em>a</em></dt>
<dd><p>Genericized version of stored-hash reader for AST structs
</p></dd></dl>
<span id="Generic_002dFunction-_0028setf-ast_002dstored_002dhash_0029"></span><dl>
<dt id="index-_0028setf-ast_002dstored_002dhash_0029">Generic Function: <strong>(setf ast-stored-hash)</strong> <em>v a</em></dt>
<dd><p>Genericized version of children writer for AST structs
</p></dd></dl>
<span id="Structure-ast_002dstub"></span><dl>
<dt id="index-ast_002dstub">Structure: <strong>ast-stub</strong></dt>
<dd><p>Class precedence list: <code>ast-stub, ast, structure-object, t</code>
</p>
<p>Base type of sub-tree of an applicative AST tree.
</p></dd></dl>
<span id="Generic_002dFunction-ast_002dtext"></span><dl>
<dt id="index-ast_002dtext">Generic Function: <strong>ast-text</strong> <em>ast</em></dt>
<dd><p>Return textual representation of AST.
</p></dd></dl>
<span id="Generic_002dFunction-ast_002dto_002dlist"></span><dl>
<dt id="index-ast_002dto_002dlist">Generic Function: <strong>ast-to-list</strong> <em>obj</em></dt>
<dd><p>Return ASTs under <code>obj</code> as a list.
</p></dd></dl>
<span id="Generic_002dFunction-combine_002dconflict_002dasts"></span><dl>
<dt id="index-combine_002dconflict_002dasts">Generic Function: <strong>combine-conflict-asts</strong> <em>ca1 ca2</em></dt>
<dd><p>Merge conflict ast nodes CA1 and CA2, their alists and default values.
</p></dd></dl>
<span id="Structure-conflict_002dast"></span><dl>
<dt id="index-conflict_002dast">Structure: <strong>conflict-ast</strong></dt>
<dd><p>Class precedence list: <code>conflict-ast, ast-stub, ast, structure-object, t</code>
</p>
<p>Node representing several possibilities for insertion into an AST.
The mapping from a conflicted AST into a regular AST is as follows: for
a given conflict key, and for each conflict node, get the list of children
corresponding to that key (default if the key is not present), and splice
that list of children in place of the conflict node in its parent&rsquo;s children
list.
</p></dd></dl>
<span id="Macro-define_002dast"></span><dl>
<dt id="index-define_002dast">Macro: <strong>define-ast</strong> <em>name-and-options &amp;rest slot-descriptions</em></dt>
<dd><p>Implicitly defines an AST wrapper for the defined AST-node.
</p></dd></dl>
<span id="Generic_002dFunction-fixup_002dmutation"></span><dl>
<dt id="index-fixup_002dmutation">Generic Function: <strong>fixup-mutation</strong> <em>operation current before ast after</em></dt>
<dd><p>Adjust mutation result according to syntactic context.
</p></dd></dl>
<span id="Generic_002dFunction-from_002dalist"></span><dl>
<dt id="index-from_002dalist">Generic Function: <strong>from-alist</strong> <em>symbol alist</em></dt>
<dd><p>Convert alist to struct representation.
</p></dd></dl>
<span id="Generic_002dFunction-map_002dast"></span><dl>
<dt id="index-map_002dast">Generic Function: <strong>map-ast</strong> <em>tree fn</em></dt>
<dd><p>Apply <code>fn</code> to each node of AST, in preorder.
</p></dd></dl>
<span id="Generic_002dFunction-map_002dast_002dpostorder"></span><dl>
<dt id="index-map_002dast_002dpostorder">Generic Function: <strong>map-ast-postorder</strong> <em>tree fn</em></dt>
<dd><p>Apply <code>fn</code> to each node of AST, in postorder.
</p></dd></dl>
<span id="Generic_002dFunction-map_002dast_002dstrings"></span><dl>
<dt id="index-map_002dast_002dstrings">Generic Function: <strong>map-ast-strings</strong> <em>tree fn</em></dt>
<dd><p>Build a new AST obtained by replacing each string with
(funcall <code>fn</code> string).  If the <code>fn</code> returns <code>nil</code> do not replace.
</p></dd></dl>
<span id="Generic_002dFunction-map_002dast_002dwith_002dancestors"></span><dl>
<dt id="index-map_002dast_002dwith_002dancestors">Generic Function: <strong>map-ast-with-ancestors</strong> <em>tree fn &amp;optional ancestors</em></dt>
<dd><p>Apply <code>fn</code> to each node of the AST, and its list of ancestors,
in preorder.  The ancestor list is in decreasing order of depth in the AST.
</p></dd></dl>
<span id="Function-mapc_002dast"></span><dl>
<dt id="index-mapc_002dast">Function: <strong>mapc-ast</strong> <em>ast fn</em></dt>
<dd><p>Apply <code>fn</code> to AST collecting the results with &lsquo;cons&rsquo;.
</p></dd></dl>
<span id="Function-mapc_002dast_002dand_002dstrings"></span><dl>
<dt id="index-mapc_002dast_002dand_002dstrings">Function: <strong>mapc-ast-and-strings</strong> <em>ast fn</em></dt>
<dd><p>Apply <code>fn</code> to ASTs and strings in AST collecting the results with &lsquo;cons&rsquo;.
</p></dd></dl>
<span id="Function-move_002dprefixes_002ddown"></span><dl>
<dt id="index-move_002dprefixes_002ddown">Function: <strong>move-prefixes-down</strong> <em>children allowed-fn prefix-fn</em></dt>
<dd><p>Give a list <code>children</code> of strings and AST nodes, find children
that satisfy <code>allowed-fn</code>, are followed by a string, and for for which
<code>prefix-fn</code> returns a non-null value, which must be a position
in the string.   Move the [0..pos) prefix of that string
down into the list of children of the preceding node, concatenating
it onto the end of the last string in that node&rsquo;s children.
All list operations are destructive.
</p></dd></dl>
<span id="Generic_002dFunction-rebind_002dvars"></span><dl>
<dt id="index-rebind_002dvars">Generic Function: <strong>rebind-vars</strong> <em>ast var-replacements fun-replacements</em></dt>
<dd><p>Replace variable and function references, returning a new AST.
</p></dd></dl>
<span id="Method-rebind_002dvars-_0028_0028ast-javascript_002dast_0029-var_002dreplacements-fun_002dreplacements_0029"></span><dl>
<dt id="index-rebind_002dvars-1">Method: <strong>rebind-vars</strong> <em>(ast javascript-ast) var-replacements fun-replacements</em></dt>
<dd><p>Replace variable and function references, returning a new AST.
</p><ul>
<li> AST node to rebind variables and function references for
</li><li> <code>var-replacements</code> list of old-name, new-name pairs defining the rebinding
</li><li> <code>fun-replacements</code> list of old-function-info, new-function-info pairs defining
</li></ul>
<p>the rebinding
</p></dd></dl>
<span id="Method-rebind_002dvars-_0028_0028ast-clang_002dast_0029-var_002dreplacements-fun_002dreplacements_0029"></span><dl>
<dt id="index-rebind_002dvars-2">Method: <strong>rebind-vars</strong> <em>(ast clang-ast) var-replacements fun-replacements</em></dt>
<dd><p>Replace variable and function references, returning a new AST.
</p><ul>
<li> AST node to rebind variables and function references for
</li><li> <code>var-replacements</code> list of old-name, new-name pairs defining the rebinding
</li><li> <code>fun-replacements</code> list of old-function-info, new-function-info pairs defining
</li></ul>
<p>the rebinding
</p></dd></dl>
<span id="Method-rebind_002dvars-_0028_0028ast-string_0029-var_002dreplacements-fun_002dreplacements_0029"></span><dl>
<dt id="index-rebind_002dvars-3">Method: <strong>rebind-vars</strong> <em>(ast string) var-replacements fun-replacements</em></dt>
<dd><p>Replace variable and function references, returning a new AST.
</p><ul>
<li> AST node to rebind variables and function references for
</li><li> <code>var-replacements</code> list of old-name, new-name pairs defining the rebinding
</li><li> <code>fun-replacements</code> list of old-function-info, new-function-info pairs defining
</li></ul>
<p>the rebinding
</p></dd></dl>
<span id="Generic_002dFunction-replace_002din_002dast"></span><dl>
<dt id="index-replace_002din_002dast">Generic Function: <strong>replace-in-ast</strong> <em>ast replacements &amp;key test</em></dt>
<dd><p>Make arbitrary replacements within AST, returning a new
AST.
</p></dd></dl>
<span id="Method-replace_002din_002dast-_0028_0028ast-string_0029-replacements-_0026key-_0028test-_0023_0027equalp_0029_0029"></span><dl>
<dt id="index-replace_002din_002dast-1">Method: <strong>replace-in-ast</strong> <em>(ast string) replacements &amp;key (test (function equalp))</em></dt>
<dd><p>Make arbritrary replacements within AST, returning a new AST.
</p><ul>
<li> AST node to perform modifications to
</li><li> <code>replacements</code> association list of key, value pairs to replace in AST
</li><li> <code>test</code> function to test if a given replacement key can be found in AST
</li></ul>
</dd></dl>
<span id="Method-replace_002din_002dast-_0028_0028ast-ast_0029-replacements-_0026key-_0028test-_0023_0027equalp_0029_0029"></span><dl>
<dt id="index-replace_002din_002dast-2">Method: <strong>replace-in-ast</strong> <em>(ast ast) replacements &amp;key (test (function equalp))</em></dt>
<dd><p>Make arbritrary replacements within AST, returning a new AST.
</p><ul>
<li> AST node to perform modifications to
</li><li> <code>replacements</code> association list of key, value pairs to replace in AST
</li><li> <code>test</code> function to test if a given replacement key can be found in AST
</li></ul>
</dd></dl>
<span id="Generic_002dFunction-replace_002dnth_002dchild"></span><dl>
<dt id="index-replace_002dnth_002dchild">Generic Function: <strong>replace-nth-child</strong> <em>ast n replacement</em></dt>
<dd><p>Return AST with the nth child of AST replaced with
<code>replacement</code>.
</p>
<ul>
<li> AST tree to modify
</li><li> <code>n</code> child to modify
</li><li> <code>replacement</code> replacement for the nth child
</li></ul>
</dd></dl>
<span id="Generic_002dFunction-source_002dtext"></span><dl>
<dt id="index-source_002dtext">Generic Function: <strong>source-text</strong> <em>ast</em></dt>
<dd><p>Source code corresponding to an AST.
</p></dd></dl>
<span id="Method-source_002dtext-_0028_0028str-string_0029_0029"></span><dl>
<dt id="index-source_002dtext-1">Method: <strong>source-text</strong> <em>(str string)</em></dt>
<dd><p>Return the source code corresponding to <code>str</code>.
</p></dd></dl>
<span id="Method-source_002dtext-_0028_0028node-ast_002dnode_0029_0029"></span><dl>
<dt id="index-source_002dtext-2">Method: <strong>source-text</strong> <em>(node ast-node)</em></dt>
<dd><p>Return a source text representation of a single, immutable, AST node.
</p></dd></dl>
<span id="Method-source_002dtext-_0028_0028ast-ast_0029_0029"></span><dl>
<dt id="index-source_002dtext-3">Method: <strong>source-text</strong> <em>(ast ast)</em></dt>
<dd><p>Return the source code corresponding to AST.
</p></dd></dl>
<span id="Generic_002dFunction-to_002dalist"></span><dl>
<dt id="index-to_002dalist">Generic Function: <strong>to-alist</strong> <em>struct</em></dt>
<dd><p>Convert struct to alist representation.
</p></dd></dl>
<span id="Generic_002dFunction-to_002dast"></span><dl>
<dt id="index-to_002dast">Generic Function: <strong>to-ast</strong> <em>ast-type spec</em></dt>
<dd><p>Walk a potentially recursive AST <code>spec</code> creating an <code>ast-type</code> AST.
A <code>spec</code> should have the form
</p>
<div class="lisp">
<pre class="lisp">  (ast-class &lt;optional-keyword-args-to-`make-&lt;AST-TYPE&gt;-node'&gt;
             CHILDREN)
</pre></div>

<p>where <code>children</code> may themselves be specifications suitable for passing
to &lsquo;to-ast&lsquo;.  <code>e</code>.g.
</p>
<div class="lisp">
<pre class="lisp">  (to-ast 'clang-ast (:callexpr (:implicitcastexpr
                                 :includes '(&quot;&lt;string.h&gt;&quot;)
                                 &quot;&quot; &quot;(|strcpy|)&quot; &quot;&quot;)
                                &quot;(&quot; &quot;arg-1&quot; &quot;,&quot; &quot;arg-2&quot; &quot;)&quot;))
</pre></div>
</dd></dl>

<hr>
<div class="header">
<p>
Next: <a href="sel_002dsw_002dcil.html" accesskey="n" rel="next">sel-sw-cil</a>, Previous: <a href="sel_002dsw_002dasm_002dsuper_002dmutant.html" accesskey="p" rel="prev">sel-sw-asm-super-mutant</a>, Up: <a href="SEL-Packages.html" accesskey="u" rel="up">SEL Packages</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
