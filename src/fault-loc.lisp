;;; fault-loc.lisp -- fault localization

#|
*************************************************************************************
*
* Unless otherwise specified, software artifacts in this directory and its
* subdirectories are subject to:
*
* UNLIMITED RIGHTS
*
* The Government's rights to use, modify, reproduce, release, perform, display, or
* disclose this software are governed by DFARS 252.227-7013, RIGHTS IN TECHNICAL DATA
* --NONCOMMERCIAL ITEMS, and DFARS 252.227-7014 RIGHTS IN NONCOMMERCIAL SOFTWARE AND
* NONCOMMERCIAL COMPUTER SOFTWARE DOCUMENTATION.
*
*************************************************************************************
*
* All GrammaTech IP (sole or co-developed) needs to include the GrammaTech copyright.
*
* (c) 2016 GrammaTech, Inc.  All rights reserved.
*
* Such IP is also subject to the terms of the Prioprietary Information Agreement (PIA)
* executed between BAE Systems Information and Electronics Systems Integration Inc.
* and GrammaTech, Inc. dated April 21, 2015
*
*************************************************************************************
|#

;; Fault localization algorithms.
;; These all operate on execution traces generated by the instrument
;; method.

(in-package :software-evolution)

(defgeneric collect-fault-loc-traces (instrumented-obj test-suite read-trace-fn)
  (:documentation "Run test cases and collect execution traces.

Returns a list of \"good\" traces (from passing tests) and a list of
\"bad\" traces (from failing tests).

INSTRUMENTED-OBJ is a software object which has already been instrumented.
READ-TRACE-FN is a function for reading the traces generated by that
instrumentation.

No assumptions are made about the format or contents of the traces."))

(defmethod collect-fault-loc-traces ((instrumented-obj software) test-suite
                                     read-trace-fn)
  (with-temp-file (bin)
    (build instrumented-obj bin)
    (iter (for test in (test-cases test-suite))
          (let ((f (run-test test-suite bin test))
                (trace (funcall read-trace-fn)))
            (if (>= f 1.0)
                (collecting trace into good-traces)
                (collecting trace into bad-traces)))
          (finally (return (values good-traces bad-traces))))))

(defun stmts-in-file (trace file-id)
  (remove-if-not [{= file-id} {aget :f}] trace))

(defun error-funcs (software bad-traces good-traces)
  "Find statements which call error functions.

Error functions are defined as functions which are only called during
bad runs. Such functions often contain error-handling code which is
not itself faulty, so it's useful to identify their callers instead.
"
  (labels
      ((call-sites (obj neg-test-stmts error-funcs)
         (remove-if-not (lambda (x)
                          (remove-if-not
                           (lambda (y)
                             (let ((cur-node (get-ast obj x)))
                               (and (string= (ast-class cur-node)
                                             "CallExpr")
                                    (search y (ast-src-text cur-node)))))
                           error-funcs))
                        neg-test-stmts))
       (functions (obj trace)
         (remove-duplicates
          (mapcar {function-containing-ast obj}
                  ;; Not necessary, but this is faster than doing
                  ;; duplicate function-containing-ast lookups.
                  (remove-duplicates trace))))
       (find-error-funcs (obj good-stmts bad-stmts)
         (mapcar #'ast-name
                 (set-difference (functions obj bad-stmts)
                                 (functions obj good-stmts)))))

    ;; Find error functions in each file individually, then append them.
    (let ((good-stmts (apply #'append good-traces))
          (bad-stmts (apply #'append bad-traces)))
     (iter
       (for obj in (mapcar #'cdr (evolve-files software)))
       (for i upfrom 0)
       (let ((good (mapcar {aget :c} (stmts-in-file good-stmts i)))
             (bad (mapcar {aget :c} (stmts-in-file bad-stmts i))))
         (appending
          (mapcar (lambda (c) `((:c . ,c) (:f . ,i)))
                  (call-sites obj
                              (remove-duplicates bad)
                              (find-error-funcs obj good bad)))))))))

(defclass stmt-counts ()
  ((id :initarg :id :accessor id
         :documentation "AST identifier (counter and file index).")
   (positive :initarg :positive :accessor positive
         :documentation "Count of positive tests which ran this statement.")
   (negative :initarg :negative :accessor negative
         :documentation "Count of negative tests which ran this statement.")
   (positions :initarg :positions :accessor positions
            :documentation "Positions of last occurrences in negative traces."))
  (:documentation
   "Statement information for spectrum-based fault localization."))

(defun rinard-compare (a b)
  ;; A is more suspicious than B if any of the following are true:
  (cond
    ((> (negative a) (negative b)) t)
    ((< (negative a) (negative b)) nil)
    ;; negative count is equal
    ((< (positive a) (positive b)) t)
    ((> (positive a) (positive b)) nil)
    ;; both counts are equal: which is executed later in more tests?
    (t (> (count t (mapcar (lambda (p1 p2) (> (or p1 -1) (or p2 -1)))
                           (positions a) (positions b)))
          (/ (length (positions a)) 2)))))

(defun rinard (count obj bad-traces good-traces)
  "Spectrum-based fault localization from SPR and Prophet.

Ranks statements based on their occurrences in positive and negative
tests, returning the COUNT highest-ranked statements.
"
  (declare (ignorable obj))
  (let ((good-traces (mapcar {mapcar {alist-filter '(:f :c)}} good-traces))
        (bad-traces (mapcar {mapcar {alist-filter '(:f :c)}} bad-traces)))
    (flet ((trace-contains (stmt trace)
             (member stmt trace :test #'equal)))
      (let ((counts
             (loop
                for stmt in (remove-duplicates
                             (append (apply #'append good-traces)
                                     (apply #'append bad-traces))
                             :test #'equal)

                collect
                  (make-instance 'stmt-counts
                                 :id stmt
                                 :positive (count-if {trace-contains stmt}
                                                     good-traces)
                                 :negative (count-if {trace-contains stmt}
                                                     bad-traces)
                                 :positions (mapcar (lambda (trace)
                                                      (position stmt trace
                                                                :from-end t
                                                                :test #'equal))
                                                    bad-traces)))))
        (mapcar #'id (take count
                           (sort counts #'rinard-compare)))))))
