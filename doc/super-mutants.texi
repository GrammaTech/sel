For many software objects, a large portion of the search time will be
spent on compiling mutants in order to test their fitness. This
overhead can be reduced significantly through the use of
super-mutants, which bundle multiple changes into a single genome,
guarded by runtime flags. This allows several mutants to be evaluated
with a single compilation.

Super-mutants can be enabled with the @code{:super-mutant-count}
argument to @code{evolve}. When this is greater than one, each
iteration of the search loop will generate the indicated number of
mutants. The mutants will then be combined into a super-mutant,
producing a single phenome which is used to evaluate all variants.

This process is almost entirely transparent to the client code. The
callback functions @code{every-pre-fn}, @code{every-post-fn} and
@code{filter} will be called individually on each mutant. The
@code{test} function will also be called on each variant, but calls to
@code{phenome} will return a wrapper which invokes the super-mutant
with the desired mutations enabled.

@subsection Limitations
@itemize
@item Super-mutants are currently only implemented for @code{clang} and
@code{clang-project} software objects.

@item Global variable declarations must match across all mutants. Declarations
may be added or deleted, however.

@item Functions must have identical arguments and return types across all
mutants. Functions may be added or deleted, but all existing copies
must match.

@end itemize

@subsection Interactions Between Mutants
When combining multiple genomes, there is some risk of interactions
between the individual mutants. These primarily relate to compilation
errors. For example, if a mutation deletes a global variable which is
referenced in the program, that would normally lead to an error. But
if that mutant is combined with another which still has the variable,
the combined mutant will compile and both will run as if the variable
was present.

Conversely, a compilation error in any mutant will cause compilation
to fail for the entire super-mutant.

If all mutants are free from compilation errors, their combination
should also compile, and its runtime behavior should be functionally
indistinguishable from that of the individual mutants.

@subsection Performance Considerations
The super-mutant genome will introduce a @code{getenv} call and a
@code{switch} statement. If these are placed in a performance-critical
function, execution time might increase significantly. If execution
time is part of the fitness evaluation, use super-mutants with
caution.

A compilation failure in a single mutant will cause @code{phenome} to
fail for the entire super-mutant. If mutations frequently introduce
compilation failures, this can lead to a lot of wasted
compilation. This problem will get worse as @code{:super-mutant-count}
increases.

Similarly, if the individual mutants are not compatible (due to
differences in global variables or function signatures), a
@code{mutate} error will be raised and the entire super-mutant
discarded. This can lead to wasted mutations.
