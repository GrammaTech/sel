SEL exports a Python library which exposes functionality for parsing,
traversing, and inspecting source code from multiple languages.
Specifically, this library exposes SEL's tree-sitter based asts (see
@ref{Source Code with @code{tree-sitter}}) and the generic functions
define upon those ASTs.  The ultimate Python library then has two
large sources of functionality, (i) the tree-sitter libraries which
provide the ability to parse a large number of programming languages
into ASTs and (ii) the SEL machinery leveraging Common Lisp's object
system (CLOS) and generic functions to build a large multi-language
API for software analysis and transformation over these ASTs.

Documentation for users of the Python library including documentation
of the API functions will be generated with Doxygen and packaged with
the library (see @b{TODO}).  This page is for SEL developers seeking
to understand how the library is built and maintained.

The remainder of this section walks through building, running, and
troubleshooting this Python Library from the perspective of a Common
Lisp developer.  From the perspective of a Python developer the use of
lisp should not be noticable.

The system setup described below may be skipped by simply using the
@code{Dockerfile.python} included in the base of the SEL repository.

SEL's @code{SOFTWARE-EVOLUTION-LIBRARY/SOFTWARE/TREE-SITTER}
(@code{sel/sw/ts}) system is exposed as a Python package.  This is a
three step process.
@enumerate
@item
First, embeddable common lisp (ECL) (see
@url{https://gitlab.com/embeddable-common-lisp/ecl}) is used to load
the @code{sel/sw/ts} system, and then compile it to a shared object.
ECL makes this relatively easy given its focus on being a lisp which
is easily embedded into C applications (@xref{,,, ecl, System
Building}).
@item
Second, the resulting C shared library is called from Python using
Python's CFFI module (see @url{https://cffi.readthedocs.io}).  This
makes it possible for a Common Lisp process to be started inside of
the Python process and for Python to call into lisp using its CFFI.
Objects are exchanged across this API as raw pointers, strings, and
integers.
@item
Finally, a regular Python library is written in Python which wraps the
CFFI interface and provides a standard Python class-based API.  This
library is kept as then as possible leaving the actual functionality
on the lisp side with the Python code limited to wrapping the CFFI
interface and implicitly Python class and method definition.
@end enumerate

@menu
* Building the SEL Python Library::
* Running the SEL Python Library::
* Troubleshooting the SEL Python Library::
@end menu

@node Building the SEL Python Library, Running the SEL Python Library, Python Library, Python Library
@section Building the SEL Python Library
@cindex building the sel python library

The build requires ECL (@pxref{,,, ecl, ECL Manual}) to compile the
common lisp @code{sel/sw/ts} package into a C shared library and
Python's CFFI (@url{https://cffi.readthedocs.io}) to call into that C
library from Python.  With these prerequesites installed the following
might be sufficient to build the library:
@example
make python-tree-sitter
@end example

However, before running this Makefile target some local configuration
is required.
@enumerate
@item
First, a set of packages which does not include any new ASDF installs
must be compiled on the user's system.  It may be possible to use your
existing local Quicklisp-downloaded packages.  However, if new
ASDF/UIOP packages are included then it might be necessary to make
coppies of all transitive dependencies of @code{sel/sw/ts} in a
separate location.

We don't use quicklisp to actually laod these packages as quicklisp
can require newer features of ASDF and UIOP and ECL @b{MUST} only be
run with the version of ASDF packaged and shipped with ECL.  This is
@emph{very important} as any other ASDF version will not successfully
compile and link C libraries of systems.

@item
ASDF must be configured to find these packages.  This can be done by
adding packages to a standard configuration location.  Specifically in:
@example
~/.config/common-lisp/source-registry.conf.d/
@end example

add a file with a name ending in @code{.conf} and the contents of that
file should give the path to your lisp system definitions.  E.g., if
you are using the same systems downloaded by quicklisp then the
following may be sufficient.
@example
(:tree "/home/username/quicklisp/local-projects/")
(:tree "/home/username/quicklisp/dists/quicklisp/software/")
@end example
@end enumerate

With requirements installed and configuration complete, let's unpack
the Makefile target.  It invokes two actions:
@enumerate
@item
First, ECL builds the shared object.
@lisp
(require :asdf) ; Required to provide ASDF functions which drive the build.
(asdf/source-registry:clear-source-registry) ; Required to re-read ASDF registry configuration
(asdf:load-system :software-evolution-library/software/tree-sitter) ; Load the system
(asdf:make-build :software-evolution-library/software/tree-sitter ; Actually build the shared library
  :prologue-code '(progn (require :asdf) ; Ensure ASDF is available at library runtime
                         (require :cffi-grovel)) ; Ensure symbols are defined for OSICAT
  :type :shared-library ; It is also possible to build a static library by changing this line
  :move-here #P"." ; Self explanatory
  :monolithic t ; Include all transitive dependencies in this single library
  :init-name "init")' ; Function called from 
@end lisp

@item
A simple C libarary wrapping this system library is written in
@code{software/tree-sitter.h} and @code{software/tree-sitter.c}.  This
library serves as the bridge betweeen lisp and Python.  Python's CFFI
is used to build the Python bindings to this library.  This is done by
running the @code{software/tree-sitter_build.py} python script.  That
file has C declarations for every function defined in
@code{tree-sitter.h}.  The result of this step is a simple Python CFFI
module which may be run directly as follows.
@example
sel$ python
Python 3.9.1 (default, Feb  3 2021, 07:38:02) 
[Clang 12.0.0 (clang-1200.0.32.29)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> from _tree_sitter_cffi import ffi, lib
>>> lib.start()
;;; Loading #P"/usr/local/lib/ecl-21.2.1/asdf.fas"
;;; Warning: No definition for IOV-MAX
;;; Warning: No definition for CFLAG-VSWTC
;;; Warning: No definition for TTY-IUCLC
;;; Warning: No definition for TTY-OLCUC
;;; Warning: Class NORMAL-SCOPE has been forward referenced.
>>> lib.eval("(format t \"Package:~S~%\" *package*)".encode('ascii'))
Package:#<"SOFTWARE-EVOLUTION-LIBRARY/SOFTWARE/TREE-SITTER" package>
<cdata 'void *' 0x1>
>>> 
@end example
@end enumerate

@node Running the SEL Python Library, Troubleshooting the SEL Python Library, Building the SEL Python Library, Python Library
@section Running the SEL Python Library
@cindex running the sel python library

The actual Python interface is defined in @code{sel.py} in this base
of the SEL repository.  This file is documented elsewhere @b{TODO}.
That documentation should take precedence, but the following
demonstrates usage of this library.

@example
sel$ python
Python 3.9.2 (default, Feb 19 2021, 17:43:04)
[Clang 12.0.0 (clang-1200.0.32.29)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import sel
;;; Loading #P"/usr/local/lib/ecl-21.2.1/asdf.fas"
;;; Warning: No definition for IOV-MAX
;;; Warning: No definition for CFLAG-VSWTC
;;; Warning: No definition for TTY-IUCLC
;;; Warning: No definition for TTY-OLCUC
;;; Warning: Class NORMAL-SCOPE has been forward referenced.
>>> it = sel.AST(sel.python, "x + 88")
>>> it.children()
[<sel.AST object at 0x1048bd460>]
>>> it.children()[0].children()
[<sel.AST object at 0x1048f7b50>]
>>> it.children()[0].children()[0].children()
[<sel.AST object at 0x104845790>, <sel.AST object at 0x1048bf280>, <sel.AST object at 0x104904cd0>]
>>> it.children()[0].children()[0].children()[1].source_text()
'+'
>>> it.children()[0].children()[0].children()[0].source_text()
'88'
>>> it.children()[0].children()[0].children()[2].source_text()
'x'
>>> it.children()[0].children()[0].source_text()
'x + 88'
>>> it.children()[0].children()[0].child_slots()
[('CHILDREN', 0), ('PYTHON-RIGHT', 1), ('PYTHON-OPERATOR', 1), ('PYTHON-LEFT', 1)]
@end example

@node Troubleshooting the SEL Python Library, , Running the SEL Python Library, Python Library
@section Troubleshooting the SEL Python Library
@cindex troubleshooting the sel python library

@enumerate
@item
Note.  If you see a error that looks similar to @code{ImportError:
dlopen(...sel/_tree_sitter_cffi.cpython-39-darwin.so, 2): Library not
loaded:
~/.cache/common-lisp/ecl...software/tree-sitter--all-systems.dylib}
then you may need to manually copy the shared library compiled by ECL
from your @code{sel/source} directory into the location mentioned in
the error.

@end enumerate
