\input texinfo
@c @setfilename emacs-web-server.info

@documentencoding utf-8
@settitle Software Evolution Library

@copying
This file documents the Software Evolution library

Copyright (C) 2014-2018 Eric Schulte and GrammaTech

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with the Invariant Section being ``GNU GENERAL PUBLIC LICENSE,''
A copy of the license is included in the section entitled
``GNU Free Documentation License.''
@end quotation
@end copying

@dircategory Libraries
@direntry
* Software Evolution: (software-evolution-library). Manipulate and evaluate software
@end direntry

@titlepage
@title Software Evolution Library
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c Output the table of the contents at the beginning.
@contents


@macro refapiclass{name}
@ref{Class \name\, @code{\name\}}
@end macro

@macro refapistruct{name}
@ref{Structure \name\, @code{\name\}}
@end macro

@macro refapivariable{name}
@ref{Variable \name\, @code{\name\}}
@end macro

@macro refapimacro{name}
@ref{Macro \name\, @code{\name\}}
@end macro

@macro refapicond{name}
@ref{Condition \name\, @code{\name\}}
@end macro

@macro refapifunction{name}
@ref{Function \name\, @code{\name\}}
@end macro

@macro refapigeneric{name}
@ref{Generic-Function \name\, @code{\name\}}
@end macro

@c Don't link to the method itself since method links are fragile
@c especially in the presence of ongoing development. Instead link to
@c the generic function but with the option of using different link
@c text.
@macro refapimethod{name,txt}
@ref{Generic-Function \name\, @code{\txt\}}
@end macro


@ifnottex
@node Top, Introduction, (dir), (dir)
@top Software Evolution Library

@insertcopying
@end ifnottex


The SOFTWARE-EVOLUTION-LIBRARY enables the programmatic modification
and evaluation of software.

A common interface abstracts over multiple types of software objects
including source code abstract syntax trees, compiled assembler code,
and binary software objects.  Software transformation, analysis, and
evaluation techniques are implemented on top of this interface
supporting automation of common software engineering tasks.


@menu
* Introduction::                What is SEL?
* Implementation::              How SEL is implemented.
* Components::                  Components provided by SEL.
* Utilities::                   Utilities provided by SEL.
* Usage::                       Using SEL, including examples.
* Troubleshooting::             Solutions for build and test issues.
* Python Library::              A Python interface to SEL.

Appendices
* Software Evolution Library Index:: Public functions, variables, and macros
* ChangeLog::                   Chronological log of notable changes by version
* General Lisp Advice::         Information for those new to Common Lisp
* SEL Coding Standards::        Development guidelines for SEL
* Contributing::                Process for contributing to SEL
* Licensing::                   Licensing for SEL and for this documentation.
* Combined Index::              Complete combined index.

@end menu



@node Introduction, Implementation, Top, Top
@chapter Introduction
@cindex introduction


The Software Evolution library enables the programmatic modification
and evaluation of extant software.

A common interface abstracts over multiple types of software objects
(@pxref{Software Objects}) including abstract syntax trees parsed from
source code, LLVM IR, and compiled assembler.
Mutation and evaluation methods (@pxref{Software Methods}) are
implemented on top of this interface supporting automation of common
software engineering tasks.  Support is included for Search Based
Software Engineering (SBSE) techniques (@pxref{Search Functions}).


@section SEL Applications

SEL has a broad range of applications for software improvement and
understanding. The following are some current and past projects
utilizing SEL.

@itemize

@item
Multiple functions underlying an integrated software development assistant.
(@url{https://grammatech.gitlab.io/Mnemosyne/docs/})

@item
Automatically resolving merge conflicts
(@url{https://mergeresolver.github.io}).

@item
Optimizing real-world software
(@url{https://github.com/eschulte/goa,github.com/eschulte/goa}).

@item
Patching vulnerabilities in closed source binaries
(@url{http://eschulte.github.io/netgear-repair,eschulte.github.io/netgear-repair}).

@item
Filling "holes" in incomplete programs whose behavior is partially
specified by unit tests and developer hints
(@url{http://cs.unm.edu/~eschulte/data/musynth-ssbse-2017.pdf,MuSynth}).

@item
Injecting bugs into software to create cyber-defense benchmarks
(@url{https://arxiv.org/pdf/1901.02819.pdf}).

@item
Decompiling binaries to C source
(@url{http://cs.unm.edu/~eschulte/data/bed.pdf,
      BED (Byte Equivalent Decompilation)}).

@item
Studying the @emph{mutational robustness} of software
(@url{http://cs.unm.edu/~eschulte/dissertation/,cs.unm.edu/~eschulte/dissertation}).

@end itemize


@section Many different kinds of software can be manipulated

The Software Evolution Library Index defines software objects using the Common Lisp Object
System (CLOS), to provide a uniform interface to many kinds of
software artifact, shown in the table below.

Additionally, the flexible design of SEL makes it possible to add new
software object kinds. See section @ref{Software Objects} for
information about creating new software objects.


@multitable {compiled assembler  ASM  } {experimental}
@item Source Code using Tree-Sitter @tab mature
@item C/C++ using Clang             @tab mature
@item Common LISP                   @tab mature
@item compiled assembler (ASM)      @tab mature
@item LLVM IR                       @tab experimental
@item CIL                           @tab experimental
@item Forth                         @tab experimental
@item Coq                           @tab experimental
@end multitable


@section Other features

SEL provides support for exploring many different aspects of both
evolutionary search and automated software manipulation.

@itemize

@item
Multiple search techniques including steady-state and generational
evolution or Markov chain Monte Carlo (MCMC).

@item
Custom mutations tailored to each software object.

@item
One- and two-point crossover.

@item
Lexicase or multi-objective fitness evaluations.

@item
Use of "fodder databases" as a source of new statements or expressions
that can be injected by mutations.

@item
Ancestry tracking of evolved software objects.

@item
Adaptive mutations which dynamically update probabilities based on
mutation success.

@item
Super-mutants to more efficiently evaluate multiple mutations in a single genome.

@end itemize


@subheading Tailored features for Clang C and C++ objects

@itemize

@item
Automatic repair for some compilation errors and warnings.

@item
Special mutations for renaming variables, changing loops, and
otherwise manipulating statements.

@end itemize



@section Getting started


First, @ref{Installation, install SEL and its dependencies}.

Once SEL is installed, try out some of the @ref{Examples, example code}.

For more detailed usage information consult the @ref{Software Evolution Library Index, API
documentation}.


@section Citing

Please cite this manual when publishing results that you have obtained
with the SOFTWARE EVOLUTION library.
@example
@@manual@{sel2018manual,
  title        = @{Software Evolution Library@},
  author       = @{Eric Schulte and Contributors@},
  organization = @{GrammaTech@},
  address      = @{eschulte@@grammatech.com@},
  month        = 1,
  year         = 2018,
  note         = @{https://grammatech.github.io/sel/@}
@}
@end example


@node Implementation, Components, Introduction, Top
@chapter Implementation
@cindex implementation

The Software Evolution library is implemented in Common Lisp and is
intended for use in Common Lisp programs.  @ref{fig:overview} provides
an overview of the Software Evolution object system, the specifics of
which are given in remainder of this section.

@menu
* Software Objects::            Representation of software
* Software Methods::            Operations on software objects
* Mutation Objects::            Representation of software mutation operations
* Global Variables::            Interface to search processes
* Search Functions::            High level functions to perform search
* REST API::                    REST API for the Software Evolution Library
@end menu

@float Figure,fig:overview
@example
                                                      search functions
 global variables                                     ----------------
 ----------------        +------------------+         incorporate
 *population*            |   *population*   |         evict
 *max-population-size*   |------------------|         tournament
 *tournament-size*       |      list of     |         mutate
 *fitness-predicate*     | software objects |         new-individual
 *cross-chance*          +------------------+         evolve
 *fitness-evals*                  |                   mcmc
 *running*                      +-+-+
                                | | |                 software methods
                         +------------------+         --------------
 evolve arguments        | software object  |         genome
 ----------------        |------------------|         phenome
 max-evals               | edits,           |         copy
 max-time                | fitness          |         pick-good,pick-bad
 target                  | ...              |         mutate
 period                  +------------------+         crossover
 period-func                       |
 filter                            |
              +--------------------+-----------------------------------------+
              |                    |                                         |
     +-----------------+      +--------------+                      +------------------+
     |       IR        |      |    simple    |                      |    parseable     |
     +-----------------+      |--------------|                      +------------------+
     |  intermediate   |      | Basic Vector |                      |    Parsed AST    |
     | representation  |      |   Genome     |-----+                |  representation  |
     +-----------------+      +--------------+     |                +------------------+
                     |                    |        |                                |
 +----------+        |                    | +--------------+   +--------------+     |
 |   LLVM   |--------+                    | |    forth     |   |    clang     |-----+
 |----------|        |                    | |--------------|   +--------------|     |
 | LLVM IR  |        |                    | | forth source |   | C/C++ source |     |
 +----------+        |                    | +--------------+   +--------------+     |
 +----------------+  |                    |                                         |
 |       CIL      |--+                    |    +------------+  +--------------+     |
 |----------------|                       +----|    asm     |  | common-lisp  |-----+
 | C Intermediate |                            |------------|  +--------------+     |
 |    Language    |                            |  assembly  |                       |
 +----------------+                            |    code    |  +--------------+     |
                                               +------------+  | tree-sitter  |-----+
                                                     |         +--------------+
                                                     |                |
                                        +------------------+   +----------------------+
                                        |    asm-range     |   | agda bash c c-sharp  |
                                        |------------------|   | cpp css go html java |
                                        | memory efficient |   |   javascript jsdoc   |
                                        +------------------+   | json julia ocaml php |
                                                               | python ql regex ruby |
                                                               |    rust scala        |
                               mixin classes                   |     typescript       |
                             -----------------                 +----------------------+

       +------------+ +-----------+ +-----------+ +------+ +------------+
       | Searchable | | Ancestral | | Styleable | | File | | Compilable |
       +------------+ +-----------+ +-----------+ +------+ +------------+
              |                                       |
         +----------------------+           +-------------------+
         | Fodder Database, ... |           | File-w-attributes |
         +----------------------+           +-------------------+
@end example
@caption{Software Evolution API.  Exported functions and variables are
shown along with the software object class hierarchy.}
@end float

@node Software Objects, Software Methods, Implementation, Implementation
@section Software Objects
@cindex software objects

The Software Evolution Library represents software as @emph{software
objects} which all inherit from the base @refapiclass{sel:software} class.
Currently many subclasses of software are defined.  These classes may
inherit from other software sub-classes, e.g. most tree-structured
source code software objects inherit from the @refapiclass{sel/sw/ts:tree-sitter} class.
The inheritance tree of software objects is shown graphically in
@ref{fig:overview}.

Table @ref{tab:objects} lists the existing software object classes
with an indicate of their relative maturity.

@float Table,tab:objects
@caption{Supported software objects listed with relative maturity.}
@multitable {} {} {}

@headitem  Software type @tab SEL Class @tab Maturity

@item Source Code using Tree-Sitter
      @tab @refapiclass{sel/sw/ts:tree-sitter}
      @tab mature

@item C and C++ source using Clang
      @tab @refapiclass{sel/sw/clang:clang}
      @tab mature

@item Common Lisp
      @tab @refapiclass{sel/sw/lisp:lisp}
      @tab mature

@item compiled assembler (ASM)
      @tab @refapiclass{sel/sw/asm:asm}
      @tab mature

@item LLVM IR
      @tab @refapiclass{sel/sw/llvm:llvm}
      @tab experimental

@item CIL
      @tab @refapiclass{sel/sw/cil:cil}
      @tab experimental

@item Forth
      @tab @refapiclass{sel/sw/forth:forth}
      @tab experimental

@item Coq source
      @tab @refapiclass{sel/sw/coq:coq}
      @tab experimental

@end multitable
@end float

These classes may also inherit from @emph{mixin} classes which provide
additional functionality which may be re-used across multiple software
object classes.  Detailed descriptions of important software object
classes and mixins (which may be added to a software objects
inheritance tree to provide additional functionality) are described in
the following subsections.

@menu
Software Object Classes
* Source Code with @code{tree-sitter}:: Source code ASTs for @emph{many} languages
* C/C++ with @code{clang}::             C language source code ASTs
* Assembler with @code{asm}::           Assembler represented as a vector
* Coq with @code{coq}::                 Coq language source code ASTs

Software Object Mixins
* Ancestor tracking with @code{ancestral}:: Collect history of applied
                                        mutations and crossover events.
* Lighter asm alternatives @code{light}/@code{range}/@code{diff}::
                                        Lighter weight alternatives to
                                        @code{simple} software.
* Inherited Indentation @code{indentation}:: Maintain correct indentation across mutations.
* Software Methods::                    Methods on software objects
@end menu

@node Source Code with @code{tree-sitter}, C/C++ with @code{clang}, Software Objects, Software Objects

@subsection Source Code with @code{tree-sitter}

@include include/tree-sitter.texi

@node C/C++ with @code{clang}, Assembler with @code{asm}, Source Code with @code{tree-sitter}, Software Objects

@subsection C/C++ with @code{clang} Software Object

@include include/clang.texi

@node Assembler with @code{asm}, Coq with @code{coq}, C/C++ with @code{clang}, Software Objects

@subsection Assembler with @code{asm} Software Object

@include include/asm.texi

@node Coq with @code{coq}, Ancestor tracking with @code{ancestral}, Assembler with @code{asm}, Software Objects

@subsection Coq with @code{coq} and @code{SerAPI}

@include include/serapi-io.texi

@include include/coq.texi

@node Ancestor tracking with @code{ancestral}, Lighter asm alternatives @code{light}/@code{range}/@code{diff}, Coq with @code{coq}, Software Objects

@subsection Ancestor tracking with @code{ancestral} Software Mixin

@include include/ancestral.texi

@node Lighter asm alternatives @code{light}/@code{range}/@code{diff}, Inherited Indentation @code{indentation}, Ancestor tracking with @code{ancestral}, Software Objects

@subsection Lighter asm alternatives @code{light}/@code{range}/@code{diff}

@subsubsection Lighter genomes with @code{light} Software Mixin

@include include/light.texi

@subsubsection Range based genomes @code{range} Software Mixin

@include include/range.texi

@subsubsection Difference genomes with @code{diff} Software Mixin

@include include/diff.texi

@node Inherited Indentation @code{indentation}, , Lighter asm alternatives @code{light}/@code{range}/@code{diff}, Software Objects

@subsection Inherited Indentation

@include include/indentation.texi

@node Software Methods, Mutation Objects, Software Objects, Software Objects

@section Software Methods
@cindex software methods


@subsection Software Genome and Phenome

A software object has both a @emph{genome} and a @emph{phenome}.
These are the two most important methods on software objects.  They
return the @emph{code} and @emph{executable} versions of the software
respectively.

@table @dfn

@item Genome
In biology, the genome is the genetic material (DNA/RNA) of the
cell. In the software evolution library, this field should contain the
instructions which define the behavior of a software object. In most
cases, the code (source or assembly), should be stored on this field.

@item Phenome
A phenome is an expression of all the traits described in the
genome. In the software evolution library, this is an executable
binary.

@c In addition to the executable, this method also returns (2) an
@c errno (a numeric indication of compilation success), (3) stderr of the
@c compilation process or a string holding error output relevant to
@c phenome generation, (4) stdout of the evolution process or a string
@c holding non-error output relevant to phenome generation, (5) the
@c source file name used during compilation.

@end table


@subsection Defining new software object types

New software objects should inherit from the most-relevant base
class. For source code based software objects, this is the
@refapiclass{sel/sw/parseable:parseable} class. To define a new software object type from an
existing base class, use the @refapimacro{sel:define-software} macro.  All
software objects should ultimately inherit from the
@refapiclass{sel:software} class.

@lisp
(define-software new-software-type (base-software-type)
  ())
@end lisp


@subsection Core methods on Software

The following lists the core methods which are defined for all
software object types exposing a common interface for use by user
programs or in heuristic search.

@itemize
@item Recover @ref{Software Objects,genome and phenome}.
    @itemize
    @item @refapigeneric{sel:genome}
    @item @refapigeneric{sel:phenome}
    @end itemize

@item Get genome properties.
    @itemize
    @item @refapigeneric{sel:genome-string}
    @item @refapigeneric{sel:lines}
    @end itemize

@item @refapigeneric{sel:copy}

@item Pick an index into the genome.
    @itemize
    @item @refapigeneric{sel:pick}
    @item @refapigeneric{sel:pick-good}
    @item @refapigeneric{sel:pick-bad}
    @item @refapigeneric{sel:pick-bad-good}
    @item @refapigeneric{sel:pick-bad-bad}
    @end itemize

@item Perform crossover on two software objects.
    @itemize
    @item @refapigeneric{sel:crossover}
    @item @refapigeneric{sel:one-point-crossover}
    @item @refapigeneric{sel:two-point-crossover}
    @end itemize


@item Input/Output.
    @itemize
    @item @refapigeneric{sel:from-file}
    @item @refapigeneric{sel:from-string}
    @item @refapigeneric{sel:to-file}
    @end itemize

@item @refapigeneric{sel:mutate}
@item @refapigeneric{sel:evaluate}
@item @refapigeneric{sel:fitness-extra-data}
@end itemize



@c DOCFIXME: Finish moving these descriptions into documentation
@c strings in the code and replacing the in-place definitions
@c with @include directives to load the automatically generated
@c documentation.






@ignore
@anchor{pick}
@defun pick software key &optional func
Randomly select elements of the genome of @code{SOFTWARE}.  Selection
may optionally be biased towards particular portions of the genome
based on a @code{key} supplied to @code{pick}.  Related
@code{pick-good} and @code{pick-bad} methods may also be customized.
@end defun

@anchor{mutate}
@defun mutate software
Randomly mutate the supplied software object.  The modified software
object and the applied mutation are returned.
@end defun

@anchor{crossover}
@defun crossover software-a software-b
Perform the specified form of crossover on two software objects
returning a new software object and information on the crossover
operation performed (e.g., the indices of crossover).  The related
@code{one-point-crossover} and @code{two-point-crossover} methods may
also be used to perform particular types of crossover.
@end defun

@anchor{from-file}
@defun from-file software file
Initialize a software object @code{SOFTWARE} using the contents of
@code{FILE}.
@end defun

@anchor{to-file}
@defun to-file software file
Write the genome of software object @code{SOFTWARE} to @code{FILE}.
@end defun

@end ignore


@node Mutation Objects, Global Variables, Software Methods, Implementation
@section Mutation Objects
@cindex Mutation

@c DOCFIXME need more intro

SEL provides a variety of operations that apply @emph{mutations} to
modify code. These mutations are represented as @refapiclass{sel:mutation}
objects.



See the @ref{Software Evolution Library Index} for full API
documentation. We provide a brief outline here.

New @refapiclass{sel:mutation} subclasses should derive from the
most-relevant base class. To define a new mutation from an existing
base class, use

@lisp
(define-mutation new-mutation (base-mutation)
  ())
@end lisp

The mutation may be initialized with two functions; a targeter and
picker. The targeter is a function which, given a software object,
returns a list of mutation targets; this function defaults to
@refapigeneric{sel:pick-bad}. The picker is a function which, given a software
object, returns a random mutation target; this function defaults to a
random element returned by @refapigeneric{sel:pick-bad}.

After creating a software object and a mutation, use the
@refapigeneric{sel:apply-mutation} method to create a new mutant.




@node Global Variables, Search Functions, Mutation Objects, Implementation
@section Global Variables
@cindex Global Variables

The following global variables are exposed for configuration and
interaction with heuristic search processes. This table contains summary information only, see the @ref{Software Evolution Library Index} section for full details.

@multitable {} {}

@item @refapivariable{sel:*population*} @tab
A list of the software objects currently known to the system.

@item @refapivariable{sel:*max-population-size*} @tab
Maximum allowable population size.

@item @refapivariable{sel:*generations*} @tab
The running generation count.

@item @refapivariable{sel:*tournament-size*} @tab
Number of individuals to participate in tournament selection.

@item @refapivariable{sel:*tournament-eviction-size*} @tab
Number of individuals to participate in eviction tournaments.

@item @refapivariable{sel:*tournament-selector*} @tab
Function used to select winners of a tournament.

@item @refapivariable{sel:*tournament-tie-breaker*} @tab
Function used to break ties when a tournament has multiple
winners.

@item @refapivariable{sel:*tie-breaker-predicate*} @tab
Function to compare two tie breaker values to select which is
preferred.

@item @refapivariable{sel:*fitness-predicate*} @tab
Function to compare two fitness values to select which is preferred.


@item @refapivariable{sel:*cross-chance*} @tab
Fraction of new individuals generated using crossover rather than
mutation.

@item @refapivariable{sel:*mut-rate*} @tab
Chance to mutate a new individual.

@item @refapivariable{sel:*fitness-evals*} @tab
Tracks the total number of fitness evaluations
performed.

@item @refapivariable{sel:*running*} @tab
True when a search process is running, set to nil to
stop a running search.

@end multitable


@node Search Functions, REST API, Global Variables, Implementation
@section Search Functions
@cindex search functions

Currently two high-level search functions are implemented:
@code{evolve} and @code{mcmc}.  The @code{evolve} search function has
received much more testing and is recommended.


@table @dfn

@item @refapimacro{sel:evolve}
Evolve the existing @refapivariable{sel:*population*} of
@refapiclass{sel:software} objects using a supplied test function to
evaluate the fitness of software objects. A steady state evolutionary
computation algorithm is used to evolve increasingly fit software
objects in a process resembling natural selection.

@item @refapimacro{sel:mcmc}
Perform Markov chain Monte Carlo search from a supplied
@refapiclass{sel:software} object using a supplied test function
to evaluate the fitness of software objects.  The fitness returned by
the test function is optimized.

@end table


@ignore
@anchor{evolve}
@defun evolve test &key max-evals max-time target period period-fn every-fn filter
Evolve the existing @code{*population*} of software objects using the
supplied @code{TEST} function to evaluate the fitness of software
objects.  The fitness returned by the @code{TEST} function is
optimized.  A steady state evolutionary computation algorithm is used
to evolve increasingly fit software objects in a process resembling
natural selection.
@end defun

@anchor{mcmc}
@defun mcmc original test &key accept-fn max-evals max-time target period period-fn every-fn filter
Perform Markov chain Monte Carlo search from the supplied
@code{ORIGINAL} software object using the supplied @code{TEST}
function to evaluate the fitness of software objects.  The fitness
returned by the @code{test} function is optimized.
@end defun

Both functions take the following optional keyword arguments

@table @code
@item max-evals
stop after this many fitness evaluations

@item max-time
stop after this many seconds

@item target
stop when an individual passes @code{TARGET-FIT}

@item period
interval of fitness evaluations to run @code{PERIOD-FN}

@item period-fn
function to run every @code{PERIOD} fitness evaluations

@item every-fn
function to run before every fitness evaluation

@end table

In addition the @code{evolve} function takes an optional @code{filter}
keyword argument which when specified only includes individual for
which @code{FILTER} returns true, and the @code{mcmc} function takes
an optional @code{accept-fn} keyword argument which is a function of
current and new fitness that returns acceptance.
@end ignore


@node REST API, REST Server, Search Functions, Implementation
@section REST API
@cindex rest api

@menu
* REST Server::                 Using the rest server
* REST Interface::              Standard RESTful interface over SEL
* REST Sessions::               Interface for managing RESTful sessions
* Async Jobs::                  RESTful asynchronous job interface
@c * Defining a Command Endpoint:: RESTful interface for command endpoints
@end menu

@node REST Server, REST Interface, REST API, REST API

@include include/rest.texi

@node REST Interface, REST Sessions, REST Server, REST API

@include include/rest-std-api.texi

@node REST Sessions, Async Jobs, REST Interface, REST API

@include include/rest-sessions.texi

@node Async Jobs, , REST Sessions, REST API

@include include/rest-async-jobs.texi

@c NOTE: For some reason this one isn't showing up...
@c @node Defining a Command Endpoint, Components, Async Jobs, REST API
@c
@c @include include/rest-define-command-endpoint.texi

@node Components, Test Suites, Implementation, Top
@chapter Components
@cindex components

In addition to the software objects, method and evolutionary
infrastructure described in the previous section @ref{Implementation},
the Software Evolution Library includes many ``components.''  Each
component is a self-contained unit used to evaluate or manipulate
software objects.  Some components are implemented as classes which
may be @i{mixed in} with software objects which others are functions
on software objects, or extensions to the basic evolutionary
infrastructure.

@menu
* Test Suites::                 Running unit tests
* Multi-objective Fitness::     Optimizing multiple objectives
* Style Features::              Extracting source code features
* Clang C Tokenizer::           Tokenize software objects
* Super-Mutants::               Evaluate multiple variants in a single genome
* Configuration::               Configure software representations with files
* Utilities::                   Utilities
@end menu

@node Test Suites, Multi-objective Fitness, Components, Components
@section Test Suites
@cindex test-suite
@include test-suite.texi

@node Multi-objective Fitness, Style Features, Test Suites, Components
@section Multi-objective Fitness
@cindex multi-objective fitness
@include multi-objective-fitness.texi

@node Style Features, Clang C Tokenizer, Multi-objective Fitness, Components
@section Style Features
@cindex style-features
@include style-features.texi

@node Clang C Tokenizer, Super-Mutants, Style Features, Components
@section Clang C Tokenizer
@cindex tokenizer
@include tokenizer.texi

@node Super-Mutants, Configuration, Clang C Tokenizer, Components
@section Super-Mutants
@cindex super-mutants
@include include/super-mutant.texi

@node Configuration, Utilities, Super-Mutants, Components
@section Configuration
@cindex configuration
@include include/configuration.texi

@node Utilities, Basic Utilities, Super-Mutants, Components
@chapter Utilities
@cindex utilities

The Software Evolution Library provides utilities packages, including
the @code{GT} package (see @ref{Basic Utilities}) and the
@code{SEL/VIEW}.  This chapter documents these utilities.

@menu
* Basic Utilities::             Basic Utilities covering a range of uses
* View::                        A simple GUI for SEL applications
* Task::                        Infrastructure to use multiple threads
@end menu

@node Basic Utilities, View, Utilities, Utilities
@section Basic Utilities

Note.  The SEL utilities have largely been moved to a new GT library
available at @url{https://github.com/grammatech/cl-utils}.  This library
is now also available in quicklisp, and need not be installed separately.

@node View, Task, Basic Utilities, Utilities
@section View
@include include/view.texi

@node Task, Usage, View, Utilities
@section Task
@include include/task.texi

@node Usage, Installation, Task, Top
@chapter Usage
@cindex usage


@menu
* Installation:: Installing SEL and its dependencies
* Examples:: A series of examples demonstrating some SEL applications.
@end menu



@node Installation, Windows Installation, Usage, Usage
@section Installation

TLDR; If you already have a Common Lisp development environment setup
the Software Evolution Library (SEL) can be installed from QuickLisp
by running @code{(ql:quickload :software-evolution-library)}, however
many components and software types have additional dependencies.

Note: The following instructions assume you are running a Linux or
macOS operating system, for installation Windows see @ref{Windows
Installation}.

SEL is currently only tested against @url{https://www.cliki.net/SBCL,
Steel Bank Common Lisp (SBCL)} @url{https://www.cliki.net/CCL, Clozure
Common Lisp (CCL)} and requires ASDF version 3.3.x or greater.

The source code for SEL is available at
@url{https://github.com/GrammaTech/sel}.  SEL and its Common Lisp
dependencies are installable through Quicklisp (see
@url{http://www.quicklisp.org/}).

@float Table,tab:dependencies
@caption{Additional dependencies for specific software objects.}
@multitable {} {} {} {}

External dependencies are required for some software object subclasses
that require external parsers.  For all languages evaluation of
software objects require that the language's compiler or interpreter
is available.

@headitem  Software type @tab Class @tab Dependency @tab URL

@item Source Code for many languages @tab @refapiclass{sel/sw/ts:tree-sitter} @tab tree-sitter @tab @url{https://tree-sitter.github.io/tree-sitter/}

@item Alternate C/CPP Source Code @tab @refapiclass{sel/sw/clang:clang} @tab clang v10.0+ @tab @url{https://github.com/llvm/llvm-project}

@item Coq @tab @refapiclass{sel/sw/coq:coq} @tab SerAPI @tab @url{https://github.com/ejgallego/coq-serapi}

@end multitable
@end float

@menu
* Windows Installation:: Installing SEL on Windows
@end menu

@node Windows Installation, Examples, Installation, Installation
@subsection Windows Installation

The following instructions start from a clean machine and install SEL
in a VirtualBox VM.  If you want to install SEL directly on your
existing Windows machine you can skip to the ``Windows Common Lisp''
step.  (This is a work in progress.)

@subsubsection Windows OS Installation
@enumerate
@item
Install Windows 10 Pro (64-bit). 8 gigs memory, 2 cores, 80 gb hard drive
@item
Install VirtualBox guest tools for Windows.
@item
Install SNMP
@item
In Powershell (Run as Administrator):
@example
Add-WindowsCapability -Online -Name "SNMP.Client~~~~0.0.1.0"
@end example
@end enumerate

@subsubsection Windows Utilities
@enumerate
@item
Install Chrome browser, make it default browser for Windows.
@item
Install Git for 64-bit Windows. Accept all defaults.
@item
Install 7-zip. @url{https://www.7-zip.org/}
@item
Install gnu emacs 26.1 for Windows 64-bit.
@end enumerate

@subsubsection Windows Common Lisp
@enumerate
@item
Install Clozure CL. @url{https://ccl.clozure.com}
@item
Install quicklisp: quicklisp.org
@item
Install slime (using CCL instructions: @url{https://trac.clozure.com/ccl/wiki/InstallingSlime})
In ccl:
@example
(ql:quickload :asdf) ; to upgrade version of asdf to 3.3.x, needed for LAUNCH-PROGRAM support
@end example
@end enumerate

@subsubsection Windows SEL
Clone SEL from @url{https://github.com/GrammaTech/sel} or install
using QuickLisp.

@subsubsection Windows Development Software
@enumerate
@item
Install Windows 10 SDK:
@url{https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk}

@item
Visual Studio:
Install Visual Studio Community Edition 2019
@url{https://visualstudio.microsoft.com/vs/}

Make sure to include C and C++ support in the installation options.

@end enumerate

@subsubsection Windows clang/LLVM 10.0
This is required to use SEL's C/C++ front.

Install Windows 64-bit pre-built binary.

Found it in a snapshot release here: @url{https://llvm.org/builds}
(it is still pre-release).

@subsubsection Windows WSL
This is not required but a useful enhancement.

@enumerate
@item
In Windows Features control panel:
Enable Windows Subsystem for Linux (WSL). Restart.
Go to Microsoft App Store: Install Ubuntu 18.04
After install, launch it (this will finish the install process)
Create a user/password.
@example
sudo apt-get install update
sudo apt-get install upgrade
@end example

@item
Create a shared folder (to access the linux host)
Assuming shared folder is drive z:, mount it:
@example
sudo mkdir /mnt/z
sudo mount -t drvfs Z: /mnt/z
@end example
@end enumerate

@node Examples, Mutation, Windows Installation, Usage
@section Examples

The examples in this section illustrate various applications of the
software evolution library.

We start with a C program for computing the greatest common
demominator (gcd) of two numbers. The source file is available in
@code{test/etc/gcd/gcd.c}, and reproduced below.


@verbatiminclude ./test/etc/gcd/gcd.c

(You may notice at this point that the C code is buggy and does not
compute correct gcd for all inputs. The @ref{Repair} example will
demonstrate how SEL can be used to create a repaired version of the
program.)


The examples operate on the ASM file compiled from @code{gcd.c}. If
you would like to try out the examples yourself, compile @code{gcd.c}
to ASM. For example:

@example
$(CC) gcd.c -S -o gcd.s
@end example




@menu
* Mutation::                    Mutate a program
* Evaluation::                  Evaluate the fitness of a mutant
* Neutral Variants::            Generate neutral variants of a program
* Repair::                      Repair a program
@c * Memoize Fitness::             A global memoized genome-fitness map
@c * Annotations::                 Annotating portions of the genome
@c * Focused Mutation::            Using annotations to focus mutation operations
@c * Execution Statistics::        Saving statistics
@end menu
@node Mutation, Evaluation, Examples, Examples
@subsection Mutation
@cindex example mutation


The @refapigeneric{sel:mutate} method applies a random mutation to a
@refapiclass{sel:software} object and returns two values: the mutated
object and a @refapiclass{sel:mutation} object describing the mutation
that was applied.

The following example applies a random mutation to @code{gcd.s}.


@enumerate

@item Uses @refapigeneric{sel:from-file} to load @code{gcd.s} into a new @refapiclass{sel/sw/asm:asm} software object, @code{orig}.

@item Applies @refapigeneric{sel:mutate} to mutate a deep @refapigeneric{sel:copy} of @code{orig}.

@item Writes the mutated object to disk with @refapigeneric{sel:to-file}.

@item Prints the @refapiclass{sel:mutation} that was applied.
@end enumerate

@verbatiminclude ./doc/examples/001-mutate.lisp


Executing this code will print output resembling the following.

@example
Results of applying #<SIMPLE-CUT #<ASM #x3020022A24DD> 78> to gcd written to "/\
tmp/fileLfs6Mf.s".
@end example


@subsubheading API components in this example


@itemize
@item Class @refapiclass{sel/sw/asm:asm}
@item Methods
  @itemize
  @item @refapigeneric{sel:copy}
  @item @refapigeneric{sel:from-file}
  @item @refapigeneric{sel:mutate}
  @item @refapigeneric{sel:to-file}
  @end itemize
@end itemize


@node Evaluation, Neutral Variants, Mutation, Examples
@subsection Evaluation
@cindex example evaluation

Once we are mutating programs, we need to be able to evaluate each
variant and keep track of the evaluation results.

We have provided a shell script @code{test.sh}, which contains several
gcd test cases. Our fitness function will be the number of test cases
for which a program produces the correct solution.

Once a fitness value for a @refapiclass{sel:software} object is
established, it can be recorded in the object's @code{fitness} field.


The example code below has two main components:

@itemize
@item A @code{test} function that harnesses the @code{test.sh} script to evaluate the fitness of an individual @refapiclass{sel/sw/asm:asm} object.

@item A loop in which ten mutants of the   @refapiclass{sel/sw/asm:asm} object corresponding to the original @code{gcd.s} program are generated, their fitness assessed, and the results printed.
@end itemize

@ignore
The example code below does the following.
@enumerate
@item
Defines a @code{test} function used to evaluate the fitness of a
software object.  This function makes use of an external shell script
test driver which is run using the @code{shell} function defined in
the @ref{SEL Utility API}.

@item
The original program is initialized from a file on disk.

@item
Ten mutants of the original are generated by applying random edits.

@item
The @code{fitness} field of each mutant is set using the previously
defined @code{test} method.

@item
The edits and fitness of each mutant are printed.

@end enumerate

@end ignore


@verbatiminclude ./doc/examples/002-evaluation.lisp

Executing this code will print output resembling the following.

@c TODO: Figure out if/why this doesn't seem to work currently.

@example
 0 fitness for edit (:INSERT 76 38)
 0 fitness for edit (:SWAP 66 77)
 0 fitness for edit (:CUT 50)
10 fitness for edit (:CUT 11)
10 fitness for edit (:SWAP 62 39)
 0 fitness for edit (:INSERT 2 48)
10 fitness for edit (:CUT 66)
 0 fitness for edit (:CUT 73)
10 fitness for edit (:INSERT 73 26)
 0 fitness for edit (:INSERT 71 1)
@end example



@subsubheading API components in this example

@itemize
@item Class @refapiclass{sel/sw/asm:asm}
@item Methods
  @itemize
  @item @refapigeneric{sel:copy}
  @item @refapigeneric{sel:from-file}
  @item @refapigeneric{sel:mutate}
  @item @refapigeneric{sel:phenome}
  @end itemize
@end itemize




@node Neutral Variants, Repair, Evaluation, Examples
@subsection Neutral Variants
@cindex neutral variants


In some cases we are interested in ``neutral mutants'': variants of
the original program that still satisfy the test suite. (For more information,
see @cite{Software Mutational Robustness} available at @url{http://arxiv.org/abs/1204.4224}).


The following example constructs a collection of neutral mutants of
@code{gcd.c}, using the @code{test} function defined in the
@ref{Evaluation} example to determine whether or not candidate
variants have equivalent behavior to the original.

@verbatiminclude ./doc/examples/003-neutral.lisp


@subsubheading API components in this example


@itemize
@item Class @refapiclass{sel/sw/asm:asm}
@item Methods
  @itemize
  @item @refapigeneric{sel:copy}
  @item @refapigeneric{sel:from-file}
  @item @refapigeneric{sel:mutate}
  @end itemize
@end itemize




@node Repair, Troubleshooting, Neutral Variants, Examples
@subsection Repair
@cindex repair

The sample gcd program is failing one of the test cases in
@code{test.sh}, so we know it contains at least one bug.  We can use
evolutionary search to look for a ``repair'' for this buggy
implementation: a mutant that passes every test case in the script.

As before, we use the @code{test} function defined in the
@ref{Evaluation} example to measure the fitness of each program
variant. This time, @code{test} is used as the fitness test in
applying @refapimacro{sel:evolve} to a @refapivariable{sel:*population*}
initialized with 100 copies of the original program. Variable
@refapivariable{sel:*target-fitness-p*} is set up so that the search will
terminate when a member of the population has a fitness value that
indicates it is passing all of the tests; @refapimacro{sel:evolve}'s
keyword argument @code{:max-evals} ensures that execution will always
terminate after at most 100 fitness evaluations.

@ignore
The following properties of this example should be noted.

@enumerate
@item
Before calling @code{evolve} the population is populated with copies
of the original program.

@item
The @code{*orig*} individual is assigned a fitness before the
@code{*population*} is populated.  This is necessary as the search
functions assume that every element of @code{*population*} already
have a fitness assigned.

@item
The @code{*population*} is not explicitly passed to the @code{evolve}
function which implicitly modifies the @code{*population*} variable.
When this function terminates the evolved program variants will be
saved in the @code{*population*}.
@end enumerate
@end ignore


@verbatiminclude ./doc/examples/004-evolve.lisp

@subsubheading API components in this example




@itemize
@item Class @refapiclass{sel/sw/asm:asm}
@item Macro @refapimacro{sel:evolve}
@item Methods
  @itemize
  @item @refapigeneric{sel:copy}
  @item @refapigeneric{sel:from-file}
  @end itemize
@item Variables
  @itemize
  @item @refapivariable{sel:*population*}
  @item @refapivariable{sel:*target-fitness-p*}
  @item @refapivariable{sel:*fitness-predicate*}
  @end itemize
@end itemize


@subsection Parallel Repair
@cindex parallel repair

Evolution may be parallelized by calling @refapimacro{sel:evolve} in multiple
threads.

For example a parallel version of the previous example would
replace,

@lisp
(let ((*target-fitness-p* [@{= 11@} #'fitness]))
  (evolve #'test :max-evals 100))
  @end lisp

with the following.

@lisp
(require 'bordeaux-threads)
(defvar *num-threads* 64 "Number of available cores.")

;; launch *num-threads* evolution threads
(let ((*target-fitness-p* [@{= 11@} #'fitness]))
  (let (threads)
      (loop :for n :below *num-threads* :do
             (push (bordeaux-threads:make-thread
                           (lambda () (evolve #'test :max-evals 100))
                                         :name (format nil "opt-~d" n))
                                                      threads))))

;; wait for all threads to return
(mapc #'bordeaux-threads:join-thread threads)
@end lisp


@c @node Annotations, Focused Mutation, Parallel Fitness Evaluation, Usage Examples
@c @section Annotations
@c @cindex annotations

@c @node Focused Mutation, Execution Statistics, Annotations, Usage Examples
@c @section Focused Mutation
@c @cindex focused mutation

@c @node Execution Statistics, Memoize Fitness, Focused Mutation, Usage Examples
@c @section Execution Statistics
@c @cindex execution statistics

@c @node Memoize Fitness, Neutral Variants, Execution Statistics, Usage Examples
@c @section Memoize Fitness
@c @cindex memoize fitness

@node Troubleshooting, Python Library, Repair, Top
@chapter Troubleshooting
@cindex troubleshooting
@include troubleshooting.texi

@node Python Library, Software Evolution Library Index, Troubleshooting, Top
@chapter Python Library
@cindex python-library
@include python-library.texi

@include include/sb-texinfo.texinfo
@include software-evolution-library-index-sb-texinfo.texi

@node ChangeLog, General Lisp Advice, Software Evolution Library Index, Top
@appendix ChangeLog
@include changelog.texi

@node General Lisp Advice, SEL Coding Standards, ChangeLog, Top
@appendix General Lisp Advice
@include general-lisp-advice.texi

@node SEL Coding Standards, Contributing, General Lisp Advice, Top
@appendix SEL Coding Standards
@include sel-coding-standards.texi

@node Contributing, Licensing, SEL Coding Standards, Top
@appendix Contributing
@include contributing.texi

@node Licensing, Copying, Contributing, Top
@appendix Licensing
@menu
* Copying::                     The GNU General Public License gives
                                you permission to redistribute GNU Emacs on
                                certain terms; it also explains that there is
                                no warranty.
* GNU Free Documentation License::  The license for this documentation.
@end menu


@node Copying, GNU Free Documentation License, Licensing, Licensing
@appendixsec Copying: GNU GENERAL PUBLIC LICENSE
@include gpl.texi


@node GNU Free Documentation License, Combined Index, Copying, Licensing
@appendixsec GNU Free Documentation License
@include doclicense.texi

@node Combined Index,  , GNU Free Documentation License, Top
@unnumbered Combined Index

@c Combine all index (function variable type and concept) types into a
@c single index.
@syncodeindex fn cp
@syncodeindex vr cp
@syncodeindex tp cp
@printindex cp

@bye
