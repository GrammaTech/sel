\input texinfo
@c @setfilename emacs-web-server.info

@documentencoding utf-8
@settitle Software Evolution Library

@copying
This file documents the Software Evolution library

Copyright (C) 2014-2018 Eric Schulte and GrammaTech

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with the Invariant Section being ``GNU GENERAL PUBLIC LICENSE,''
A copy of the license is included in the section entitled
``GNU Free Documentation License.''
@end quotation
@end copying

@dircategory Libraries
@direntry
* Software Evolution: (software-evolution-library). Manipulate and evaluate software
@end direntry

@titlepage
@title Software Evolution Library
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c Output the table of the contents at the beginning.
@contents


@macro refapiclass{name}
@ref{Class \name\, @code{\name\}}
@end macro

@macro refapistruct{name}
@ref{Structure \name\, @code{\name\}}
@end macro

@macro refapivariable{name}
@ref{Variable \name\, @code{\name\}}
@end macro

@macro refapimacro{name}
@ref{Macro \name\, @code{\name\}}
@end macro

@macro refapicond{name}
@ref{Condition \name\, @code{\name\}}
@end macro

@macro refapifunction{name}
@ref{Function \name\, @code{\name\}}
@end macro

@macro refapigeneric{name}
@ref{Generic-Function \name\, @code{\name\}}
@end macro

@c Don't link to the method itself since method links are fragile
@c especially in the presence of ongoing development. Instead link to
@c the generic function but with the option of using different link
@c text.
@macro refapimethod{name,txt}
@ref{Generic-Function \name\, @code{\txt\}}
@end macro


@ifnottex
@node Top, Introduction, (dir), (dir)
@top Software Evolution Library

@insertcopying
@end ifnottex


Software Evolution Library (SEL) is a Common Lisp library for using
evolutionary search to programmatically modify and evaluate software.
It provides a common interface which abstracts over several kinds of
software objects including parsed abstract syntax trees, intermediate
languages, compiled assembler, or binaries.

Methods for evolution, mutation, crossover, and fitness evaluation are
implemented on top of this interface, supporting Search Based Software
Engineering (SBSE) techniques.


@menu
* Introduction::                What is SEL?
* Implementation::              How SEL is implemented.
* Components::                  Components provided by SEL.
* Utilities::                   Utilities provided by SEL.
* Usage::                       Using SEL, including examples.
* Troubleshooting::             Solutions for build and test issues.


SEL API Reference
* SEL API::                     Public functions, variables, and macros
* SEL Utility API::             Public functions, variables, and macros
* SEL View API::                Public functions, variables, and macro

Appendices
* General Lisp Advice::         Information for those new to Common Lisp
* SEL Coding Standards::        Guidance for contribution to SEL
* ChangeLog::                   Chronological log of notable changes by version
* Licensing::                   Licensing for SEL and for this documentation.
* Index::                       Complete index.

@end menu



@node Introduction, Implementation, Top, Top
@chapter Introduction
@cindex introduction


The Software Evolution library enables the programmatic modification
and evaluation of extant software.  The software evolution library was
developed as part of the genprog project on automated program repair.

A common interface abstracts over multiple types of software objects
(@pxref{Software Objects}) including abstract syntax trees parsed from
source code, LLVM IR, compiled assembler, and linked ELF binaries.
Mutation and evaluation methods (@pxref{Software Methods}) are
implemented on top of this interface supporting Search Based Software
Engineering (SBSE) techniques (@pxref{Search Functions}).


@section SEL Applications

SEL has a broad range of applications for software improvement and
understanding. The following are some current and past projects
utilizing SEL.

@itemize

@item
Optimizing real-world software
(@url{https://github.com/eschulte/goa,github.com/eschulte/goa}).

@item

Patching vulnerabilities in closed source binaries
(@url{http://eschulte.github.io/netgear-repair,eschulte.github.io/netgear-repair}).

@item
Filling "holes" in incomplete programs whose behavior is partially
specified by unit tests and developer hints
(@url{http://cs.unm.edu/~eschulte/data/musynth-ssbse-2017.pdf,MuSynth}).

@item
Adapting  software for
@url{https://www.darpa.mil/program/building-resource-adaptive-software-systems,DARPA's BRASS program}.

@item
Injecting bugs into software to create cyber-defense benchmarks
(@url{https://www.grammatech.com/sponsored-research,BUG-INJECTOR}).

@item
Decompiling binaries to C source
(@url{http://cs.unm.edu/~eschulte/data/bed.pdf,
      BED (Byte Equivalent Decompilation)}).

@item
Studying the @emph{mutational robustness} of software
(@url{http://cs.unm.edu/~eschulte/dissertation/,cs.unm.edu/~eschulte/dissertation}).

@end itemize


@section Many different kinds of software can be manipulated

The SEL API defines software objects using the Common Lisp Object
System (CLOS), to provide a uniform interface to many kinds of
software artifact, shown in the table below.

Additionally, the flexible design of SEL makes it possible to add new
software object kinds. See section @ref{Software Objects} for
information about creating new software objects.


@multitable {compiled assembler  ASM  } {experimental}
@item C and C++ source         @tab mature
@item compiled assembler (ASM) @tab mature
@item linked ELF binaries      @tab mature
@item LLVM IR                  @tab experimental
@item CIL                      @tab experimental
@item LISP                     @tab experimental
@item Forth                    @tab experimental
@item Java                     @tab experimental
@item Coq                      @tab experimental
@end multitable


@section Other features

SEL provides support for exploring many different aspects of both
evolutionary search and automated software manipulation.

@itemize

@item
Multiple search techniques including steady-state and generational
evolution or Markov chain Monte Carlo (MCMC).

@item
New mutations tailored to each software object.

@item
One- and two-point crossover.

@item
Lexicase or multi-objective fitness evaluations.

@item
Instrumentation of software objects and dynamic trace collection.

@item
Use of "fodder databases" as a source of new statements or expressions
that can be injected by mutations.

@item
Ancestry for candidate solutions.

@item
Adaptive mutations to dynamically update probabilities based on
mutation success.

@item
Super-mutants to evaluate multiple mutations in a single genome.

@end itemize


@subheading Tailored feautures for for C and C++ objects

@itemize

@item
Automatic repair for some compilation errors and warnings.

@item
Special mutations for renaming variables, changing loops, and
otherwise manipulating statements.

@item
Spectrum-based fault localization, which instruments source code and
runs (passing and failing) unit tests to attempt to locate errors.

@item
Condition synthesis, a repair technique
@url{http://groups.csail.mit.edu/pac/patchgen/papers/spr-fse15.pdf, described by Long and Rinard}
which tries to synthesize conditional statements that will correct
source code so that it passes failing unit tests.

@end itemize



@section Getting started


First, @ref{Installation, install SEL and its dependencies}.

Once SEL is installed, try out some of the @ref{Examples, example code}.

If you are ready to try using SEL in your own code, consult the
@ref{SEL API, API documentation}.


@section Citing

Please cite Eric Schulte's Ph.D. dissertation when you publish results
that you have obtained with the SOFTWARE EVOLUTION library (see
@cite{Neutral Networks of Real-World Programs and their Application to
Automated Software Evolution} available at
@url{https://cs.unm.edu/~eschulte/dissertation}).



@node Implementation, Software Objects, Introduction, Top
@chapter Implementation
@cindex implementation

The Software Evolution library is implemented in Common Lisp and is
intended for use in Common Lisp programs.  @ref{fig:overview} provides
an overview of the Software Evolution system, the specifics of which
are given in remainder of this section.

@menu
* Software Objects::            Representation of software
* Software Methods::            Operations on software objects
* Mutation Objects::            Representation of software mutation operations
* Global Variables::            Interface to search processes
* Search Functions::            High level functions to perform search
* REST API::                    REST API for the Software Evolution Library
@end menu

@float Figure,fig:overview
@example
                                                      population functions
 global variables                                     --------------------
 ----------------        +------------------+         incorporate
 *population*            |   *population*   |         evict
 *max-population-size*   |------------------|         tournament
 *tournament-size*       |      list of     |         mutate
 *fitness-predicate*     | software objects |         new-individual
 *cross-chance*          +------------------+         evolve
 *fitness-evals*                  |                   mcmc
 *running*                      +-+-+
                                | | |                 software functions
                         +------------------+         --------------
 evolve arguments        | software object  |         genome
 ----------------        |------------------|         phenome
 max-evals               | edits,           |         copy
 max-time                | fitness          |         pick-good,pick-bad
 target                  | ...              |         mutate
 period                  +------------------+         crossover
 period-func                       |
 filter                            |             +--------------+
               +-------------------+-------------|    simple    |
               |                                 |--------------|
     +-----------------+   +-------------+       | Basic Vector |
     |     Source      |   |    lisp     |-------|   Genome     |-----+
     +-----------------+   |-------------|       +--------------+     |
     | Textual source  |   | lisp source |           |       | +--------------+
     |  representation |   +-------------+   +------------+  | |    forth     |
     +-----------------+                     |    ELF     |  | |--------------|
               |                             |------------|  | | forth source |
               |                             | Executable |  | +--------------+
       +---------+------------+              |  Linkable  |  |
       |         |            |              |   Format   |  |    +------------+
+-------------+  |   +----------------+      +------------+  +----|    asm     |
|     Java    |  |   |       CIL      |  +----------+   |         |------------|
|-------------|  |   |----------------|  | elf-risc |---+         |  assembly  |
| Java source |  |   | C Intermediate |  +----------+   |         |    code    |
+-------------+  |   |    Language    |  +----------+   |         +------------+
                 |   +----------------+  | elf-cisc |---+               |
                 |                       +----------+                   |
        +--------+------------+                             +------------------+
        |                     |                             |     asm-range    |
  +----------+          +-------------+                     |------------------|
  |   LLVM   |          |  Parseable  |                     | memory efficient |
  |----------|          +-------------+                     +------------------+
  | LLVM IR  |   +------| Parsed ASTs |
  +----------+   |      +-------------+
                 |            |       +------------+ +-----------+ +-----------+
      +-----------------+ +-------+   | Searchable | | Ancestral | | Traceable |
      |   JavaScript    | | Clang |   +------------+ +-----------+ +-----------+
      +-----------------+ |-------|          |
      |  JavaScript AST | | C AST |     +-----------------+
      +-----------------+ +-------+     | Fodder Database |
                                        +-----------------+
                                          |            |
                                     +----------+  +--------------------+
                                     | Pliny DB |  | In Memory Database |
                                     +----------+  +--------------------+
                                                             |
                                                        +---------+
                                                        | JSON DB |
                                                        +---------+
@end example
@caption{Software Evolution API.  Exported functions and variables are
shown along with the software object class hierarchy.}
@end float

@node Software Objects, Software Methods, Implementation, Implementation
@section Software Objects
@cindex software objects

The Software Evolution Library represents software as @emph{software
objects} which all inherit from the base @refapiclass{software} class.
Currently many subclasses of software are defined.  These classes may
inherit from other software sub-classes, e.g. most tree-structured
source code software objects inherit from the @refapiclass{parseable} class.
The inheritance tree of software objects is shown graphically in
@ref{fig:overview}.

Table @ref{tab:objects} lists the existing software object classes
with an indicate of their relative maturity.

@float Table,tab:objects
@caption{Supported software objects listed with relative maturity.}
@multitable {} {} {}

@headitem  Software type @tab SEL Class @tab Maturity

@item C and C++ source
      @tab @refapiclass{clang}
      @tab mature

@item compiled assembler (ASM)
      @tab @refapiclass{asm}
      @tab mature

@item linked ELF binaries @* (manipulated as assembler)
      @tab @refapiclass{csurf-asm}
      @tab mature

@item linked ELF binaries
      @tab @refapiclass{elf-mips} @*  @refapiclass{elf-cisc}
      @tab mature (not recommended)

@item Java source
      @tab @refapiclass{java}
      @tab experimental

@item JavaScript source
      @tab @refapiclass{javascript}
      @tab experimental

@item LLVM IR
      @tab @refapiclass{llvm}
      @tab experimental

@item CIL
      @tab @refapiclass{cil}
      @tab experimental

@item LISP
      @tab @refapiclass{lisp}
      @tab experimental

@item Coq source
      @tab @refapiclass{coq}
      @tab experimental

@item Forth
      @tab @refapiclass{forth}
      @tab experimental

@end multitable
@end float

These classes may also inherit from @emph{mixin} classes which provide
additional functionality which may be re-used across multiple software
object classes.  Detailed descriptions of important software object
classes and mixins (which may be added to a software objects
inheritance tree to provide additional functionality) are described in
the following subsections.

@menu
Software Object Classes (see also @ref{api-software-object-classes,Software Object Classes} in the API)
* C/C++ with @code{clang}::     C language source code ASTs
* Assembler with @code{asm}::   Assembler represented as a vector
* Executables with @code{csurf-asm}:: Executables manipulated as an
                                      assembler vector
* Java with @code{java}::             Java language source code ASTs
* JavaScript with @code{javascript}:: JavaScript language source code ASTs
* Coq with @code{coq}::               Coq language source code ASTs

Software Object Mixins (see also @ref{api-software-object-mixins,Software Object Class ``Mixins''} in the API)
* Ancestor tracking with @code{ancestral}:: Collect history of applied
                                        mutations and crossover events.
* Lighter asm alternatives @code{light}/@code{range}/@code{diff}::
                                        Lighter weight alternatives to
                                        @code{simple} software.
@end menu

@node C/C++ with @code{clang}, Assembler with @code{asm}, Software Objects, Software Objects

@subsection C/C++ with @code{clang} Software Object

@include include/clang.texi

@node Assembler with @code{asm}, Executables with @code{csurf-asm}, C/C++ with @code{clang}, Software Objects

@subsection Assembler with @code{asm} Software Object

@include include/asm.texi

@node Executables with @code{csurf-asm}, Java with @code{java}, Assembler with @code{asm}, Software Objects

@subsection Executables with @code{csurf-asm} Software Object

@include include/csurf-asm.texi

@node Java with @code{java}, JavaScript with @code{javascript}, Executables with @code{csurf-asm}, Software Objects

@subsection Java with @code{java}

@include include/java.texi

@node JavaScript with @code{javascript}, Coq with @code{coq}, Java with @code{java}, Software Objects

@subsection JavaScript with @code{javascript}

@include include/javascript.texi

@node Coq with @code{coq}, Ancestor tracking with @code{ancestral}, JavaScript with @code{javascript}, Software Objects

@subsection Coq with @code{coq} and @code{SerAPI}

@include include/serapi-io.texi

@include include/coq.texi

@node Ancestor tracking with @code{ancestral}, Lighter asm alternatives @code{light}/@code{range}/@code{diff}, Coq with @code{coq}, Software Objects

@subsection Ancestor tracking with @code{ancestral} Software Mixin

@include include/ancestral.texi

@node Lighter asm alternatives @code{light}/@code{range}/@code{diff}, Software Methods, Ancestor tracking with @code{ancestral}, Software Objects

@subsection Lighter asm alternatives @code{light}/@code{range}/@code{diff}

@subsubsection Lighter genomes with @code{light} Software Mixin

@include include/light.texi

@subsubsection Range based genomes @code{range} Software Mixin

@include include/range.texi

@subsubsection Difference genomes with @code{diff} Software Mixin

@include include/diff.texi

@node Software Methods, Mutation Objects, Software Objects, Implementation

@section Software Methods
@cindex software methods


@subsection Software Genome and Phenome

A software object has both a @emph{genome} and a @emph{phenome}.
These are the two most important methods on software objects.  They
return the @emph{code} and @emph{executable} versions of the software
respectively.

@table @dfn

@item Genome
In biology, the genome is the genetic material (DNA/RNA) of the
cell. In the software evolution library, this field should contain the
instructions which define the behavior of a software object. In most
cases, the code (source or assembly), should be stored on this field.

@item Phenome
A phenome is an expression of all the traits described in the
genome. In the software evolution library, this is an executable
binary.

@c In addition to the executable, this method also returns (2) an
@c errno (a numeric indication of compilation success), (3) stderr of the
@c compilation process or a string holding error output relevant to
@c phenome generation, (4) stdout of the evolution process or a string
@c holding non-error output relevant to phenome generation, (5) the
@c source file name used during compilation.

@end table


@subsection Defining new software object types

New software objects should inherit from the most-relevant base
class. For source code based software objects, this is the
@refapiclass{parseable} class. To define a new software object type from an
existing base class, use the @refapimacro{define-software} macro.  All
software objects should ultimately inherit from the
@refapiclass{software} class.

@lisp
(define-software new-software-type (base-software-type)
  ())
@end lisp


@subsection Core methods on Software

The following lists the core methods which are defined for all
software object types exposing a common interface for use by user
programs or in heuristic search.

@itemize
@item Recover @ref{Software Objects,genome and phenome}.
    @itemize
    @item @refapigeneric{genome}
    @item @refapigeneric{phenome}
    @end itemize

@item Get genome properties.
    @itemize
    @item @refapigeneric{genome-string}
    @item @refapigeneric{lines}
    @item @refapigeneric{size}
    @end itemize

@item @refapigeneric{copy}

@item Pick an index into the genome.
    @itemize
    @item @refapigeneric{pick}
    @item @refapigeneric{pick-good}
    @item @refapigeneric{pick-bad}
    @item @refapigeneric{pick-bad-good}
    @item @refapigeneric{pick-bad-bad}
    @end itemize

@item Perform crossover on two software objects.
    @itemize
    @item @refapigeneric{crossover}
    @item @refapigeneric{one-point-crossover}
    @item @refapigeneric{two-point-crossover}
    @end itemize


@item Input/Output.
    @itemize
    @item @refapigeneric{from-file}
    @item @refapigeneric{from-string}
    @item @refapigeneric{to-file}
    @end itemize

@item @refapigeneric{mutate}
@item @refapigeneric{evaluate}
@item @refapigeneric{fitness-extra-data}
@end itemize



@c DOCFIXME: Finish moving these descriptions into documentation
@c strings in the code and replacing the in-place definitions
@c with @include directives to load the automatically generated
@c documentation.






@ignore
@anchor{pick}
@defun pick software key &optional func
Randomly select elements of the genome of @code{SOFTWARE}.  Selection
may optionally be biased towards particular portions of the genome
based on a @code{key} supplied to @code{pick}.  Related
@code{pick-good} and @code{pick-bad} methods may also be customized.
Useful for e.g., using annotations or fault localization information
to bias mutation operations.
@end defun

@anchor{mutate}
@defun mutate software
Randomly mutate the supplied software object.  The modified software
object and the applied mutation are returned.
@end defun

@anchor{crossover}
@defun crossover software-a software-b
Perform the specified form of crossover on two software objects
returning a new software object and information on the crossover
operation performed (e.g., the indices of crossover).  The related
@code{one-point-crossover} and @code{two-point-crossover} methods may
also be used to perform particular types of crossover.
@end defun

@anchor{from-file}
@defun from-file software file
Initialize a software object @code{SOFTWARE} using the contents of
@code{FILE}.
@end defun

@anchor{to-file}
@defun to-file software file
Write the genome of software object @code{SOFTWARE} to @code{FILE}.
@end defun

@end ignore


@node Mutation Objects, Global Variables, Software Methods, Implementation
@section Mutation Objects
@cindex Mutation

@c DOCFIXME need more intro

SEL provides a variety of operations that apply @emph{mutations} to
modify code. These mutations are represented as @refapiclass{mutation}
objects.



See section @ref{api-mutations,API | Mutations} for full API
documentation. We provide a brief outline here.

New @refapiclass{mutation} subclasses should derive from the
most-relevant base class. To define a new mutation from an existing
base class, use

@lisp
(define-mutation new-mutation (base-mutation)
  ())
@end lisp

The mutation may be initialized with two functions; a targeter and
picker. The targeter is a function which, given a software object,
returns a list of mutation targets; this function defaults to
@refapigeneric{pick-bad}. The picker is a function which, given a software
object, returns a random mutation target; this function defaults to a
random element returned by @refapigeneric{pick-bad}.

After creating a software object and a mutation, use the
@refapigeneric{apply-mutation} method to create a new mutant.




@node Global Variables, Search Functions, Mutation Objects, Implementation
@section Global Variables
@cindex Global Variables

The following global variables are exposed for configuration and
interaction with heuristic search processes. This table contains summary information only, see the @ref{SEL API} section for full details.

@multitable {} {}

@item @refapivariable{*population*} @tab
A list of the software objects currently known to the system.

@item @refapivariable{*max-population-size*} @tab
Maximum allowable population size.

@item @refapivariable{*generations*} @tab
The running generation count.

@item @refapivariable{*tournament-size*} @tab
Number of individuals to participate in tournament selection.

@item @refapivariable{*tournament-eviction-size*} @tab
Number of individuals to participate in eviction tournaments.

@item @refapivariable{*tournament-selector*} @tab
Function used to select winners of a tournament.

@item @refapivariable{*tournament-tie-breaker*} @tab
Function used to break ties when a tournament has multiple
winners.

@item @refapivariable{*tie-breaker-predicate*} @tab
Function to compare two tie breaker values to select which is
preferred.

@item @refapivariable{*fitness-predicate* } @tab
Function to compare two fitness values to select which is preferred.


@item @refapivariable{*cross-chance*} @tab
Fraction of new individuals generated using crossover rather than
mutation.

@item @refapivariable{*mut-rate*} @tab
Chance to mutate a new individual.

@item @refapivariable{*fitness-evals*} @tab
Tracks the total number of fitness evaluations
performed.

@item @refapivariable{*running*} @tab
True when a search process is running, set to nil to
stop a running search.

@end multitable


@node Search Functions, REST API, Global Variables, Implementation
@section Search Functions
@cindex search functions

Currently two high-level search functions are implemented:
@code{evolve} and @code{mcmc}.  The @code{evolve} search function has
received much more testing and is recommended.


@table @dfn

@item @refapimacro{evolve}
Evolve the existing @refapivariable{*population*} of
@refapiclass{software} objects using a supplied test function to
evaluate the fitness of software objects. A steady state evolutionary
computation algorithm is used to evolve increasingly fit software
objects in a process resembling natural selection.

@item @refapimacro{mcmc}
Perform Markov chain Monte Carlo search from a supplied
@refapiclass{software} object using a supplied test function
to evaluate the fitness of software objects.  The fitness returned by
the test function is optimized.

@end table


@ignore
@anchor{evolve}
@defun evolve test &key max-evals max-time target period period-fn every-fn filter
Evolve the existing @code{*population*} of software objects using the
supplied @code{TEST} function to evaluate the fitness of software
objects.  The fitness returned by the @code{TEST} function is
optimized.  A steady state evolutionary computation algorithm is used
to evolve increasingly fit software objects in a process resembling
natural selection.
@end defun

@anchor{mcmc}
@defun mcmc original test &key accept-fn max-evals max-time target period period-fn every-fn filter
Perform Markov chain Monte Carlo search from the supplied
@code{ORIGINAL} software object using the supplied @code{TEST}
function to evaluate the fitness of software objects.  The fitness
returned by the @code{test} function is optimized.
@end defun

Both functions take the following optional keyword arguments

@table @code
@item max-evals
stop after this many fitness evaluations

@item max-time
stop after this many seconds

@item target
stop when an individual passes @code{TARGET-FIT}

@item period
interval of fitness evaluations to run @code{PERIOD-FN}

@item period-fn
function to run every @code{PERIOD} fitness evaluations

@item every-fn
function to run before every fitness evaluation

@end table

In addition the @code{evolve} function takes an optional @code{filter}
keyword argument which when specified only includes individual for
which @code{FILTER} returns true, and the @code{mcmc} function takes
an optional @code{accept-fn} keyword argument which is a function of
current and new fitness that returns acceptance.
@end ignore


@node REST API, Components, Search Functions, Implementation
@section REST API
@cindex rest api

@include include/rest-api.texi

@node Components, Test Suites, Implementation, Top
@chapter Components
@cindex components

In addition to the software objects, method and evolutionary
infrastructure described in the previous section @ref{Implementation},
the Software Evolution Library includes many ``components.''  Each
component is a self-contained unit used to evaluate or manipulate
software objects.  Some components are implemented as classes which
may be @i{mixed in} with software objects which others are functions
on software objects, or extensions to the basic evolutionary
infrastructure.

@menu
* Test Suites::                 Running unit tests
* Multi-objective Fitness::     Optimizing multiple objectives
* Style Features::              Extracting source code features
* Clang C Tokenizer::           Tokenize software objects
* Condition Synthesis::         Synthesize guard conditions to repair software
* Fault Localization::          Identify or prioritize likely-faulty code
* Tracing::                     Trace execution of software
* Super-Mutants::               Evaluate multiple variants in a single genome
* AST Differencing::            Calculate AST tree-differences of software
@end menu

@node Test Suites, Multi-objective Fitness, Components, Components
@section Test Suites
@cindex test-suite
@include test-suite.texi

@node Multi-objective Fitness, Style Features, Test Suites, Components
@section Multi-objective Fitness
@cindex multi-objective fitness
@include multi-objective-fitness.texi

@node Style Features, Clang C Tokenizer, Multi-objective Fitness, Components
@section Style Features
@cindex style-features
@include style-features.texi

@node Clang C Tokenizer, Condition Synthesis, Style Features, Components
@section Clang C Tokenizer
@cindex tokenizer
@include tokenizer.texi

@node Condition Synthesis, Fault Localization, Clang C Tokenizer, Components
@section Condition Synthesis
@cindex condition-synthesis
@include condition-synthesis.texi

@node Fault Localization, Tracing, Condition Synthesis, Components
@section Fault Localization
@cindex fault-localization
@include fault-localization.texi

@node Tracing, Super-Mutants, Fault Localization, Components
@section Tracing
@cindex tracing
@include tracing.texi

@node Super-Mutants, Clang Super-Mutants, Tracing, Components
@section Super-Mutants
@cindex super-mutants
@include include/super-mutant.texi

@node AST Differencing, Utilities, Super-Mutants, Components
@section AST Differencing
@cindex ast-differencing
@include include/ast-diff.texi

@node Utilities, Basic Utilities, Components, Top
@chapter Utilities
@cindex utilities

The Software Evolution Library provides utilities packages, including
the @code{SEL/UTILITY} package (see @ref{SEL Utility API}) and the
@code{SEL/VIEW} package (see @ref{SEL View API}).  This chapter
documents these utilities.

@menu
* Basic Utilities::             Basic Utilities covering a range of uses
* View::                        A simple GUI for SEL applications
* Task::                        Infrastructure to use multiple threads
@end menu

@node Basic Utilities, View, Utilities, Utilities
@section Basic Utilities
@include include/utility.texi

@subsection Files and Directories, Temporary and Git
@include include/file-directory.texi

@subsection Process wrapping
@include include/process.texi

@subsection Shell and system command helpers
@include include/shell.texi

@subsection Generic utility functions
@include include/generic-utility.texi

@subsection Source and binary locations and ranges.
@include include/locations-and-ranges.texi

@subsection Debugging helpers
@include include/debugging.texi

@subsection Oprofile functions
@include include/oprofile.texi

@subsection Profiling
@include include/profiling.texi

@node View, Task, Basic Utilities, Utilities
@section View
@include include/view.texi

@node Task, Usage, View, Utilities
@section Task
@include include/task.texi

@node Usage, Installation, Utilities, Top
@chapter Usage
@cindex usage


@menu
* Installation:: Installing SEL and its dependencies
* Examples:: A series of examples demonstrating some SEL applications.

@end menu



@node Installation, Examples, Usage, Usage
@section Installation

The Software Evolution Library (SEL) requires one of the following
supported lisp distributions.  (Relatively recent versions of these
implementations are required because of the use of new features of
ASDF/UIOP.)

@multitable {} {} {}

@headitem  Implementation @tab Minimum Version @tab URL

@item Steel Bank Common Lisp (SBCL) @tab 1.4 @tab @url{https://www.cliki.net/SBCL}

@item Clozure Common Lisp (CCL) @tab 1.12-dev @tab @url{https://www.cliki.net/CCL}

@end multitable

The source code for SEL is available at
@url{https://github.com/GrammaTech/sel}.  The following Common Lisp
packages are required by this library, all of which are installable
through Quicklisp (see @url{http://www.quicklisp.org/}).
@itemize
@item alexandria
@item metabang-bind
@item curry-compose-reader-macros
@item split-sequence
@item cl-ppcre
@end itemize

The following additional Common Lisp packages are required by this
library but are not (yet) installable through Quicklisp.  These should
be downloaded into your Quicklisp @code{local-projects/} folder.

@itemize
@item trace-db (available from @url{https://github.com/GrammaTech/trace-db})
@item command-line-arguments (available from @url{https://github.com/eschulte/command-line-arguments})
@end itemize

Depending on the type of software object used the following may also
be required.
@itemize
@item
clang-mutate for @code{clang} object support  (available from
@url{https://github.com/GrammaTech/clang-mutate}).
@item
cil-mutate for @code{cil} object support (available from
@url{https://github.com/eschulte/cil-mutate}).
@item
llvm-mutate for @code{llvm} object support (available from
@url{https://github.com/eschulte/llvm-mutate}).
@end itemize



Install llvm-mutate, cil-mutate and clang-mutate as per the
instructions in their respective repositories. (Note, it is only
necessary to install the tools for the specific software backends you
intend to use.) Install SEL by cloning the repository into your
quicklisp local-projects directory and then running:
@example
    (ql:register-local-projects)
    (ql:quickload :software-evolution-library)
    (ql:quickload :software-evolution-library/utility)
@end example




@node Examples, Mutation, Installation, Usage
@section Examples

The examples in this section illustrate various applications of the
software evolution library.

We start with a C program for computing the greatest common
demominator (gcd) of two numbers. The source file is available in
@code{test/etc/gcd/gcd.c}, and reproduced below.


@verbatiminclude ../test/etc/gcd/gcd.c

(You may notice at this point that the C code is buggy and does not
compute correct gcd for all inputs. The @ref{Repair} example will
demonstrate how SEL can be used to create a repaired version of the
program.)


The examples operate on the ASM file compiled from @code{gcd.c}. If
you would like to try out the examples yourself, compile @code{gcd.c}
to ASM. For example:

@example
gcc gcd.c -S -o gcd.s
@end example




@menu
* Mutation::                    Mutate a program
* Evaluation::                  Evaluate the fitness of a mutant
* Neutral Variants::            Generate neutral variants of a program
* Repair::                      Repair a program
@c * Memoize Fitness::             A global memoized genome-fitness map
@c * Annotations::                 Annotating portions of the genome
@c * Focused Mutation::            Using annotations to focus mutation operations
@c * Execution Statistics::        Saving statistics
@end menu
@node Mutation, Evaluation, Examples, Examples
@subsection Mutation
@cindex example mutation


The @refapigeneric{mutate} method applies a random mutation to a
@refapiclass{software} object and returns two values: the mutated
object and a @refapiclass{mutation} object describing the mutation
that was applied.

The following example applies a random mutation to @code{gcd.s}.


@enumerate

@item Uses @refapigeneric{from-file} to load @code{gcd.s} into a new @refapiclass{asm} software object, @code{orig}.

@item Applies @refapigeneric{mutate} to mutate a deep @refapigeneric{copy} of @code{orig}.

@item Writes the mutated object to disk with @refapigeneric{to-file}.

@item Prints the @refapiclass{mutation} that was applied.
@end enumerate

@verbatiminclude ./examples/001-mutate.lisp


Executing this code will print output resembling the following.

@example
Results of applying #<SIMPLE-CUT #<ASM #x3020022A24DD> 78> to gcd written to "/\
tmp/fileLfs6Mf.s".
@end example


@subsubheading API components in this example


@itemize
@item Class @refapiclass{asm}
@item Methods
  @itemize
  @item @refapigeneric{copy}
  @item @refapigeneric{from-file}
  @item @refapigeneric{mutate}
  @item @refapigeneric{to-file}
  @end itemize
@end itemize


@node Evaluation, Neutral Variants, Mutation, Examples
@subsection Evaluation
@cindex example evaluation

Once we are mutating programs, we need to be able to evaluate each
variant and keep track of the evaluation results.

We have provided a shell script @code{test.sh}, which contains several
gcd test cases. Our fitness function will be the number of test cases
for which a program produces the correct solution.

Once a fitness value for a @refapiclass{software} object is
established, it can be recorded in the object's @code{fitness} field.


The example code below has two main components:

@itemize
@item A @code{test} function that harnesses the @code{test.sh} script to evaluate the fitness of an individual @refapiclass{asm} object.

@item A loop in which ten mutants of the   @refapiclass{asm} object corresponding to the original @code{gcd.s} program are generated, their fitness assessed, and the results printed.
@end itemize

@ignore
The example code below does the following.
@enumerate
@item
Defines a @code{test} function used to evaluate the fitness of a
software object.  This function makes use of an external shell script
test driver which is run using the @code{shell} function defined in
the @ref{SEL Utility API}.

@item
The original program is initialized from a file on disk.

@item
Ten mutants of the original are generated by applying random edits.

@item
The @code{fitness} field of each mutant is set using the previously
defined @code{test} method.

@item
The edits and fitness of each mutant are printed.

@end enumerate

@end ignore


@verbatiminclude ./examples/002-evaluation.lisp

Executing this code will print output resembling the following.

@c TODO: Figure out if/why this doesn't seem to work currently.

@example
 0 fitness for edit (:INSERT 76 38)
 0 fitness for edit (:SWAP 66 77)
 0 fitness for edit (:CUT 50)
10 fitness for edit (:CUT 11)
10 fitness for edit (:SWAP 62 39)
 0 fitness for edit (:INSERT 2 48)
10 fitness for edit (:CUT 66)
 0 fitness for edit (:CUT 73)
10 fitness for edit (:INSERT 73 26)
 0 fitness for edit (:INSERT 71 1)
@end example



@subsubheading API components in this example

@itemize
@item Class @refapiclass{asm}
@item Methods
  @itemize
  @item @refapigeneric{copy}
  @item @refapigeneric{from-file}
  @item @refapigeneric{mutate}
  @item @refapigeneric{phenome}
  @end itemize
@c @item [sel/utility] Macro @ref{Macro sel/utility:with-temp-file, @code{with-temp-file}}
@c @item [sel/utility] Function @ref{Function sel/utility:shell, @code{shell}}
@item [sel/utility] Macro @ref{Macro with-temp-file, @code{with-temp-file}}
@item [sel/utility] Function @ref{Function shell, @code{shell}}
@end itemize




@node Neutral Variants, Repair, Evaluation, Examples
@subsection Neutral Variants
@cindex neutral variants


In some cases we are interested in ``neutral mutants'': variants of
the original program that still satisfy the test suite. (For more information,
see @cite{Software Mutational Robustness} available at @url{http://arxiv.org/abs/1204.4224}).


The following example constructs a collection of neutral mutants of
@code{gcd.s}, using the @code{test} function defined in the
@ref{Evaluation} example to determine whether or not candidate
variants have equivalent behavior to the original.

@verbatiminclude ./examples/003-neutral.lisp


@subsubheading API components in this example


@itemize
@item Class @refapiclass{asm}
@item Methods
  @itemize
  @item @refapigeneric{copy}
  @item @refapigeneric{from-file}
  @item @refapigeneric{mutate}
  @end itemize
@end itemize




@node Repair, Troubleshooting, Neutral Variants, Examples
@subsection Repair
@cindex repair

The sample gcd program is failing one of the test cases in
@code{test.sh}, so we know it contains at least one bug.  We can use
evolutionary search to look for a ``repair'' for this buggy
implementation: a mutant that passes every test case in the script.

As before, we use the @code{test} function defined in the
@ref{Evaluation} example to measure the fitness of each program
variant. This time, @code{test} is used as the fitness test in
applying @refapimacro{evolve} to a @refapivariable{*population*}
initialized with 100 copies of the original program. Variable
@refapivariable{*target-fitness-p*} is set up so that the search will
terminate when a member of the population has a fitness value that
indicates it is passing all of the tests; @refapimacro{evolve}'s
keyword argument @code{:max-evals} ensures that execution will always
terminate after at most 100 fitness evaluations.

@ignore
The following properties of this example should be noted.

@enumerate
@item
Before calling @code{evolve} the population is populated with copies
of the original program.

@item
The @code{*orig*} individual is assigned a fitness before the
@code{*population*} is populated.  This is necessary as the search
functions assume that every element of @code{*population*} already
have a fitness assigned.

@item
The @code{*population*} is not explicitly passed to the @code{evolve}
function which implicitly modifies the @code{*population*} variable.
When this function terminates the evolved program variants will be
saved in the @code{*population*}.
@end enumerate
@end ignore


@verbatiminclude ./examples/004-evolve.lisp

@subsubheading API components in this example




@itemize
@item Class @refapiclass{asm}
@item Macro @refapimacro{evolve}
@item Methods
  @itemize
  @item @refapigeneric{copy}
  @item @refapigeneric{from-file}
  @end itemize
@item Variables
  @itemize
  @item @refapivariable{*population*}
  @item @refapivariable{*target-fitness-p*}
  @item @refapivariable{*fitness-predicate*}
  @end itemize
@end itemize


@subsection Parallel Repair
@cindex parallel repair

Evolution may be parallelized by calling @refapimacro{evolve} in multiple
threads.

For example a parallel version of the previous example would
replace,

@lisp
(let ((*target-fitness-p* [@{= 11@} #'fitness]))
  (evolve #'test :max-evals 100))
  @end lisp

with the following.

@lisp
(require 'bordeaux-threads)
(defvar *num-threads* 64 "Number of available cores.")

;; launch *num-threads* evolution threads
(let ((*target-fitness-p* [@{= 11@} #'fitness]))
  (let (threads)
      (loop :for n :below *num-threads* :do
             (push (bordeaux-threads:make-thread
                           (lambda () (evolve #'test :max-evals 100))
                                         :name (format nil "opt-~d" n))
                                                      threads))))

;; wait for all threads to return
(mapc #'bordeaux-threads:join-thread threads)
@end lisp


@c @node Annotations, Focused Mutation, Parallel Fitness Evaluation, Usage Examples
@c @section Annotations
@c @cindex annotations

@c @node Focused Mutation, Execution Statistics, Annotations, Usage Examples
@c @section Focused Mutation
@c @cindex focused mutation

@c @node Execution Statistics, Memoize Fitness, Focused Mutation, Usage Examples
@c @section Execution Statistics
@c @cindex execution statistics

@c @node Memoize Fitness, Neutral Variants, Execution Statistics, Usage Examples
@c @section Memoize Fitness
@c @cindex memoize fitness



@node Troubleshooting, SEL API, Usage, Top
@chapter Troubleshooting
@cindex troubleshooting

@include troubleshooting.texi


@node SEL API, SEL Utility API, Troubleshooting, Top
@appendix SEL API
@include include/sb-texinfo.texinfo

SEL is a Lisp @emph{package}, in essence, a container for symbols
allowing the creation of separate namespaces within a program. See
@url{http://www.gigamonkeys.com/book/programming-in-the-large-packages-and-symbols.html}
for more information on the definition and use of packages in Common
Lisp.

@menu
* SEL API Concept Index :: Structured description of the SEL API contents.
* SEL API Details :: Documentation for each SEL API artifact.
@end menu


@node SEL API Concept Index, SEL API Details, SEL API, SEL API
@unnumberedsec SEL API Concept Index
@include sel-api-index.texi

@node SEL API Details, SEL Utility API, SEL API Concept Index, SEL API
@unnumberedsec SEL API Details
@include sel-api.texi


@node SEL Utility API, SEL View API, SEL API, Top
@appendix SEL Utility API
@cindex utility

@itemize
@item @ref{utility-api-contents,SEL Utility API Contents}
@item @ref{utility-api-details,SEL Utility API Details}
@end itemize

@anchor{utility-api-contents}
@section SEL Utility API Contents
@include sel-utility-api-index.texi

@anchor{utility-api-details}
@section SEL Utility API Details
@include sel-utility-api.texi




@node SEL View API, General Lisp Advice, SEL Utility API, Top
@chapter SEL View API

@cindex view



@itemize
@item @ref{view-api-contents,SEL View API Contents}
@item @ref{view-api-details,SEL View API Details}
@end itemize

@anchor{view-api-contents}
@section SEL View API Contents
@include sel-view-api-index.texi

@anchor{view-api-details}
@section SEL View API Details
@include sel-view-api.texi



@node General Lisp Advice, Getting Started with Lisp, SEL View API, Top
@appendix General Lisp Advice

@menu
* Getting Started with Lisp::
* Additional Lisp Resources::
* General Lisp Debugging Advice::
@end menu


@node Getting Started with Lisp, Additional Lisp Resources, General Lisp Advice, General Lisp Advice
@appendixsec Getting Started with Lisp

We recommend the following Common Lisp resources.

@itemize

@item
The @url{http://cliki.net/Getting+Started,Getting Started} guide provided on @url{http://cliki.net/,CLiki}, the Common Lisp wiki.

This is a fairly complete guide to starting out with Lisp in general
and Common Lisp in particular.

@item
The web site @url{http://articulate-lisp.com/,Articulate Common Lisp},
includes a comprehensive startup guide and introduction to the lisp
language.

This includes sections on choosing an
@url{http://articulate-lisp.com/implementations/summary.html,
implementation}, using @url{http://articulate-lisp.com/quicklisp.html,
Quicklisp}, and defining new libraries with
@url{http://articulate-lisp.com/project/new-project.html, ASDF}.

@item @url{http://www.gigamonkeys.com/book/,Practical Common Lisp}.

Especially, @url{
http://www.gigamonkeys.com/book/lather-rinse-repeat-a-tour-of-the-repl.html,
Chapter 2} describes how to get Emacs and Slime working.

@end itemize


We strongly recommend that you use Emacs: no other editor has such
strong integration into the Lisp process (useful for finding function
definitions, automatically displaying information, compiling,
highlighting compiler warnings, evaluating, etc...).
Install Emacs @url{http://emacswiki.org/emacs/ParEdit,ParEdit} for
additional Lisp authoring support.

If you prefer to use VIM, we recommend installing
@url{https://github.com/vim-scripts/paredit.vim,paredit.vim}.




@node Additional Lisp Resources, General Lisp Debugging Advice, Getting Started with Lisp, General Lisp Advice

@appendixsec Additional Lisp Resources

@itemize

@item
The @code{#lisp} IRC room on the @url{https://freenode.net/,freenode}
IRC server.


@item
@url{http://www.cliki.net/slime-howto,Introduction to Slime}

@item
@url{https://www.emacswiki.org/emacs/ParEdit,Introduction to ParEdit}

@item
@url{https://melpa.org/#/getting-started,Introduction to Melpa}

@item
@url{http://malisper.me/2015/07/07/debugging-lisp-part-1-recompilation/,Debugging Lisp}

@item
@url{http://www.gigamonkeys.com/book/,Practical Common Lisp Book}

@item
@url{https://www.csee.umbc.edu/courses/331/resources/lisp/onLisp/,On Lisp}

@item
@url{https://github.com/eschulte/curry-compose-reader-macros,
     Curry compose reader macros@comma{} aka@comma{} those weird @code{[@{@}]} and @code{@guillemotleft{}@guillemotright{}} symbols}

@item
We prefer @code{iter} over @code{loop}. See
@url{https://sites.google.com/site/sabraonthehill/loop-v-iter#TOC-Collect,
     @code{loop} vs. @code{iter}} for a comparison.

@item
@url{https://common-lisp.net/project/iterate/doc/index.html,
     @code{iter} in detail}

@item
@url{https://common-lisp.net/project/metabang-bind/user-guide.html,
     Using @code{bind}}

@end itemize


@node General Lisp Debugging Advice, SEL Coding Standards, Additional Lisp Resources, General Lisp Advice
@appendixsec General Lisp Debugging Advice


@subsection Log all interaction with the system shell

For problems related to the execution of external commands turn on
logging of all execution of shell commands by SEL.  This may be done
by setting the `*shell-debug*` variable to a non-nil value.

@lisp
(setq *shell-debug* t)
@end lisp

All subsequent executions of @code{shell} will now print logging
information.


@subsection Tracing specific functions

Common Lisp provides support for function-level tracing.  This may be
enabled and disabled using the @code{cl-user::trace} and
@code{cl-user::untrace} functions respectively, as shown in the
following.

@lisp
    CL-USER> (in-package :software-evolution-library/test)
    #<PACKAGE "SOFTWARE-EVOLUTION-LIBRARY/TEST">
    SE-TEST> (hello-world-clang)
    T
    SE-TEST> (cl-user::trace snippet->clang-type)
    (SNIPPET->CLANG-TYPE)
    SE-TEST> (update-asts *hello-world*)
      0: (SNIPPET->CLANG-TYPE
          ((:ARRAY . "") (:COL . 0) (:DECL . "") (:FILE . "")
           (:HASH . 342363981814211589) (:LINE . 0) (:POINTER . T) (:REQS)
           (:SIZE . 4) (:TYPE . "char")))
      0: SNIPPET->CLANG-TYPE returned
           #S(CLANG-TYPE
              :ARRAY ""
              :COL 0
    ;;;...
    #<CLANG @{1003AD88D3@}>
    SE-TEST>
@end lisp


@subsection Use extra verbosity in command-line tools

Many command-line tools compiled from @code{sel} support various levels of
verbosity in their output.  The simplest first step in debugging these
tools should be to maximize the level of verbosity, e.g. @code{-v 5}.


@node SEL Coding Standards, Use the compiler(s), General Lisp Advice, Top
@appendix SEL Coding Standards

@menu
* Use the compiler(s)::
* Formatting::
* Comments::
* Git Commits::
* Testing::
* Use existing utility functions::
* Packages::
* Portability::
* Documentation::
* Don't use superfluous @code{let} or @code{let*} bindings::
* Map instead of iterate::
* Judicious use of arrow macros::
@end menu

@node Use the compiler(s), Formatting, SEL Coding Standards, SEL Coding Standards
@appendixsec Use the compiler(s)


All code should compile without warning in both SBCL and CCL.  Files
may easily be compiled from within Emacs by running @code{M-x
slime-compile-file} (which is typically bound to @code{C-c M-k}).  These
warnings are often useful and catch type errors and outright mistakes
that can easily slip through testing.  This will also ensure
@ref{Portability,portability}.


@node Formatting, Comments, Use the compiler(s), SEL Coding Standards
@appendixsec Formatting

All code should conform to the following standards:
@itemize
@item no tabs
@item no closing parenthesis on lines by themselves
@item indent everything as would GNU Emacs
@item typically only include vertical whitespace between top-level
   forms, sections of large functions may be demarcated by vertical
   whitespace but it is better to use smaller functions
@item no trailing whitespace
@item no whitespace following an open-paren
@item lines should be limited to a maximum of 79 characters
@end itemize

Google's @url{http://google.github.io/styleguide/lispguide.xml,Common
Lisp guide} is generally applicable.  Specifically the sections on
@url{http://google.github.io/styleguide/lispguide.xml#Formatting,Formatting}
and
@url{http://google.github.io/styleguide/lispguide.xml#Comment_semicolons,Comment
semicolons}.

The
@url{https://github.com/eschulte/lisp-format/blob/master/lisp-format,lisp-format}
utility may be used to automatically check and fix code formatting.
See the comments at the top of the lisp-format script for more
information.  The git-lisp-format script (adopted from
@url{https://llvm.org/svn/llvm-project/cfe/trunk/tools/clang-format/git-clang-format,git-clang-format})
integrates lisp-format with git, enabling the easy application of
lisp-format to all lines that differ between the working directory and
a given commit, which defaults to HEAD.  To automatically run
``@code{git lisp-format}'' before every commit and abort the commit
when re-formatting is needed, save the following shell script to
@code{.git/hooks/pre-commit} in the base of this repository and mark
it as executable.

@verbatim
#!/bin/bash
OUTPUT=$(git lisp-format --diff)
if [ "${OUTPUT}" == "no modified files to format" ] ||
   [ "${OUTPUT}" == "lisp-format did not modify any files" ];then
    exit 0
else
    echo "Run git lisp-format, then commit."
    exit 1
fi
@end verbatim


@node Comments, Git Commits, Formatting, SEL Coding Standards
@appendixsec Comments (number of semicolons matters)

@itemize
@item All comments should be complete sentences with capitalization and a period.
@item 3 (or 4) semicolons at the beginning of a line for block comments outside of any top level form
@item 2 semicolons for comments that appear between lines of code
@item 1 semicolon for comments that appear after code at the end of a line
@item vertical align end-of-line comments when possible
@item always use a space after the last semicolon and before comment text
@item In Emacs @code{M-;} inserts a comment of the appropriate type.
@end itemize

@node Git Commits, Testing, Comments, SEL Coding Standards
@appendixsec Git Commits

Follow
@url{https://chris.beams.io/posts/git-commit/#seven-rules,the seven rules of git commit messages}.

@enumerate
@item Separate subject from body with a blank line.
@item Limit the subject line to 50 characters.
@item Capitalize the subject line.
@item Do not end the subject line with a period.
@item Use the imperative mood in the subject line.
@item Wrap the body at 72 characters.
@item Use the body to explain what and why vs. how.
@end enumerate


@node Testing, Use existing utility functions, Git Commits, SEL Coding Standards
@appendixsec Testing

Every merge request should first pass all tests which are defined in
the @code{SOFTWARE-EVOLUTION-LIBRARY/TEST} package using the
@url{https://common-lisp.net/project/stefil/index-old.shtml,Stefil}
testing framework.

Additional unit tests should be defined for any added functionality.
Unit tests should execute @i{quickly}, long running tests should not
be included in the default unit test suite.

@node Use existing utility functions, Packages, Testing, SEL Coding Standards
@appendixsec Use existing utility functions (don't write your own)

Look carefully for existing utility functions before
re-implementation.  Check the following places before implementation
of any utility:

@enumerate
@item
Run @code{(apropos "thing")} in the repl.

@item
Search the
@url{http://www.lispworks.com/documentation/HyperSpec/Front/,hyperspec}
(with Emacs slime properly configured you can tab-complete to plumb
the existing definitions in the hyperspec).  The hyperspec is a
reference, good for lookup and bad for browsing.

@item
Check the @url{https://common-lisp.net/project/alexandria/,Alexandria}
package for general utilities and the
@url{https://github.com/fare/asdf/tree/master/uiop,UIOP} package for
filesystem and OS utilities.

@item
Check the ``Utilities'' package of SEL (see @ref{SEL Utility API}).

@end enumerate


@node Packages, Portability, Use existing utility functions, SEL Coding Standards
@appendixsec Packages

Only use packages which are explicitly included in your current
package.  E.g., calling @code{cl-ppcre:foo} just because @code{cl-ppcre} happens
to be loaded in the lisp image every time you've run tests is @emph{not}
acceptable.  Instead the @code{:use} option to @code{defpackage} should
explicitly include the required package and if necessary @code{:shadow} and
@code{:shadowing-import-from} should be used to limit the symbols imported.


@node Portability, Documentation, Packages, SEL Coding Standards
@appendixsec Portability

All code should be portable across at least
@url{http://www.sbcl.org/,SBCL} and
@url{https://ccl.clozure.com/,CCL}.  Any code which is specific to a
particular implementation must be protected by @code{#+impl} guards.


@node Documentation, Don't use superfluous @code{let} or @code{let*} bindings, Portability, SEL Coding Standards
@appendixsec Documentation

@subsection For functions and methods

Write documentation strings for @emph{every} function @emph{always}.
Also, ensure every @code{defmethod} has a @code{defgeneric} which has
a documentation string.  The following formatting should be used for
docstrings.

@verbatim
Brief description (maximum 79 characters).

Longer description if necessary. This may span multiple lines, but
should adhere to the standard 79-character limit.

Paragraph breaks are also OK in the longer description.
* PARAM-A description of param
* PARAM-B description of param
@end verbatim

@subsection For files and modules

Large new functional modules (e.g., a new file of code) should be
documented in the manual.  The SEL manual is located in the @code{doc/}
subdirectory and is written in texinfo.  Follow the example set by
existing documentation to add new sections to this manual.



@node Don't use superfluous @code{let} or @code{let*} bindings, Map instead of iterate, Documentation, SEL Coding Standards
@appendixsec Don't use superfluous @code{let} or @code{let*} bindings


Any @code{let*} which can be changed to a @code{let} should be changed
to a @code{let}.

Typically, if a let-bound variable is only used once it should not be
bound but instead its definition should replace its sole use.  This
is suggested because each variable binding forces every subsequent
reader to perform a dereference.  For example, this

@lisp
(let* ((subject (quick brown fox))
       (object (lazy dog))
       (sentence (The subject jumps over the object.)))
  sentence)
@end lisp

is harder to read than this.

@lisp
(The quick brown fox jumps over the lazy dog)
@end lisp

There are some exceptions to this rule.

@itemize

@item
If the variable is often used in debugging (printf or debugger) and it
thus matters that it is bound at that point in the code then this may
be acceptable.

@item
If the let-bound value appears as, lets say, the third argument to
some function the in-lining of the long calculation may obscure the
flow of the function with it's other arguments.

@item
If use of the let avoids horrible indentation issues then it may be
acceptable.

@end itemize

@node Map instead of iterate, Judicious use of arrow macros, Don't use superfluous @code{let} or @code{let*} bindings, SEL Coding Standards
@appendixsec Map instead of iterate


Generally @code{mapc}, @code{mapcar}, @code{mappend}, and
@code{reduce} should be preferred to use of the @code{iterate} macro
(which should itself be preferred to @code{loop} which should never be
used).  In general @code{iterate} should be limited to cases where
non-trivial accumulation variables or incremental state are needed.
Potentially there are cases where a straightforward @code{iterate} has
better indentation behavior, in which case it might be acceptable (but
I can't think of one now).


@node Judicious use of arrow macros, ChangeLog, Map instead of iterate, SEL Coding Standards
@appendixsec Judicious use of ``arrow'' (@code{->}, @code{->>}, etc...) macros

We sometimes over-use the @code{->} and @code{->>} macros.  These
@emph{typically} only make sense to chain multiple calls, not single
(or often double) nested call.  One exception here is to aid
indentation (avoid going over 80 characters) when regular nesting
would require contortionist indentation.  For example in the following
excerpt from our tests.  This


@lisp
    (is (equalp (->> (stmt-starting-with-text *collatz* "int collatz")
                     (function-body *collatz*))
                #|...|#))
@end lisp

is nicer than this.

@lisp
    (is (equalp (function-body
                 *collatz*
                 (stmt-starting-with-text *collatz* "int collatz"))
                #|...|#))
@end lisp


@node ChangeLog, Licensing, SEL Coding Standards, Top
@appendix ChangeLog
@include changelog.texi

@node Licensing, Copying, ChangeLog, Top
@appendix Licensing
@menu
* Copying::                     The GNU General Public License gives
                                you permission to redistribute GNU Emacs on
                                certain terms; it also explains that there is
                                no warranty.
* GNU Free Documentation License::  The license for this documentation.
@end menu


@node Copying, GNU Free Documentation License, Licensing, Licensing
@appendixsec Copying: GNU GENERAL PUBLIC LICENSE
@include gpl.texi


@node GNU Free Documentation License, Index, Copying, Licensing
@appendixsec GNU Free Documentation License
@include doclicense.texi

@node Index,  , Licensing, Top
@unnumbered Index

@c Combine all index (function variable type and concept) types into a
@c single index.
@syncodeindex fn cp
@syncodeindex vr cp
@syncodeindex tp cp
@printindex cp

@bye
