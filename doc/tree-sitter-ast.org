#+TITLE: SEL tree-sitter-ast

tree-sitter-ast--more of a CST--representation in SEL.


* What is tree-sitter?
"Tree-sitter is a parser generator tool and an incremental parsing library.
It can build a concrete syntax tree for a source file and efficiently update
the syntax tree as the source file is edited."
-- https://tree-sitter.github.io/tree-sitter/

- Don't currently use the incremental abilities. Because we get rid of the C
  structure
- Primary use case is for syntax highlighting. Our use case of software
  synthesis varies widely from it, but it provides convenient information
  as a base.

** Benefits
- Adoption by several projects, such as Neovim.
- Many available languages
- Fairly uniform representation of languages
  - Previously, each language had a different way of getting an AST. These
    different ways often varied widely in how useful they were. As an
    example, Python 3's AST representation isn't the most ideal for our use
    case.
- Many people/organizations contribute to it

**  What does it provide?
- A shared object that provides functionality to take a string and
  generate a CST. This CST is fairly error-resilient.
- JSON files which specify the structure of the CST
  - node-types.json
  - grammar.json (commonly referred to as "the JSON" in discussions)

** Pain Points
- It has trouble parsing some languages, such as C++
- Frequently things need patched to store enough information to reproduce
  source text

* SEL Additions
- Cross-language Mixins ::
    Similar ideas, such as functions, loops, class definitions, etc., can be
    labeled as such.

  - This allows for generic function implementations which can be used across
    languages. As an example is the c/cpp mixin which allows C and C++ to
    easily share code. ECMAScript is another example allowing multiple
    JavaScript languages to share their implementation.

  - Mixins are much simpler in lisp and multiple inheritance is much simpler
    to leverage with CLOS.

- Source Text Reproduction ::
    The source text can be reproduced from the AST.

- Modification of Grammar and Node Types ::
    The grammar can be patched and node definitions can be modified before
    the generation of lisp code. To support this, there's functionality to
    transform parse trees after they are read into lisp such that they match
    the new grammar and definitions.
    - There's an issue with newlines having a source text range that is larger
      than one character. This causes issues with languages which expect
      newlines in a rule/production. This is commonly a problem with the C
      preprocessor.

- Validation of AST Structure ::
    If an AST cannot be matched against the grammar, an error will be thrown.
    This makes the evolutionary loop more efficient as we can discard
    grammatically invalid variants earlier. This is particularly useful for
    language agnostic mutations, such as cutting an AST or swapping ASTs.

- Indentation Maintenance ::
    Indentation is stored as the number of spaces. A variable can be set to
    allow for tabs and how many spaces a tab uses. This allows for the two
    most common identation styles--spaces and tabs + spaces. On top of this,
    insertion of new ASTs will maintain the correct amount of indentation.
    This functionality was developed to better support evolution of Python
    software.

* Structured Text
** Previous Representation [Interleaved Text]
- ASTs are interleaved with strings in a list
- Eventually evolved into "named childlren"
  - This assigned children their own slot/field/member variable
- This became very cumbersome to use and maintain the strings. As an
  example, removing or adding the 'else' clause of an 'if' statement
  required checking the interleaved text and patching it if necessary.

** Structured Text
- Current representation
- Assigns every child a relevant slot to be stored in

*** Implicit Text
A large portion of text can be inferred based on the class of an AST. This
is determined by its relevant rule/production in the grammar file. As an
example, if you have a parenthesized expression AST then the parenthesis
aren't stored any where in an instance of that object. Instead, this
information is put into an output-transformation method which transforms an
AST into its relevant string representation, i.e., source text.

*** Before/After slots
The before and after text slots store whitespace, comments, and any other
information that is, more or less, ignored by the grammar.
- This is information is pushed down from the parent into the closest child
  AST
- If the relevant information is surround by child ASTs, the relevant
  before slot is preferred over the after
  - This is by convention as opposed to any technical reason

*** Internal AST slots
There are places where whitespace and comments occur which do not have any
surrounding children. Instead of pushing it to children, it is instead
stored in internal AST slots. Adding these slots to nodes is part of the
code generation process.

*** Computed Text (Variable Part)
Variable text, such as function names and variable names, need to be
computed and stored at AST creation. These can, however, have children of
their own, so they can't always be stored as only text.
- Text Fragments are used to separate the children ASTs from the variable
  part. This maintains a list of ASTs instead of regressing back to the
  interleaved text representation.

*** Source Text Fragments
In some cases the the grammar can't be matched exactly. This may occur when
a file is actively being edited. The resulting AST can no longer be matched
when validating the parent AST's rule. The parent is instead turned into
a source text fragment AST which still allows for source text reproduction.
- tree-sitter either adds a zero-width token to force a matching
  rule/production or removes tokens from consideration until something does
  match.
- Note that tree-sitter frequently gets the parent AST's type incorrect
  when an error occurs, so source-text fragments protects against incorrect
  information.

*** Choice Expansion Subclasses
Each choice/alternation in the rule/production for node or AST is expanded
to create a new subclass for each branch that could be taken. This is done
for every choice branch which is not in a repeat/repetition.
- We can only match/validate on information that is stored in the AST/node
  object. By creating these different subclasses, information is
  stored implicitly based on the subclass. This allows semantically
  identical ASTs to have different implicit source text.
- Of note, when a subclass can no longer match on the values stored in its
  slots, it will go through every possible sibling subclass until it can
  match on one. This is done by literally changing the class of the object.
  This is particularly useful when mutating classes like
  'if' statements because removal or addition of the 'else' clause no
  longer requires any analysis to determine if the source text is still
  valid.

* Code Generation
** How many Lines are generated?
The actual code used for generation is about 2-3K LoC.

 - ~18K LoC for C
 - ~50K LoC for C ++
 - ~20K LoC for JavaScript
 - ~35K LoC for Rust
 - ~20K LoC for Python
 - ~110K LoC for TypeScript

Large amount of saved developer time.
- These are generated at build time on the fly
- They're cached by the lisp implementation if the files don't change
  between the last compilation

** Process
[Make a diagram for this if possible]

- Identifies every available tree-sitter module available for the system.
- Both the node-types and grammar JSON files are read in
- The initial classes are created based on the node-types file and stored in
  a hash table so that they can be modified during code generation
  - Additional slots, superclasses, and patches to node structures are added
    as specified by several special variables defined at the top-level.
- The grammar JSON is extensively patched.
  - The rule/production is traversed looking for places where two
    unnamed/unnamed/terminal symbols occur back-to-back without either of
    them being assigned to a slot. Internal-ast slots are assigned in between
    these such that the whitespace and/or comments can be stored and
    reproduced.
  - All aliases have their rule/production added to the node types it aliases
    to by wrapping the rule in a choice/alternation and adding a new branch
    with it. This solved several reoccuring problems.
  - Several different versions of the rule are generated. Each serves a
    different purpose: unchanged json rule, pruned rule, and collapsed
    rule. The pruned rule removed any subtree which doesn't contain
    information stored that is to be stored on an object and replaces that
    subtree with nil. This is used extensively for matching parse trees and
    ASTs. The collapsed rule collapses nested choices and sequences on
    themselves, and further removes any nil's from the tree. It is
    only used for detecting problematic rules.
- Problematic rules are identified and printed out at compile time. These
  are the rules where the correct reproduction of source text could be
  ambiguous due to lack of stored information.
- Choice expansion subclasses are generated
- Rules, choice expansion subclass information are attached to slots with
  class allocation.
- Several methods are generated.
  - A conversion from a parse tree to a tree-sitter-ast.
  - An output transformation which transfroms an AST into source-text.
    This inserts any implicit text.

*  AST creation
[Make a diagram for this if possible]

- cl-tree-sitter calls tree-sitter SO and converts the C structure into a tree.
- transform-parse-tree traverses the tree and runs transform-parse-tree
  methods on any subtree which has a transformation defined. This allows for
  bugs and extra features to be patched by SEL.
- The transformed parse tree has surrounding text annotations added to it and
  inner whitespace subtrees are created for any whitespace that can't be
  attached to a child AST.
- The parse tree is passed to match-parsed-children and a valid choice
  expansion subclass is found if needed. Otherwise, it simply checks if the
  class matches if there aren't any subclasses. If it fails to match, an error
  occurs.
- An instance of the relevant class is instantiated and its slots are populated
  with its named children, internal ASTs, and surrounding text.
- The AST has its indentation converted from a string into a number.
