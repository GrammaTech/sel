<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This file documents the Software Evolution library

Copyright (C) 2014-2018 Eric Schulte and GrammaTech

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with the Invariant Section being "GNU GENERAL PUBLIC LICENSE,"
A copy of the license is included in the section entitled
"GNU Free Documentation License." -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>sel-cp-condition-synthesis (Software Evolution Library)</title>

<meta name="description" content="sel-cp-condition-synthesis (Software Evolution Library)">
<meta name="keywords" content="sel-cp-condition-synthesis (Software Evolution Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="SEL-Packages.html" rel="up" title="SEL Packages">
<link href="sel_002dcp_002dfault_002dloc.html" rel="next" title="sel-cp-fault-loc">
<link href="sel_002dcp_002dclang_002dtokens.html" rel="prev" title="sel-cp-clang-tokens">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<span id="sel_002dcp_002dcondition_002dsynthesis"></span><div class="header">
<p>
Next: <a href="sel_002dcp_002dfault_002dloc.html" accesskey="n" rel="next">sel-cp-fault-loc</a>, Previous: <a href="sel_002dcp_002dclang_002dtokens.html" accesskey="p" rel="prev">sel-cp-clang-tokens</a>, Up: <a href="SEL-Packages.html" accesskey="u" rel="up">SEL Packages</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="sel_002dcp_002dcondition_002dsynthesis-1"></span><h3 class="section">C.43 sel-cp-condition-synthesis</h3>
<span id="Class-add_002dcondition"></span><dl>
<dt id="index-add_002dcondition">Class: <strong>add-condition</strong></dt>
<dd><p>Class precedence list: <code>add-condition, clang-mutation, mutation, oid-object, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library/software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library/software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Guard a statement with an abstract condition.
<code>e</code>.g., foo; becomes if(abst_cond()) foo;.
</p></dd></dl>
<span id="Class-if_002dto_002dwhile"></span><dl>
<dt id="index-if_002dto_002dwhile">Class: <strong>if-to-while</strong></dt>
<dd><p>Class precedence list: <code>if-to-while, clang-mutation, mutation, oid-object, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library/software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library/software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Replace an if statement with a while on the same condition.
<code>e</code>.g., if(foo) becomes while(foo).
</p></dd></dl>
<span id="Class-if_002dto_002dwhile_002dtighten_002dcondition"></span><dl>
<dt id="index-if_002dto_002dwhile_002dtighten_002dcondition">Class: <strong>if-to-while-tighten-condition</strong></dt>
<dd><p>Class precedence list: <code>if-to-while-tighten-condition, if-to-while, tighten-condition, refine-condition, clang-mutation, mutation, oid-object, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library/software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library/software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Combine if-to-while replacement with a tighter condition.
<code>e</code>.g., if(foo) becomes while(foo <code>&amp;&amp;</code> !abst_cond()).
</p></dd></dl>
<span id="Class-insert_002delse_002dif"></span><dl>
<dt id="index-insert_002delse_002dif">Class: <strong>insert-else-if</strong></dt>
<dd><p>Class precedence list: <code>insert-else-if, tighten-condition, refine-condition, clang-mutation, mutation, oid-object, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library/software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library/software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>insert an (empty) else-if clause after an existing if, e.g., if(foo) bar; becomes if(foo) bar; else if(abst_cond()) ;.
</p></dd></dl>
<span id="Class-loosen_002dcondition"></span><dl>
<dt id="index-loosen_002dcondition">Class: <strong>loosen-condition</strong></dt>
<dd><p>Class precedence list: <code>loosen-condition, refine-condition, clang-mutation, mutation, oid-object, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library/software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library/software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Add an abstract condition to make a guard more permissive.
<code>e</code>.g., if(foo) becomes if(foo || abst_cond()).
</p></dd></dl>
<span id="Class-refine_002dcondition"></span><dl>
<dt id="index-refine_002dcondition">Class: <strong>refine-condition</strong></dt>
<dd><p>Class precedence list: <code>refine-condition, clang-mutation, mutation, oid-object, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library/software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library/software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Add an additional Boolean clause to an if condition.
</p></dd></dl>
<span id="Class-tighten_002dcondition"></span><dl>
<dt id="index-tighten_002dcondition">Class: <strong>tighten-condition</strong></dt>
<dd><p>Class precedence list: <code>tighten-condition, refine-condition, clang-mutation, mutation, oid-object, standard-object, t</code>
</p>
<p>Slots:
</p><ul>
<li> <code>targeter</code> &mdash; initarg: <code>:targeter<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library/software-evolution-library:targeter</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> targets.
</p></li><li> <code>picker</code> &mdash; initarg: <code>:picker<!-- /@w --></code>; reader: <code><span class="nolinebreak">software-evolution-library/software-evolution-library:picker</span><!-- /@w --></code>

<p>A function from software <code>-&gt;</code> random target.
</p></li></ul>

<p>Add an abstract condition to make a guard less permissive.
<code>e</code>.g., if(foo) becomes if(foo <code>&amp;&amp;</code> !abst_cond()).
</p></dd></dl>
<span id="Variable-_002aabst_002dcond_002dattempts_002a"></span><dl>
<dt id="index-_002aabst_002dcond_002dattempts_002a">Variable: <strong>*abst-cond-attempts*</strong></dt>
<dd><p>Maximum number of combinations for abst_cond() values to attempt before
discarding a repair.
</p></dd></dl>
<span id="Variable-_002asynth_002dcondition_002dattempts_002a"></span><dl>
<dt id="index-_002asynth_002dcondition_002dattempts_002a">Variable: <strong>*synth-condition-attempts*</strong></dt>
<dd><p>Maximum number of synthesized conditions to test before discarding a repair.
</p></dd></dl>
<span id="Function-entails"></span><dl>
<dt id="index-entails">Function: <strong>entails</strong> <em>env condition result</em></dt>
<dd><p>Check whether the value of <code>condition</code> in environment <code>env</code> is consistent
with the desired <code>result</code>, returning <code>t</code> if so and <code>nil</code> otherwise.
</p>
<ul>
<li> <code>env</code> a list of assignment triples (&quot;var&quot; &quot;type&quot; &quot;value&quot;)
</li><li> <code>condition</code> a 4-tuple ([:eq|:neq] &quot;var&quot; &quot;type&quot; &quot;value&quot;)
</li><li> <code>result</code> a string: either &quot;0&quot; or &quot;1&quot;.

</li></ul>
<p>The condition representing &quot;(x <code>==</code> v)&quot; in
an environment where x is assigned the value v is consistent with the
result. Similarly, the condition representing &quot;!(x <code>==</code> v)&quot; in an
environment where x is assigned the value v is not consistent with the
result.
</p></dd></dl>
<span id="Function-find_002dbest_002dcondition"></span><dl>
<dt id="index-find_002dbest_002dcondition">Function: <strong>find-best-condition</strong> <em>recorded-results envs conditions</em></dt>
<dd><p>Return the condition which correctly matches the largest number of recorded
results when evaluated under the corresponding environment.
* <code>recorded-results</code> list of strings &quot;0&quot; or &quot;1&quot; indicating values of abstract
conditions.
* <code>envs</code> list of environments, which are a list of assignment triples
(&quot;var&quot; &quot;type&quot; &quot;value&quot;)
* <code>conditions</code> a 4-tuple ([:eq|:neq] &quot;var&quot; &quot;type&quot; &quot;val&quot;) representing a
condition (var <code>==</code> val) or !(var <code>==</code> val)
</p></dd></dl>
<span id="Function-flip"></span><dl>
<dt id="index-flip">Function: <strong>flip</strong> <em>bit-str</em></dt>
<dd><p>Return the string obtained by dropping all trailing 1s from <code>bit-str</code> and then
changing the final 0 to a 1.
* <code>bit-str</code> a string containing only &quot;0&quot; and &quot;1&quot;
</p></dd></dl>
<span id="Function-instrumentation_002dexprs"></span><dl>
<dt id="index-instrumentation_002dexprs">Function: <strong>instrumentation-exprs</strong> <em>obj point type</em></dt>
<dd><p>Return a list of additional expressions to instrument during condition
synthesis. Finds all expressions of the given type which are in scope
at the repair point, and generates comparisons for all of them. These
expressions can be passed as <code>extra-instrumentation-exprs</code> to
&lsquo;synthesize-condition&rsquo;.
</p>
<ul>
<li> <code>obj</code> software object
</li><li> <code>point</code> repair point for which to generate instrumentation
</li><li> <code>type</code> type description alist (:types :array :pointer :compare)
       Where :compare is a format template for the comparison
       expressions, and the other fields are matched against
       the type <code>db</code>.
</li></ul>
</dd></dl>
<span id="Function-synthesize_002dcondition"></span><dl>
<dt id="index-synthesize_002dcondition">Function: <strong>synthesize-condition</strong> <em>software test-suite repair-mutation &amp;key extra-instrumentation-exprs</em></dt>
<dd><p>Apply <code>repair-mutation</code> to <code>software</code>, attempting to synthesize a
condition which increases the number of tests in <code>test-suite</code> that pass.
Return a copy of <code>software</code> with a synthesized condition inserted at the
target of <code>repair-mutation</code>.
</p>
<ul>
<li> <code>test-suite</code> a &lsquo;test-suite&rsquo; containing both positive and negative test cases.
</li><li> <code>repair-mutation</code> a &lsquo;mutation&rsquo; that inserts an abstract condition.
</li><li> <code>extra-instrumentation-exprs</code> a list of additional expressions to
  print at each instrumentation point. It should have the form &rsquo;((expr
  . ((:type . &quot;typename&quot;)))). These expressions can be generated
  with &lsquo;instrumentation-exprs&rsquo;.
</li></ul>
</dd></dl>
<span id="Function-synthesize_002dconditions"></span><dl>
<dt id="index-synthesize_002dconditions">Function: <strong>synthesize-conditions</strong> <em>envs</em></dt>
<dd><p>For each assignment in each environment in <code>envs</code>, create a list of condition
triples representing (x <code>==</code> v) and !(x <code>==</code> v).
Return a list of synthesized condition triples, by prepending :eq or :neq to each
assignment in the environments in <code>env</code>.
* <code>envs</code> a list of environments, each of which contains a list of triples:
(&quot;var&quot; &quot;type&quot; &quot;value&quot;).
</p></dd></dl>
<span id="Generic_002dFunction-valid_002dtargets"></span><dl>
<dt id="index-valid_002dtargets">Generic Function: <strong>valid-targets</strong> <em>mutation software</em></dt>
<dd><p>Return a list of the locations in <code>software</code> where <code>mutation</code> can be applied.
</p></dd></dl>
<span id="Method-valid_002dtargets-_0028_0028mutation-insert_002delse_002dif_0029-software_0029"></span><dl>
<dt id="index-valid_002dtargets-1">Method: <strong>valid-targets</strong> <em>(mutation insert-else-if) software</em></dt>
<dd><p>Return a list of the locations in <code>software</code> where &lsquo;insert-else-if&rsquo; <code>mutation</code> can be applied.
</p></dd></dl>
<span id="Method-valid_002dtargets-_0028_0028mutation-if_002dto_002dwhile_0029-software_0029"></span><dl>
<dt id="index-valid_002dtargets-2">Method: <strong>valid-targets</strong> <em>(mutation if-to-while) software</em></dt>
<dd><p>Return a list of the locations in <code>software</code> where &lsquo;if-to-while&rsquo; <code>mutation</code> can be applied.
</p></dd></dl>
<span id="Method-valid_002dtargets-_0028_0028mutation-add_002dcondition_0029-software_0029"></span><dl>
<dt id="index-valid_002dtargets-3">Method: <strong>valid-targets</strong> <em>(mutation add-condition) software</em></dt>
<dd><p>Return a list of the locations in <code>software</code> where &lsquo;add-condition&rsquo; <code>mutation</code> can be applied.
</p></dd></dl>
<span id="Method-valid_002dtargets-_0028_0028mutation-refine_002dcondition_0029-software_0029"></span><dl>
<dt id="index-valid_002dtargets-4">Method: <strong>valid-targets</strong> <em>(mutation refine-condition) software</em></dt>
<dd><p>Return a list of the locations in <code>software</code> where &lsquo;refine-condition&rsquo; <code>mutation</code> can be applied.
</p></dd></dl>

<hr>
<div class="header">
<p>
Next: <a href="sel_002dcp_002dfault_002dloc.html" accesskey="n" rel="next">sel-cp-fault-loc</a>, Previous: <a href="sel_002dcp_002dclang_002dtokens.html" accesskey="p" rel="prev">sel-cp-clang-tokens</a>, Up: <a href="SEL-Packages.html" accesskey="u" rel="up">SEL Packages</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
