<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This file documents the Software Evolution library

Copyright (C) 2014-2018 Eric Schulte and GrammaTech

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with the Invariant Section being "GNU GENERAL PUBLIC LICENSE,"
A copy of the license is included in the section entitled
"GNU Free Documentation License." -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Condition Synthesis (Software Evolution Library)</title>

<meta name="description" content="Condition Synthesis (Software Evolution Library)">
<meta name="keywords" content="Condition Synthesis (Software Evolution Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Components.html" rel="up" title="Components">
<link href="Fault-Localization.html" rel="next" title="Fault Localization">
<link href="Clang-C-Tokenizer.html" rel="prev" title="Clang C Tokenizer">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<span id="Condition-Synthesis"></span><div class="header">
<p>
Next: <a href="Fault-Localization.html" accesskey="n" rel="next">Fault Localization</a>, Previous: <a href="Clang-C-Tokenizer.html" accesskey="p" rel="prev">Clang C Tokenizer</a>, Up: <a href="Components.html" accesskey="u" rel="up">Components</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Condition-Synthesis-1"></span><h3 class="section">3.5 Condition Synthesis</h3>
<span id="index-condition_002dsynthesis"></span>
<p>Condition synthesis is a program repair technique that introduces or alters
guard conditions in source code using a set of passing and failing unit tests
as a guide and measure of success. This approach is based largely on that
described in <cite>Staged Program Repair with Condition Synthesis</cite> available at
<a href="http://groups.csail.mit.edu/pac/patchgen/papers/spr-fse15.pdf">http://groups.csail.mit.edu/pac/patchgen/papers/spr-fse15.pdf</a>.
</p>

<span id="Performing-Condition-Synthesis"></span><h4 class="subsection">3.5.1 Performing Condition Synthesis</h4>

<p>At a high level, condition synthesis will:
</p><ol>
<li> <a href="#condition_002dsynthesis_002dintroduce">Introduce an abstract condition</a> into the source code

</li><li> Run <em>negative unit tests</em> &mdash; tests that should pass, but fail
due to the presence of the defect &mdash; to
<a href="#condition_002dsynthesis_002didentify_002dvalues">identify a series of
abstract condition values</a> that would allow the failing tests to pass.

</li><li> For each passing test, <a href="#condition_002dsynthesis_002dtest_002dconditions">test possible (concrete) conditions</a> to see if there are any that satisfy each value in the identified series of abstract condition values.

</li><li> If one or more such conditions are found, replace the abstract
condition in the source code with the
<a href="#condition_002dsynthesis_002dbest_002dcondition">&ldquo;best&rdquo; such condition</a>.

</li></ol>

<p>More details about each of these steps are provided in the following sections.
</p>
<span id="condition_002dsynthesis_002dintroduce"></span><span id="Introduce-An-Abstract-Condition"></span><h4 class="subsubsection">3.5.1.1 Introduce An Abstract Condition</h4>
<p>Abstract conditions are represented by a call to the
<code>abst_cond()</code> function. Mutations are used to perform the
insertion. The <a href="#condition_002dsynthesis_002dmutations">set of available
mutations</a> is listed below.
</p>

<span id="condition_002dsynthesis_002didentify_002dvalues"></span><span id="Identify-Abstract-Condition-Values"></span><h4 class="subsubsection">3.5.1.2 Identify Abstract Condition Values</h4>
<p>The C implementation of <code>abst_cond()</code> refers to a set of environment
variables in order to determine which value to return.
</p>
<ul>
<li> <code>ABST_COND_DEFAULT</code> specifies the default return value for
<code>abst_cond()</code>. If not specified, the default return value is 0.

</li><li> <code>ABST_COND_VALUES</code> is a list of zeroes and ones which should be
returned in that order. For example, &ldquo;001&rdquo; would indicate that the
first two invocations of <code>abst_cond()</code> should return 0, and the
third should return 1. If all values in the list are consumed, all
subsequent invocations will return the default value.

</li><li> <code>ABST_COND_LOOP_COUNT</code> is used to control looping behavior. Set
to integer N to specify that every Nth invocation of
<code>abst_cond()</code> will return 1 and all other invocations return the
default value.

</li></ul>



<p>The implementation of <code>abst_cond()</code> also records the value
returned each time the function is invoked.
</p>

<p>The procedure for identifying abstract condition values depends on whether the condition is looping or non-looping.
</p>
<table>
<tr><td>Non-Looping Conditions</td><td><ol>
<li> For each failing test, run the test with a default value of 0.

</li><li> If the test continues failing, try &ldquo;flipping&rdquo; the
         last 0 to a 1 in the series of recorded abstract condition
         values and re-running the test. This is based on the
         assumption that tests are &ldquo;mostly correct,&rdquo; and it&rsquo;s only
         one of the latest branching conditions that was incorrect.

</li><li> Do this up to a specified cut-off (defined in
         <a href="sel_002dcp_002dcondition_002dsynthesis.html#Variable-_002aabst_002dcond_002dattempts_002a"><code>*abst-cond-attempts*</code></a>).

</li><li> If no series is found that causes the unit test to
         pass, re-run the test with a default value of 1 before giving
         up.

</li><li> If a successful series of abstract condition values is
         found, record the series and the values of in-scope variables
         at each evaluation of the abstract condition.
         </li></ol></td></tr>
<tr><td>Looping Conditions</td><td><ol>
<li> For each failing test, run the test with a loop-count
         of 0. This has the effect of always returning 1 for each
         invocation of <code>abst_cond()</code>.

</li><li> If the test continues failing, try incrementing the
         loop-count so that <code>abst_cond()</code> only returns 1
         periodically for a period of increasing length.

</li><li> Do this up to a specified cut-off (defined in
         <a href="sel_002dcp_002dcondition_002dsynthesis.html#Variable-_002aabst_002dcond_002dattempts_002a"><code>*abst-cond-attempts*</code></a>).

</li><li> If no series is found that causes the unit test to
         pass, re-run the test with a default value of 1 before giving
         up.

</li><li> If a successful series of abstract condition values is
         found, record the series and the values of in-scope variables
         at each evaluation of the abstract condition.
         </li></ol></td></tr>
</table>

<span id="condition_002dsynthesis_002dtest_002dconditions"></span><span id="Test-Possible-Conditions"></span><h4 class="subsubsection">3.5.1.3 Test Possible Conditions</h4>

<p>For each test with a satisfying series of values for the abstract condition,
we have recorded an environment showing the values of in-scope variables at
the time the condition was evaluated. For each variable, var, that is
recorded with a value, v, we synthesize two conditions: <code>(var == v)</code> and
<code>!(var == v)</code>.
</p>
<p>Then for each condition, we can determine whether it would allow a unit test to
pass by checking whether it is entailed by that test&rsquo;s series of environments
and desired abstract condition values.
</p>

<span id="condition_002dsynthesis_002dbest_002dcondition"></span><span id="Select-_0060_0060Best_0027_0027-Condition"></span><h4 class="subsubsection">3.5.1.4 Select &ldquo;Best&rdquo; Condition</h4>

<p>The condition which satisfies the largest number of environment and
abstract condition value pairs is selected as the &ldquo;best&rdquo; condition,
applied, and tested. If this condition repairs all unit tests, it is
returned as the solution. If it improves the fitness (i.e., causes
more unit tests to pass than before), then it is retained as the
&ldquo;current best&rdquo; solution. In this case, up to
<a href="sel_002dcp_002dcondition_002dsynthesis.html#Variable-_002asynth_002dcondition_002dattempts_002a"><code>*synth-condition-attempts*</code></a> other conditions are
tested to see if they offer additional improvements to the fitness.
</p>

<span id="API-Support-for-Condition-Synthesis"></span><h4 class="subsection">3.5.2 API Support for Condition Synthesis</h4>

<p>API support for style features is documented in section
<a href="SEL-Concept-Index.html#api_002dcondition_002dsynthesis">API | Condition Synthesis</a>. We provide a
brief overview here.
</p>
<span id="condition_002dsynthesis_002dmutations"></span><p>Mutations (subclasses of <a href="software_002devolution_002dlibrary.html#Class-mutation"><code>mutation</code></a>)
</p>
<ul>
<li> <a href="sel_002dcp_002dcondition_002dsynthesis.html#Class-add_002dcondition"><code>add-condition</code></a>
</li><li> <a href="sel_002dcp_002dcondition_002dsynthesis.html#Class-if_002dto_002dwhile_002dtighten_002dcondition"><code>if-to-while-tighten-condition</code></a>
</li><li> <a href="sel_002dcp_002dcondition_002dsynthesis.html#Class-if_002dto_002dwhile"><code>if-to-while</code></a>
</li><li> <a href="sel_002dcp_002dcondition_002dsynthesis.html#Class-insert_002delse_002dif"><code>insert-else-if</code></a>
</li><li> <a href="sel_002dcp_002dcondition_002dsynthesis.html#Class-loosen_002dcondition"><code>loosen-condition</code></a>
</li><li> <a href="sel_002dcp_002dcondition_002dsynthesis.html#Class-tighten_002dcondition"><code>tighten-condition</code></a>
</li></ul>


<p>Methods on Mutations
</p>
<ul>
<li> <a href="sel_002dcp_002dcondition_002dsynthesis.html#Function-synthesize_002dcondition"><code>synthesize-condition</code></a>
</li><li> <a href="sel_002dcp_002dcondition_002dsynthesis.html#Generic_002dFunction-valid_002dtargets"><code>valid-targets</code></a>
</li><li> <a href="sel_002dcp_002dcondition_002dsynthesis.html#Function-instrumentation_002dexprs"><code>instrumentation-exprs</code></a>
</li></ul>


<span id="Condition-Synthesis-Example"></span><h4 class="subsection">3.5.3 Condition Synthesis Example</h4>

<p>Function <code>try-synthesis</code> will attempt condition synthesis on all valid
target locations for each of the possible guard mutations described above.
</p>
<div class="lisp">
<pre class="lisp">(defun try-synthesis (types variant test-suite)
  &quot;Attempt condition synthesis for all mutation types and valid
locations in variant. Return the first successful result result.&quot;
  (let ((obj (copy variant)))
    (when (bad-stmts obj)
      (loop
       for type in '(add-condition
                     insert-else-if
                     if-to-while-tighten-condition
                     loosen-condition
                     tighten-condition)
       for valid-targets = (valid-targets (make-instance type)
                                          obj)
       do
       (loop
        for target in valid-targets
        for i upfrom 0
        for mutation = (make-instance type :targets target)
        for result =
        (handler-case
         (synthesize-condition obj test-suite mutation)
         ;; Build failures can happen if we pick a bad
         ;; condition to modify. Ignore them and try the
         ;; next target.
         (phenome (err)
                  (note 1 &quot;~a~%&quot; err)))
        do (when result
             (setf (fitness result) (test-fitness result))
             (return-from try-synthesis result)))))))
</pre></div>

<hr>
<div class="header">
<p>
Next: <a href="Fault-Localization.html" accesskey="n" rel="next">Fault Localization</a>, Previous: <a href="Clang-C-Tokenizer.html" accesskey="p" rel="prev">Clang C Tokenizer</a>, Up: <a href="Components.html" accesskey="u" rel="up">Components</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
