<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This file documents the Software Evolution library

Copyright (C) 2014-2018 Eric Schulte and GrammaTech

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with the Invariant Section being "GNU GENERAL PUBLIC LICENSE,"
A copy of the license is included in the section entitled
"GNU Free Documentation License." -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>ASM Super-Mutants (Software Evolution Library)</title>

<meta name="description" content="ASM Super-Mutants (Software Evolution Library)">
<meta name="keywords" content="ASM Super-Mutants (Software Evolution Library)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Super_002dMutants.html" rel="up" title="Super-Mutants">
<link href="Utilities.html" rel="next" title="Utilities">
<link href="Clang-Super_002dMutants.html" rel="prev" title="Clang Super-Mutants">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<span id="ASM-Super_002dMutants"></span><div class="header">
<p>
Next: <a href="Utilities.html" accesskey="n" rel="next">Utilities</a>, Previous: <a href="Clang-Super_002dMutants.html" accesskey="p" rel="prev">Clang Super-Mutants</a>, Up: <a href="Super_002dMutants.html" accesskey="u" rel="up">Super-Mutants</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="ASM-Super-Mutants"></span><h4 class="subsection">3.8.2 ASM Super Mutants</h4>
<span id="index-asm_002dsuper_002dmutants"></span>


<span id="asm_002dsuper_002dmutant-Overview"></span><h4 class="subsection">3.8.3 <code>asm-super-mutant</code> Overview</h4>

<p><code>asm-super-mutant</code> software objects are designed to provide the
benefits of <code>super-mutant</code> to assembly programs.  Its primary
advantage is the ability to evaluate the fitness of large numbers
of variants of a given target function, in a single process, in a
minimal amount of time.  Avoiding the per-process overhead in
fitness evaluations results in orders-of-magnitude improvements of
efficiency.
</p>
<p>The <code>asm-super-mutant</code> has been tested with <code>at&amp;t</code> and Intel syntax
and for nasm (Intel) and gas <code>(at&amp;t) </code>assemblers. Like <code>asm-heap</code>,
it won&rsquo;t work for arbitrary macro-heavy assembler code.
</p>
<p>The <code>asm-super-mutant</code> derives from an <code>asm-heap</code> and also
contains the <code>super-mutant</code> methods.
</p>
<p>The <code>asm-super-mutant</code> initially contains a complete program
executable (initialized from an asm format file).  In addition it
contains a specification of a target function within the overall
program.  The target function (specified either by name or as
start and end addresses) is used to mark a range of lines within
the overall program (returned by CREATE-TARGET).
</p>
<p>Like a <code>super-mutant</code>, the <code>asm-super-mutant</code> maintains a collection
of <code>mutants</code>, each one being an instance of the <code>asm-heap</code> software
object.  Each <code>mutant</code> is a variant of the target function.
</p>
<span id="Fitness-Evaluation"></span><h4 class="subsection">3.8.4 Fitness Evaluation</h4>

<p>To perform fitness evaluation, the <code>asm-supermutant</code> performs the
following steps:
</p>
<ul>
<li> The <code>mutants</code> are combined into a single assembly file (.asm),
  which also includes the data sections and declarations necessary
  to be able to assemble. Every <code>mutant</code> is given a unique label
  (variant_0, (variant_1, ... variant_n), and those labels are
  exported.

</li><li> Input/output data, see see <a href="#i_002do_002dfile_002dformat">I/O File Format</a>,
  is appended to the asm file, and is used to determine fitness of
  each variant.  A set of I/O data (memory and register contents)
  is provided for each test run of the target function.

</li><li> The .asm file is assembled with <code>nasm</code>.

</li><li> A C harness file (asm-super-mutant-fitness.c), which runs and
  evaluates variants, is compiled and linked to the compiled
  object file.  The C code provides functions to set up each test,
  execute each variant, calculate the variant&rsquo;s fitness and
  aggregate results.  Currently the fitness is set to the number
  of executed instructions as collected by the linux Performance
  Application Programming Interface <code>(papi)</code>
  (<a href="http://icl.utk.edu/papi/">http://icl.utk.edu/papi/</a>) using the PAPI_TOT_INS event.
  The harness contains some sandboxing code to handle differences
  in execution address of the original test runs and the fitness
  runs, manage heap memory pages, and trap and handle segment
  violations and function crashes.

</li><li> Each variant is assigned an array of fitness results, with each
  item in in the array representing the number of instructions
  required to execute the function on a given test run (i.e., I/O
  pair).  If the variant did not properly pass the tests (I/O data
  did not match) then <code>maxint</code> is assigned as the fitness variable
  for that test run (since smaller is better, this is the worst
  possible fitness).

</li><li> The fitness harness writes an array of all test results for all
  variants to the <code>*standard-output*</code> stream.

</li><li> The compiled/linked fitness executable is executed by the
  fitness test and the results (written to *STANDARD-OUTPUT*) are
  parsed and stored in Lisp data structures (as an array of
  arrays). This is cached on the <code>asm-super-mutant</code> instance, and
  can be obtained with the <code>fitness</code> method.

</li></ul>
<span id="Tool-Dependencies"></span><h4 class="subsection">3.8.5 Tool Dependencies</h4>

<p>The <code>asm-super-mutant</code> currently depends upon:
</p><ul>
<li> Nasm to assemble the generated fitness program
</li><li> Clang (version 6 or later) to compile and link the fitness program.
</li><li> Assembly code or a high quality lifter (e.g., GrammaTech&rsquo;s
  CodeSurfer for Binaries) to disassemble an original binary
  program.
</li><li> A method of collecting binary I/O pairs from a series of dynamic
  tests in the format described below,
  see <a href="#i_002do_002dfile_002dformat">I/O File Format</a>

</li></ul>
<p>The <code>asm-heap</code>, which is the basis for <code>asm-super-mutant</code> and all its
variants, uses Intel-format assembly code (Nasm-compatible).
In the near future we are planning to switch to <code>at&amp;t</code> assembler syntax
and to replace Nasm with a more efficient assembler.
</p>
<span id="i_002do_002dfile_002dformat"></span><span id="I_002fO-File-Format"></span><h4 class="subsection">3.8.6 I/O File Format</h4>

<p>The file is <code>ascii</code>.  In internal tests it s generated using the <code>ibm</code>
<code>pin</code> tool to observe the execution of a binary program on a test
suite.
</p>
<p>An I/O file contains 1 or more test runs, and each test run
comprises 2 sections: Input Data and Output Data.
</p>
<p>The format of Input Data is identical to Output Data, except that
the set of registers that are included may differ.
</p>
<p>Each section (Input Data or Output Data) contains a section of
register lines, followed by a section of memory lines.
</p>
<p>In the register section, the values of all significant registers
are specified, one per line. This includes general-purpose
registers <code>(gpr) </code>i.e. rax rbx, etc. followed by floating-point
registers ymm0-15.
</p>
<p>Following the registers are values of relevant memory
addresses. These include any memory addresses read or written by
the function being tested.  If the function depends on a global
variable for instance, it will be included.
</p>
<p>In the first section (registers) each line contains:
</p><ul>
<li> The name of the register, followed by the bytes in big-endian order,
</li><li> The register name is separated from the bytes by whitespace, but any
  other whitespace on the line should be ignored.

</li></ul>
<p>For example, the line,
</p>
<div class="example">
<pre class="example">    %rax    00 00 00 00 00 00 01 00
</pre></div>

<p>indicates that register rax should contain the value 256.
</p>
<p>For the general-purpose registers rax, rcx, rdx, rbx, rsp, rbp,
rsi, rdi, r8, r9, r10, r11, r12, r13, r14, and r15, all eight
bytes will be explicitly included on the line.  For the <code>simd</code>
registers ymm0-ymm15, all 32 bytes will be explicit.
</p>
<p>Memory would be specified with one 8-byte long per line, in
big-endian order, consisting of an address, followed by a mask
indicating which bytes are live, followed by the bytes
themselves. The mask would be separated from the address and bytes
by whitespace, but again any other whitespace on the line should
be ignored.
</p>
<p>For example, the line,
</p>
<div class="example">
<pre class="example">    00007fbb c1fcf768   v v v v v v v .   2f 04 9c d8 3b 95 7c 00
</pre></div>

<p>indicates that the byte at address 0x7fbbc1fcf768 has value 0x00,
the byte at 0x7fbbc1fcf769 has value 0x7c, and so forth
(big-endian order).  Note that bytes 0x7fbbc1fcf769-0x7fbbc1fcf76f
are live (indicated with &quot;v&quot;) while 0x7fbbc1fcf768 is not
(indicated with &quot;.&quot;).
</p>
<span id="Components-2"></span><h4 class="subsection">3.8.7 Components</h4>

<p><code>asm-super-mutant</code> software object consists of:
</p>
<ul>
<li> The <code>asm-heap</code>, which is typically based on a file of assembly
  source code.  The <code>asm-super-mutant</code> object contains the whole original
  binary application (in assembler source format).

</li><li> Input/output specifications, in a specific file format as
  generated using the Intel monitoring application and our Python
  scripts

</li><li> Data object original addresses (&quot;sanity file&quot;).

</li><li> Function boundary deliminators which determines the target of
  the mutation and evaluation.

</li></ul>
<p>Note that the struct <code>input-specification</code> is a bit of a misnomer as
it is used here for both input specification and output
specification (their formats are identical so we use the same
struct for both).
</p>
<p><code>super-mutant</code> slots:
</p><ul>
<li> <code>mutants</code> will contain a list of <code>asm-heap</code> objects.
</li><li> <code>super-soft</code> caches a combined <code>asm-heap</code> representing the output
  fitness program.
</li><li> <code>phenome-results</code> caches the results obtained from calling the <code>phenome</code>
  method.

</li></ul>
<span id="Current-Limitations"></span><h4 class="subsection">3.8.8 Current Limitations</h4>

<ul>
<li> Functions which use floating point data as input or outputs will
  not evaluate correctly. The fitness file that is generated does
  not yet handle <code>ymm0</code>-<code>ymm15</code> registers, which are used to
  pass floating point values in x86_64 binaries.
</li><li> Currently only leaf functions (functions which do not call any other
  functions) are supported.
</li><li> The fitness test program does not do full sandboxing. It does protect
  against segment violations (those will typically result in a
  +worst-c-fitness+ rating) but a function variant could potentially write
  on other code or data without triggering a segment violation, and this
  will not get trapped. When that happens it will possibly invalidate
  further fitness tests, or cause the whole fitness program to crash,
  resulting in all variants to come back as +worst-c-fitness+.

</li></ul>
<span id="Installing-PAPI-on-Ubuntu"></span><h4 class="subsection">3.8.9 Installing PAPI on Ubuntu</h4>
<p>Fitness evaluation requires the PAPI component and the Linux Perf
functionality. Building the fitness evaluation program (on the fly
during fitness evaluation) requires a C program to compile and link
to PAPI. This also requires a .h file to compile.
</p>
<p>To install papi:
</p>
<p>sudo apt-get install papi-tools
</p>
<p>To install perf:
</p>
<div class="example">
<pre class="example">    sudo apt-get install linux-tools-common linux-tools-generic linux-tools-`uname -r`
</pre></div>

<p>Perf requires system permission to run. In linux, the value in
/proc/sys/kernel/perf_event_paranoid should be set to 1
(Disallow <code>cpu</code> event access by users without CAP_SYS_ADMIN).
This is typically set to 3 (maximum paranoia) by default.
</p>
<p>This can be accomplished with the following:
  sudo sh -c &rsquo;echo 1 &gt;/proc/sys/kernel/perf_event_paranoid&rsquo;
  sudo sysctl -w kernel.perf_event_paranoid=1
  You may need to use:
   sudo sh -c &rsquo;echo kernel.perf_event_paranoid=1 <code>&gt;</code> /etc/sysctl.d/local.conf&rsquo;
   and then reboot for it to take effect.
</p>
<p>It&rsquo;s also a good idea to turn off randomizing of address base
(to get more consistency):
  sudo sh -c &rsquo;echo 0 &gt;/proc/sys/kernel/randomize_va_space&rsquo;
  sudo sysctl -w kernel.randomize_va_space=0
  sudo sh -c &rsquo;echo kernel.randomize_va_space=0 <code>&gt;&gt;</code> /etc/sysctl.d/local.conf&rsquo;
</p>
<p>To get necessary include (.h) file for compiling C harness with PAPI
(needed to perform fitness evaluation):
</p>
<p>sudo apt-get install libpapi-dev
</p>
<p>Then you should be able to enter
</p>
<p>papi_avail
</p>
<p>and see a list of available PAPI events.
<code>asm-super-mutant</code> requires the use of the PAPI_TOT_INS event (total number
of instructions executed).
After installation, the PAPI library should be found in one of these
locations:
    /usr/lib/x86_64-linux-gnu/libpapi.so
    /usr/lib/libpapi.so.5.6.1
</p>


<hr>
<div class="header">
<p>
Next: <a href="Utilities.html" accesskey="n" rel="next">Utilities</a>, Previous: <a href="Clang-Super_002dMutants.html" accesskey="p" rel="prev">Clang Super-Mutants</a>, Up: <a href="Super_002dMutants.html" accesskey="u" rel="up">Super-Mutants</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
